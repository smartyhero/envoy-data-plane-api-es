// @generated by protoc-gen-es v2.10.0
// @generated from file contrib/envoy/extensions/filters/network/kafka_mesh/v3alpha/kafka_mesh.proto (package envoy.extensions.filters.network.kafka_mesh.v3alpha, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file contrib/envoy/extensions/filters/network/kafka_mesh/v3alpha/kafka_mesh.proto.
 */
export declare const file_contrib_envoy_extensions_filters_network_kafka_mesh_v3alpha_kafka_mesh: GenFile;

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh
 */
export declare type KafkaMesh = Message<"envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh"> & {
  /**
   * Envoy's host that's advertised to clients.
   * Has the same meaning as corresponding Kafka broker properties.
   * Usually equal to filter chain's listener config, but needs to be reachable by clients
   * (so 0.0.0.0 will not work).
   *
   * @generated from field: string advertised_host = 1;
   */
  advertisedHost: string;

  /**
   * Envoy's port that's advertised to clients.
   *
   * @generated from field: int32 advertised_port = 2;
   */
  advertisedPort: number;

  /**
   * Upstream clusters this filter will connect to.
   *
   * @generated from field: repeated envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition upstream_clusters = 3;
   */
  upstreamClusters: KafkaClusterDefinition[];

  /**
   * Rules that will decide which cluster gets which request.
   *
   * @generated from field: repeated envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule forwarding_rules = 4;
   */
  forwardingRules: ForwardingRule[];

  /**
   * How the consumer proxying should behave - this relates mostly to Fetch request handling.
   *
   * @generated from field: envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.ConsumerProxyMode consumer_proxy_mode = 5;
   */
  consumerProxyMode: KafkaMesh_ConsumerProxyMode;
};

/**
 * Describes the message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.
 * Use `create(KafkaMeshSchema)` to create a new message.
 */
export declare const KafkaMeshSchema: GenMessage<KafkaMesh>;

/**
 * @generated from enum envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.ConsumerProxyMode
 */
export enum KafkaMesh_ConsumerProxyMode {
  /**
   * Records received are going to be distributed amongst downstream consumer connections.
   * In this mode Envoy uses librdkafka consumers pointing at upstream Kafka clusters, what means that these
   * consumers' position is meaningful and affects what records are received from upstream.
   * Users might want to take a look into these consumers' custom configuration to manage their auto-committing
   * capabilities, as it will impact Envoy's behaviour in case of restarts.
   *
   * @generated from enum value: StatefulConsumerProxy = 0;
   */
  StatefulConsumerProxy = 0,
}

/**
 * Describes the enum envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.ConsumerProxyMode.
 */
export declare const KafkaMesh_ConsumerProxyModeSchema: GenEnum<KafkaMesh_ConsumerProxyMode>;

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition
 */
export declare type KafkaClusterDefinition = Message<"envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition"> & {
  /**
   * Cluster name.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * Kafka cluster address.
   *
   * @generated from field: string bootstrap_servers = 2;
   */
  bootstrapServers: string;

  /**
   * Default number of partitions present in this cluster.
   * This is especially important for clients that do not specify partition in their payloads and depend on this value for hashing.
   * The same number of partitions is going to be used by upstream-pointing Kafka consumers for consumer proxying scenarios.
   *
   * @generated from field: int32 partition_count = 3;
   */
  partitionCount: number;

  /**
   * Custom configuration passed to Kafka producer.
   *
   * @generated from field: map<string, string> producer_config = 4;
   */
  producerConfig: { [key: string]: string };

  /**
   * Custom configuration passed to Kafka consumer.
   *
   * @generated from field: map<string, string> consumer_config = 5;
   */
  consumerConfig: { [key: string]: string };
};

/**
 * Describes the message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition.
 * Use `create(KafkaClusterDefinitionSchema)` to create a new message.
 */
export declare const KafkaClusterDefinitionSchema: GenMessage<KafkaClusterDefinition>;

/**
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule
 */
export declare type ForwardingRule = Message<"envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule"> & {
  /**
   * Cluster name.
   *
   * @generated from field: string target_cluster = 1;
   */
  targetCluster: string;

  /**
   * @generated from oneof envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule.trigger
   */
  trigger: {
    /**
     * Intended place for future types of forwarding rules.
     *
     * @generated from field: string topic_prefix = 2;
     */
    value: string;
    case: "topicPrefix";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule.
 * Use `create(ForwardingRuleSchema)` to create a new message.
 */
export declare const ForwardingRuleSchema: GenMessage<ForwardingRule>;

