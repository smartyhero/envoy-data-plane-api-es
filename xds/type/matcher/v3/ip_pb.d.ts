// @generated by protoc-gen-es v2.10.0
// @generated from file xds/type/matcher/v3/ip.proto (package xds.type.matcher.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { CidrRange } from "../../../core/v3/cidr_pb";
import type { Matcher_OnMatch } from "./matcher_pb";

/**
 * Describes the file xds/type/matcher/v3/ip.proto.
 */
export declare const file_xds_type_matcher_v3_ip: GenFile;

/**
 * Matches a specific IP address against a set of possibly overlapping subnets using a trie.
 *
 * @generated from message xds.type.matcher.v3.IPMatcher
 */
export declare type IPMatcher = Message<"xds.type.matcher.v3.IPMatcher"> & {
  /**
   * Match IP address by CIDR ranges.
   *
   * @generated from field: repeated xds.type.matcher.v3.IPMatcher.IPRangeMatcher range_matchers = 1;
   */
  rangeMatchers: IPMatcher_IPRangeMatcher[];
};

/**
 * Describes the message xds.type.matcher.v3.IPMatcher.
 * Use `create(IPMatcherSchema)` to create a new message.
 */
export declare const IPMatcherSchema: GenMessage<IPMatcher>;

/**
 * Specifies a list of IP address ranges and a match action.
 *
 * @generated from message xds.type.matcher.v3.IPMatcher.IPRangeMatcher
 */
export declare type IPMatcher_IPRangeMatcher = Message<"xds.type.matcher.v3.IPMatcher.IPRangeMatcher"> & {
  /**
   * A non-empty set of CIDR ranges.
   *
   * @generated from field: repeated xds.core.v3.CidrRange ranges = 1;
   */
  ranges: CidrRange[];

  /**
   * Match action to apply when the IP address is within one of the CIDR ranges.
   *
   * @generated from field: xds.type.matcher.v3.Matcher.OnMatch on_match = 2;
   */
  onMatch?: Matcher_OnMatch;

  /**
   * Indicates whether this match option should be considered if there is a
   * more specific matcher. Exclusive matchers are not selected whenever a
   * more specific matcher exists (e.g. matcher with a longer prefix) even
   * when the more specific matcher fails its nested match condition.
   * Non-exclusive matchers are considered if the more specific matcher
   * exists but its nested match condition does not entirely match.
   * Non-exclusive matchers are selected in the order of their specificity
   * first (longest prefix first), then the order of declaration next.
   *
   * For example, consider two range matchers: an exclusive matcher *X* on
   * ``0.0.0.0/0`` and a matcher *Y* on ``192.0.0.0/2`` with a nested match
   * condition *Z*. For the input IP ``192.168.0.1`` matcher *Y* is the most
   * specific. If its nested match condition *Z* does not accept the input,
   * then the less specific matcher *X* does not apply either despite the
   * input being within the range, because matcher *X* is exclusive.
   *
   * The opposite is true if matcher *X* is not marked as exclusive. In that
   * case matcher *X* always matches whenever matcher "*Y* rejects the input.
   *
   * @generated from field: bool exclusive = 3;
   */
  exclusive: boolean;
};

/**
 * Describes the message xds.type.matcher.v3.IPMatcher.IPRangeMatcher.
 * Use `create(IPMatcher_IPRangeMatcherSchema)` to create a new message.
 */
export declare const IPMatcher_IPRangeMatcherSchema: GenMessage<IPMatcher_IPRangeMatcher>;

