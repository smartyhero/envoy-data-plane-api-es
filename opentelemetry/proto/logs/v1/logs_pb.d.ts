// Copyright 2020, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.0
// @generated from file opentelemetry/proto/logs/v1/logs.proto (package opentelemetry.proto.logs.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Resource } from "../../resource/v1/resource_pb";
import type { AnyValue, InstrumentationScope, KeyValue } from "../../common/v1/common_pb";

/**
 * Describes the file opentelemetry/proto/logs/v1/logs.proto.
 */
export declare const file_opentelemetry_proto_logs_v1_logs: GenFile;

/**
 * LogsData represents the logs data that can be stored in a persistent storage,
 * OR can be embedded by other protocols that transfer OTLP logs data but do not
 * implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.logs.v1.LogsData
 */
export declare type LogsData = Message<"opentelemetry.proto.logs.v1.LogsData"> & {
  /**
   * An array of ResourceLogs.
   * For data coming from a single resource this array will typically contain
   * one element. Intermediary nodes that receive data from multiple origins
   * typically batch the data before forwarding further and in that case this
   * array will contain multiple elements.
   *
   * @generated from field: repeated opentelemetry.proto.logs.v1.ResourceLogs resource_logs = 1;
   */
  resourceLogs: ResourceLogs[];
};

/**
 * Describes the message opentelemetry.proto.logs.v1.LogsData.
 * Use `create(LogsDataSchema)` to create a new message.
 */
export declare const LogsDataSchema: GenMessage<LogsData>;

/**
 * A collection of ScopeLogs from a Resource.
 *
 * @generated from message opentelemetry.proto.logs.v1.ResourceLogs
 */
export declare type ResourceLogs = Message<"opentelemetry.proto.logs.v1.ResourceLogs"> & {
  /**
   * The resource for the logs in this message.
   * If this field is not set then resource info is unknown.
   *
   * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
   */
  resource?: Resource;

  /**
   * A list of ScopeLogs that originate from a resource.
   *
   * @generated from field: repeated opentelemetry.proto.logs.v1.ScopeLogs scope_logs = 2;
   */
  scopeLogs: ScopeLogs[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_logs" field which have their own schema_url field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.logs.v1.ResourceLogs.
 * Use `create(ResourceLogsSchema)` to create a new message.
 */
export declare const ResourceLogsSchema: GenMessage<ResourceLogs>;

/**
 * A collection of Logs produced by a Scope.
 *
 * @generated from message opentelemetry.proto.logs.v1.ScopeLogs
 */
export declare type ScopeLogs = Message<"opentelemetry.proto.logs.v1.ScopeLogs"> & {
  /**
   * The instrumentation scope information for the logs in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   *
   * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
   */
  scope?: InstrumentationScope;

  /**
   * A list of log records.
   *
   * @generated from field: repeated opentelemetry.proto.logs.v1.LogRecord log_records = 2;
   */
  logRecords: LogRecord[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the log data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "scope" field and all logs in the
   * "log_records" field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.logs.v1.ScopeLogs.
 * Use `create(ScopeLogsSchema)` to create a new message.
 */
export declare const ScopeLogsSchema: GenMessage<ScopeLogs>;

/**
 * A log record according to OpenTelemetry Log Data Model:
 * https://github.com/open-telemetry/oteps/blob/main/text/logs/0097-log-data-model.md
 *
 * @generated from message opentelemetry.proto.logs.v1.LogRecord
 */
export declare type LogRecord = Message<"opentelemetry.proto.logs.v1.LogRecord"> & {
  /**
   * time_unix_nano is the time when the event occurred.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   * Value of 0 indicates unknown or missing timestamp.
   *
   * @generated from field: fixed64 time_unix_nano = 1;
   */
  timeUnixNano: bigint;

  /**
   * Time when the event was observed by the collection system.
   * For events that originate in OpenTelemetry (e.g. using OpenTelemetry Logging SDK)
   * this timestamp is typically set at the generation time and is equal to Timestamp.
   * For events originating externally and collected by OpenTelemetry (e.g. using
   * Collector) this is the time when OpenTelemetry's code observed the event measured
   * by the clock of the OpenTelemetry code. This field MUST be set once the event is
   * observed by OpenTelemetry.
   *
   * For converting OpenTelemetry log data to formats that support only one timestamp or
   * when receiving OpenTelemetry log data by recipients that support only one timestamp
   * internally the following logic is recommended:
   *   - Use time_unix_nano if it is present, otherwise use observed_time_unix_nano.
   *
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   * Value of 0 indicates unknown or missing timestamp.
   *
   * @generated from field: fixed64 observed_time_unix_nano = 11;
   */
  observedTimeUnixNano: bigint;

  /**
   * Numerical value of the severity, normalized to values described in Log Data Model.
   * [Optional].
   *
   * @generated from field: opentelemetry.proto.logs.v1.SeverityNumber severity_number = 2;
   */
  severityNumber: SeverityNumber;

  /**
   * The severity text (also known as log level). The original string representation as
   * it is known at the source. [Optional].
   *
   * @generated from field: string severity_text = 3;
   */
  severityText: string;

  /**
   * A value containing the body of the log record. Can be for example a human-readable
   * string message (including multi-line) describing the event in a free form or it can
   * be a structured data composed of arrays and maps of other values. [Optional].
   *
   * @generated from field: opentelemetry.proto.common.v1.AnyValue body = 5;
   */
  body?: AnyValue;

  /**
   * Additional attributes that describe the specific event occurrence. [Optional].
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 6;
   */
  attributes: KeyValue[];

  /**
   * @generated from field: uint32 dropped_attributes_count = 7;
   */
  droppedAttributesCount: number;

  /**
   * Flags, a bit field. 8 least significant bits are the trace flags as
   * defined in W3C Trace Context specification. 24 most significant bits are reserved
   * and must be set to 0. Readers must not assume that 24 most significant bits
   * will be zero and must correctly mask the bits when reading 8-bit trace flag (use
   * flags & LOG_RECORD_FLAGS_TRACE_FLAGS_MASK). [Optional].
   *
   * @generated from field: fixed32 flags = 8;
   */
  flags: number;

  /**
   * A unique identifier for a trace. All logs from the same trace share
   * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
   * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
   * is zero-length and thus is also invalid).
   *
   * This field is optional.
   *
   * The receivers SHOULD assume that the log record is not associated with a
   * trace if any of the following is true:
   *   - the field is not present,
   *   - the field contains an invalid value.
   *
   * @generated from field: bytes trace_id = 9;
   */
  traceId: Uint8Array;

  /**
   * A unique identifier for a span within a trace, assigned when the span
   * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
   * other than 8 bytes is considered invalid (empty string in OTLP/JSON
   * is zero-length and thus is also invalid).
   *
   * This field is optional. If the sender specifies a valid span_id then it SHOULD also
   * specify a valid trace_id.
   *
   * The receivers SHOULD assume that the log record is not associated with a
   * span if any of the following is true:
   *   - the field is not present,
   *   - the field contains an invalid value.
   *
   * @generated from field: bytes span_id = 10;
   */
  spanId: Uint8Array;

  /**
   * A unique identifier of event category/type.
   * All events with the same event_name are expected to conform to the same
   * schema for both their attributes and their body.
   *
   * Recommended to be fully qualified and short (no longer than 256 characters).
   *
   * Presence of event_name on the log record identifies this record
   * as an event.
   *
   * [Optional].
   *
   * @generated from field: string event_name = 12;
   */
  eventName: string;
};

/**
 * Describes the message opentelemetry.proto.logs.v1.LogRecord.
 * Use `create(LogRecordSchema)` to create a new message.
 */
export declare const LogRecordSchema: GenMessage<LogRecord>;

/**
 * Possible values for LogRecord.SeverityNumber.
 *
 * @generated from enum opentelemetry.proto.logs.v1.SeverityNumber
 */
export enum SeverityNumber {
  /**
   * UNSPECIFIED is the default SeverityNumber, it MUST NOT be used.
   *
   * @generated from enum value: SEVERITY_NUMBER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SEVERITY_NUMBER_TRACE = 1;
   */
  TRACE = 1,

  /**
   * @generated from enum value: SEVERITY_NUMBER_TRACE2 = 2;
   */
  TRACE2 = 2,

  /**
   * @generated from enum value: SEVERITY_NUMBER_TRACE3 = 3;
   */
  TRACE3 = 3,

  /**
   * @generated from enum value: SEVERITY_NUMBER_TRACE4 = 4;
   */
  TRACE4 = 4,

  /**
   * @generated from enum value: SEVERITY_NUMBER_DEBUG = 5;
   */
  DEBUG = 5,

  /**
   * @generated from enum value: SEVERITY_NUMBER_DEBUG2 = 6;
   */
  DEBUG2 = 6,

  /**
   * @generated from enum value: SEVERITY_NUMBER_DEBUG3 = 7;
   */
  DEBUG3 = 7,

  /**
   * @generated from enum value: SEVERITY_NUMBER_DEBUG4 = 8;
   */
  DEBUG4 = 8,

  /**
   * @generated from enum value: SEVERITY_NUMBER_INFO = 9;
   */
  INFO = 9,

  /**
   * @generated from enum value: SEVERITY_NUMBER_INFO2 = 10;
   */
  INFO2 = 10,

  /**
   * @generated from enum value: SEVERITY_NUMBER_INFO3 = 11;
   */
  INFO3 = 11,

  /**
   * @generated from enum value: SEVERITY_NUMBER_INFO4 = 12;
   */
  INFO4 = 12,

  /**
   * @generated from enum value: SEVERITY_NUMBER_WARN = 13;
   */
  WARN = 13,

  /**
   * @generated from enum value: SEVERITY_NUMBER_WARN2 = 14;
   */
  WARN2 = 14,

  /**
   * @generated from enum value: SEVERITY_NUMBER_WARN3 = 15;
   */
  WARN3 = 15,

  /**
   * @generated from enum value: SEVERITY_NUMBER_WARN4 = 16;
   */
  WARN4 = 16,

  /**
   * @generated from enum value: SEVERITY_NUMBER_ERROR = 17;
   */
  ERROR = 17,

  /**
   * @generated from enum value: SEVERITY_NUMBER_ERROR2 = 18;
   */
  ERROR2 = 18,

  /**
   * @generated from enum value: SEVERITY_NUMBER_ERROR3 = 19;
   */
  ERROR3 = 19,

  /**
   * @generated from enum value: SEVERITY_NUMBER_ERROR4 = 20;
   */
  ERROR4 = 20,

  /**
   * @generated from enum value: SEVERITY_NUMBER_FATAL = 21;
   */
  FATAL = 21,

  /**
   * @generated from enum value: SEVERITY_NUMBER_FATAL2 = 22;
   */
  FATAL2 = 22,

  /**
   * @generated from enum value: SEVERITY_NUMBER_FATAL3 = 23;
   */
  FATAL3 = 23,

  /**
   * @generated from enum value: SEVERITY_NUMBER_FATAL4 = 24;
   */
  FATAL4 = 24,
}

/**
 * Describes the enum opentelemetry.proto.logs.v1.SeverityNumber.
 */
export declare const SeverityNumberSchema: GenEnum<SeverityNumber>;

/**
 * LogRecordFlags represents constants used to interpret the
 * LogRecord.flags field, which is protobuf 'fixed32' type and is to
 * be used as bit-fields. Each non-zero value defined in this enum is
 * a bit-mask.  To extract the bit-field, for example, use an
 * expression like:
 *
 *   (logRecord.flags & LOG_RECORD_FLAGS_TRACE_FLAGS_MASK)
 *
 *
 * @generated from enum opentelemetry.proto.logs.v1.LogRecordFlags
 */
export enum LogRecordFlags {
  /**
   * The zero value for the enum. Should not be used for comparisons.
   * Instead use bitwise "and" with the appropriate mask as shown above.
   *
   * @generated from enum value: LOG_RECORD_FLAGS_DO_NOT_USE = 0;
   */
  DO_NOT_USE = 0,

  /**
   * Bits 0-7 are used for trace flags.
   *
   * @generated from enum value: LOG_RECORD_FLAGS_TRACE_FLAGS_MASK = 255;
   */
  TRACE_FLAGS_MASK = 255,
}

/**
 * Describes the enum opentelemetry.proto.logs.v1.LogRecordFlags.
 */
export declare const LogRecordFlagsSchema: GenEnum<LogRecordFlags>;

