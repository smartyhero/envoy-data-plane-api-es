// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.0
// @generated from file opentelemetry/proto/trace/v1/trace.proto (package opentelemetry.proto.trace.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Resource } from "../../resource/v1/resource_pb";
import type { InstrumentationScope, KeyValue } from "../../common/v1/common_pb";

/**
 * Describes the file opentelemetry/proto/trace/v1/trace.proto.
 */
export declare const file_opentelemetry_proto_trace_v1_trace: GenFile;

/**
 * TracesData represents the traces data that can be stored in a persistent storage,
 * OR can be embedded by other protocols that transfer OTLP traces data but do
 * not implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.trace.v1.TracesData
 */
export declare type TracesData = Message<"opentelemetry.proto.trace.v1.TracesData"> & {
  /**
   * An array of ResourceSpans.
   * For data coming from a single resource this array will typically contain
   * one element. Intermediary nodes that receive data from multiple origins
   * typically batch the data before forwarding further and in that case this
   * array will contain multiple elements.
   *
   * @generated from field: repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans = 1;
   */
  resourceSpans: ResourceSpans[];
};

/**
 * Describes the message opentelemetry.proto.trace.v1.TracesData.
 * Use `create(TracesDataSchema)` to create a new message.
 */
export declare const TracesDataSchema: GenMessage<TracesData>;

/**
 * A collection of ScopeSpans from a Resource.
 *
 * @generated from message opentelemetry.proto.trace.v1.ResourceSpans
 */
export declare type ResourceSpans = Message<"opentelemetry.proto.trace.v1.ResourceSpans"> & {
  /**
   * The resource for the spans in this message.
   * If this field is not set then no resource info is known.
   *
   * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
   */
  resource?: Resource;

  /**
   * A list of ScopeSpans that originate from a resource.
   *
   * @generated from field: repeated opentelemetry.proto.trace.v1.ScopeSpans scope_spans = 2;
   */
  scopeSpans: ScopeSpans[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_spans" field which have their own schema_url field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.ResourceSpans.
 * Use `create(ResourceSpansSchema)` to create a new message.
 */
export declare const ResourceSpansSchema: GenMessage<ResourceSpans>;

/**
 * A collection of Spans produced by an InstrumentationScope.
 *
 * @generated from message opentelemetry.proto.trace.v1.ScopeSpans
 */
export declare type ScopeSpans = Message<"opentelemetry.proto.trace.v1.ScopeSpans"> & {
  /**
   * The instrumentation scope information for the spans in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   *
   * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
   */
  scope?: InstrumentationScope;

  /**
   * A list of Spans that originate from an instrumentation scope.
   *
   * @generated from field: repeated opentelemetry.proto.trace.v1.Span spans = 2;
   */
  spans: Span[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the span data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "scope" field and all spans and span
   * events in the "spans" field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.ScopeSpans.
 * Use `create(ScopeSpansSchema)` to create a new message.
 */
export declare const ScopeSpansSchema: GenMessage<ScopeSpans>;

/**
 * A Span represents a single operation performed by a single component of the system.
 *
 * The next available field id is 17.
 *
 * @generated from message opentelemetry.proto.trace.v1.Span
 */
export declare type Span = Message<"opentelemetry.proto.trace.v1.Span"> & {
  /**
   * A unique identifier for a trace. All spans from the same trace share
   * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
   * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
   * is zero-length and thus is also invalid).
   *
   * This field is required.
   *
   * @generated from field: bytes trace_id = 1;
   */
  traceId: Uint8Array;

  /**
   * A unique identifier for a span within a trace, assigned when the span
   * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
   * other than 8 bytes is considered invalid (empty string in OTLP/JSON
   * is zero-length and thus is also invalid).
   *
   * This field is required.
   *
   * @generated from field: bytes span_id = 2;
   */
  spanId: Uint8Array;

  /**
   * trace_state conveys information about request position in multiple distributed tracing graphs.
   * It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
   * See also https://github.com/w3c/distributed-tracing for more details about this field.
   *
   * @generated from field: string trace_state = 3;
   */
  traceState: string;

  /**
   * The `span_id` of this span's parent span. If this is a root span, then this
   * field must be empty. The ID is an 8-byte array.
   *
   * @generated from field: bytes parent_span_id = 4;
   */
  parentSpanId: Uint8Array;

  /**
   * Flags, a bit field.
   *
   * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
   * Context specification. To read the 8-bit W3C trace flag, use
   * `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
   *
   * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
   *
   * Bits 8 and 9 represent the 3 states of whether a span's parent
   * is remote. The states are (unknown, is not remote, is remote).
   * To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
   * To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
   *
   * When creating span messages, if the message is logically forwarded from another source
   * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
   * be copied as-is. If creating from a source that does not have an equivalent flags field
   * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
   * be set to zero.
   * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
   *
   * [Optional].
   *
   * @generated from field: fixed32 flags = 16;
   */
  flags: number;

  /**
   * A description of the span's operation.
   *
   * For example, the name can be a qualified method name or a file name
   * and a line number where the operation is called. A best practice is to use
   * the same display name at the same call point in an application.
   * This makes it easier to correlate spans in different traces.
   *
   * This field is semantically required to be set to non-empty string.
   * Empty value is equivalent to an unknown span name.
   *
   * This field is required.
   *
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   * Distinguishes between spans generated in a particular context. For example,
   * two spans with the same name may be distinguished using `CLIENT` (caller)
   * and `SERVER` (callee) to identify queueing latency associated with the span.
   *
   * @generated from field: opentelemetry.proto.trace.v1.Span.SpanKind kind = 6;
   */
  kind: Span_SpanKind;

  /**
   * The start time of the span. On the client side, this is the time
   * kept by the local machine where the span execution starts. On the server side, this
   * is the time when the server's application handler starts running.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   *
   * This field is semantically required and it is expected that end_time >= start_time.
   *
   * @generated from field: fixed64 start_time_unix_nano = 7;
   */
  startTimeUnixNano: bigint;

  /**
   * The end time of the span. On the client side, this is the time
   * kept by the local machine where the span execution ends. On the server side, this
   * is the time when the server application handler stops running.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   *
   * This field is semantically required and it is expected that end_time >= start_time.
   *
   * @generated from field: fixed64 end_time_unix_nano = 8;
   */
  endTimeUnixNano: bigint;

  /**
   * A collection of key/value pairs. Note, global attributes
   * like server name can be set using the resource API. Examples of attributes:
   *
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "/http/server_latency": 300
   *     "example.com/myattribute": true
   *     "example.com/score": 10.239
   *
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
   */
  attributes: KeyValue[];

  /**
   * The number of attributes that were discarded. Attributes
   * can be discarded because their keys are too long or because there are too many
   * attributes. If this value is 0, then no attributes were dropped.
   *
   * @generated from field: uint32 dropped_attributes_count = 10;
   */
  droppedAttributesCount: number;

  /**
   * A collection of Event items.
   *
   * @generated from field: repeated opentelemetry.proto.trace.v1.Span.Event events = 11;
   */
  events: Span_Event[];

  /**
   * The number of dropped events. If the value is 0, then no
   * events were dropped.
   *
   * @generated from field: uint32 dropped_events_count = 12;
   */
  droppedEventsCount: number;

  /**
   * A collection of Links, which are references from this span to a span
   * in the same or different trace.
   *
   * @generated from field: repeated opentelemetry.proto.trace.v1.Span.Link links = 13;
   */
  links: Span_Link[];

  /**
   * The number of dropped links after the maximum size was
   * enforced. If this value is 0, then no links were dropped.
   *
   * @generated from field: uint32 dropped_links_count = 14;
   */
  droppedLinksCount: number;

  /**
   * An optional final status for this span. Semantically when Status isn't set, it means
   * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
   *
   * @generated from field: opentelemetry.proto.trace.v1.Status status = 15;
   */
  status?: Status;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.Span.
 * Use `create(SpanSchema)` to create a new message.
 */
export declare const SpanSchema: GenMessage<Span>;

/**
 * Event is a time-stamped annotation of the span, consisting of user-supplied
 * text description and key-value pairs.
 *
 * @generated from message opentelemetry.proto.trace.v1.Span.Event
 */
export declare type Span_Event = Message<"opentelemetry.proto.trace.v1.Span.Event"> & {
  /**
   * The time the event occurred.
   *
   * @generated from field: fixed64 time_unix_nano = 1;
   */
  timeUnixNano: bigint;

  /**
   * The name of the event.
   * This field is semantically required to be set to non-empty string.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * A collection of attribute key/value pairs on the event.
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 3;
   */
  attributes: KeyValue[];

  /**
   * The number of dropped attributes. If the value is 0,
   * then no attributes were dropped.
   *
   * @generated from field: uint32 dropped_attributes_count = 4;
   */
  droppedAttributesCount: number;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.Span.Event.
 * Use `create(Span_EventSchema)` to create a new message.
 */
export declare const Span_EventSchema: GenMessage<Span_Event>;

/**
 * A pointer from the current span to another span in the same trace or in a
 * different trace. For example, this can be used in batching operations,
 * where a single batch handler processes multiple requests from different
 * traces or when the handler receives a request from a different project.
 *
 * @generated from message opentelemetry.proto.trace.v1.Span.Link
 */
export declare type Span_Link = Message<"opentelemetry.proto.trace.v1.Span.Link"> & {
  /**
   * A unique identifier of a trace that this linked span is part of. The ID is a
   * 16-byte array.
   *
   * @generated from field: bytes trace_id = 1;
   */
  traceId: Uint8Array;

  /**
   * A unique identifier for the linked span. The ID is an 8-byte array.
   *
   * @generated from field: bytes span_id = 2;
   */
  spanId: Uint8Array;

  /**
   * The trace_state associated with the link.
   *
   * @generated from field: string trace_state = 3;
   */
  traceState: string;

  /**
   * A collection of attribute key/value pairs on the link.
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   *
   * @generated from field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 4;
   */
  attributes: KeyValue[];

  /**
   * The number of dropped attributes. If the value is 0,
   * then no attributes were dropped.
   *
   * @generated from field: uint32 dropped_attributes_count = 5;
   */
  droppedAttributesCount: number;

  /**
   * Flags, a bit field.
   *
   * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
   * Context specification. To read the 8-bit W3C trace flag, use
   * `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
   *
   * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
   *
   * Bits 8 and 9 represent the 3 states of whether the link is remote.
   * The states are (unknown, is not remote, is remote).
   * To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
   * To read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
   *
   * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
   * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
   *
   * [Optional].
   *
   * @generated from field: fixed32 flags = 6;
   */
  flags: number;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.Span.Link.
 * Use `create(Span_LinkSchema)` to create a new message.
 */
export declare const Span_LinkSchema: GenMessage<Span_Link>;

/**
 * SpanKind is the type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 *
 * @generated from enum opentelemetry.proto.trace.v1.Span.SpanKind
 */
export enum Span_SpanKind {
  /**
   * Unspecified. Do NOT use as default.
   * Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
   *
   * @generated from enum value: SPAN_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Indicates that the span represents an internal operation within an application,
   * as opposed to an operation happening at the boundaries. Default value.
   *
   * @generated from enum value: SPAN_KIND_INTERNAL = 1;
   */
  INTERNAL = 1,

  /**
   * Indicates that the span covers server-side handling of an RPC or other
   * remote network request.
   *
   * @generated from enum value: SPAN_KIND_SERVER = 2;
   */
  SERVER = 2,

  /**
   * Indicates that the span describes a request to some remote service.
   *
   * @generated from enum value: SPAN_KIND_CLIENT = 3;
   */
  CLIENT = 3,

  /**
   * Indicates that the span describes a producer sending a message to a broker.
   * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
   * between producer and consumer spans. A PRODUCER span ends when the message was accepted
   * by the broker while the logical processing of the message might span a much longer time.
   *
   * @generated from enum value: SPAN_KIND_PRODUCER = 4;
   */
  PRODUCER = 4,

  /**
   * Indicates that the span describes consumer receiving a message from a broker.
   * Like the PRODUCER kind, there is often no direct critical path latency relationship
   * between producer and consumer spans.
   *
   * @generated from enum value: SPAN_KIND_CONSUMER = 5;
   */
  CONSUMER = 5,
}

/**
 * Describes the enum opentelemetry.proto.trace.v1.Span.SpanKind.
 */
export declare const Span_SpanKindSchema: GenEnum<Span_SpanKind>;

/**
 * The Status type defines a logical error model that is suitable for different
 * programming environments, including REST APIs and RPC APIs.
 *
 * @generated from message opentelemetry.proto.trace.v1.Status
 */
export declare type Status = Message<"opentelemetry.proto.trace.v1.Status"> & {
  /**
   * A developer-facing human readable error message.
   *
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * The status code.
   *
   * @generated from field: opentelemetry.proto.trace.v1.Status.StatusCode code = 3;
   */
  code: Status_StatusCode;
};

/**
 * Describes the message opentelemetry.proto.trace.v1.Status.
 * Use `create(StatusSchema)` to create a new message.
 */
export declare const StatusSchema: GenMessage<Status>;

/**
 * For the semantics of status codes see
 * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
 *
 * @generated from enum opentelemetry.proto.trace.v1.Status.StatusCode
 */
export enum Status_StatusCode {
  /**
   * The default status.
   *
   * @generated from enum value: STATUS_CODE_UNSET = 0;
   */
  UNSET = 0,

  /**
   * The Span has been validated by an Application developer or Operator to 
   * have completed successfully.
   *
   * @generated from enum value: STATUS_CODE_OK = 1;
   */
  OK = 1,

  /**
   * The Span contains an error.
   *
   * @generated from enum value: STATUS_CODE_ERROR = 2;
   */
  ERROR = 2,
}

/**
 * Describes the enum opentelemetry.proto.trace.v1.Status.StatusCode.
 */
export declare const Status_StatusCodeSchema: GenEnum<Status_StatusCode>;

/**
 * SpanFlags represents constants used to interpret the
 * Span.flags field, which is protobuf 'fixed32' type and is to
 * be used as bit-fields. Each non-zero value defined in this enum is
 * a bit-mask.  To extract the bit-field, for example, use an
 * expression like:
 *
 *   (span.flags & SPAN_FLAGS_TRACE_FLAGS_MASK)
 *
 * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
 *
 * Note that Span flags were introduced in version 1.1 of the
 * OpenTelemetry protocol.  Older Span producers do not set this
 * field, consequently consumers should not rely on the absence of a
 * particular flag bit to indicate the presence of a particular feature.
 *
 * @generated from enum opentelemetry.proto.trace.v1.SpanFlags
 */
export enum SpanFlags {
  /**
   * The zero value for the enum. Should not be used for comparisons.
   * Instead use bitwise "and" with the appropriate mask as shown above.
   *
   * @generated from enum value: SPAN_FLAGS_DO_NOT_USE = 0;
   */
  DO_NOT_USE = 0,

  /**
   * Bits 0-7 are used for trace flags.
   *
   * @generated from enum value: SPAN_FLAGS_TRACE_FLAGS_MASK = 255;
   */
  TRACE_FLAGS_MASK = 255,

  /**
   * Bits 8 and 9 are used to indicate that the parent span or link span is remote.
   * Bit 8 (`HAS_IS_REMOTE`) indicates whether the value is known.
   * Bit 9 (`IS_REMOTE`) indicates whether the span or link is remote.
   *
   * @generated from enum value: SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 256;
   */
  CONTEXT_HAS_IS_REMOTE_MASK = 256,

  /**
   * @generated from enum value: SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 512;
   */
  CONTEXT_IS_REMOTE_MASK = 512,
}

/**
 * Describes the enum opentelemetry.proto.trace.v1.SpanFlags.
 */
export declare const SpanFlagsSchema: GenEnum<SpanFlags>;

