// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.0
// @generated from file opentelemetry/proto/profiles/v1development/profiles.proto (package opentelemetry.proto.profiles.v1development, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Resource } from "../../resource/v1/resource_pb";
import type { AnyValue, InstrumentationScope } from "../../common/v1/common_pb";

/**
 * Describes the file opentelemetry/proto/profiles/v1development/profiles.proto.
 */
export declare const file_opentelemetry_proto_profiles_v1development_profiles: GenFile;

/**
 * ProfilesDictionary represents the profiles data shared across the
 * entire message being sent. The following applies to all fields in this
 * message:
 *
 * - A dictionary is an array of dictionary items. Users of the dictionary
 *   compactly reference the items using the index within the array.
 *
 * - A dictionary MUST have a zero value encoded as the first element. This
 *   allows for _index fields pointing into the dictionary to use a 0 pointer
 *   value to indicate 'null' / 'not set'. Unless otherwise defined, a 'zero
 *   value' message value is one with all default field values, so as to
 *   minimize wire encoded size.
 *
 * - There SHOULD NOT be dupes in a dictionary. The identity of dictionary
 *   items is based on their value, recursively as needed. If a particular
 *   implementation does emit duplicated items, it MUST NOT attempt to give them
 *   meaning based on the index or order. A profile processor may remove
 *   duplicate items and this MUST NOT have any observable effects for
 *   consumers.
 *
 * - There SHOULD NOT be orphaned (unreferenced) items in a dictionary. A
 *   profile processor may remove ("garbage-collect") orphaned items and this
 *   MUST NOT have any observable effects for consumers.
 *
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesDictionary
 */
export declare type ProfilesDictionary = Message<"opentelemetry.proto.profiles.v1development.ProfilesDictionary"> & {
  /**
   * Mappings from address ranges to the image/binary/library mapped
   * into that address range referenced by locations via Location.mapping_index.
   *
   * mapping_table[0] must always be zero value (Mapping{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Mapping mapping_table = 1;
   */
  mappingTable: Mapping[];

  /**
   * Locations referenced by samples via Stack.location_indices.
   *
   * location_table[0] must always be zero value (Location{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Location location_table = 2;
   */
  locationTable: Location[];

  /**
   * Functions referenced by locations via Line.function_index.
   *
   * function_table[0] must always be zero value (Function{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Function function_table = 3;
   */
  functionTable: Function[];

  /**
   * Links referenced by samples via Sample.link_index.
   *
   * link_table[0] must always be zero value (Link{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Link link_table = 4;
   */
  linkTable: Link[];

  /**
   * A common table for strings referenced by various messages.
   *
   * string_table[0] must always be "" and present.
   *
   * @generated from field: repeated string string_table = 5;
   */
  stringTable: string[];

  /**
   * A common table for attributes referenced by the Profile, Sample, Mapping
   * and Location messages below through attribute_indices field. Each entry is
   * a key/value pair with an optional unit. Since this is a dictionary table,
   * multiple entries with the same key may be present, unlike direct attribute
   * tables like Resource.attributes. The referencing attribute_indices fields,
   * though, do maintain the key uniqueness requirement.
   *
   * It's recommended to use attributes for variables with bounded cardinality,
   * such as categorical variables
   * (https://en.wikipedia.org/wiki/Categorical_variable). Using an attribute of
   * a floating point type (e.g., CPU time) in a sample can quickly make every
   * attribute value unique, defeating the purpose of the dictionary and
   * impractically increasing the profile size.
   *
   * Examples of attributes:
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "abc.com/myattribute": true
   *     "allocation_size": 128 bytes
   *
   * attribute_table[0] must always be zero value (KeyValueAndUnit{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.KeyValueAndUnit attribute_table = 6;
   */
  attributeTable: KeyValueAndUnit[];

  /**
   * Stacks referenced by samples via Sample.stack_index.
   *
   * stack_table[0] must always be zero value (Stack{}) and present.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Stack stack_table = 7;
   */
  stackTable: Stack[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesDictionary.
 * Use `create(ProfilesDictionarySchema)` to create a new message.
 */
export declare const ProfilesDictionarySchema: GenMessage<ProfilesDictionary>;

/**
 * ProfilesData represents the profiles data that can be stored in persistent storage,
 * OR can be embedded by other protocols that transfer OTLP profiles data but do not
 * implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesData
 */
export declare type ProfilesData = Message<"opentelemetry.proto.profiles.v1development.ProfilesData"> & {
  /**
   * An array of ResourceProfiles.
   * For data coming from an SDK profiler, this array will typically contain one
   * element. Host-level profilers will usually create one ResourceProfile per
   * container, as well as one additional ResourceProfile grouping all samples
   * from non-containerized processes.
   * Other resource groupings are possible as well and clarified via
   * Resource.attributes and semantic conventions.
   * Tools that visualize profiles should prefer displaying
   * resources_profiles[0].scope_profiles[0].profiles[0] by default.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.ResourceProfiles resource_profiles = 1;
   */
  resourceProfiles: ResourceProfiles[];

  /**
   * One instance of ProfilesDictionary
   *
   * @generated from field: opentelemetry.proto.profiles.v1development.ProfilesDictionary dictionary = 2;
   */
  dictionary?: ProfilesDictionary;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesData.
 * Use `create(ProfilesDataSchema)` to create a new message.
 */
export declare const ProfilesDataSchema: GenMessage<ProfilesData>;

/**
 * A collection of ScopeProfiles from a Resource.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ResourceProfiles
 */
export declare type ResourceProfiles = Message<"opentelemetry.proto.profiles.v1development.ResourceProfiles"> & {
  /**
   * The resource for the profiles in this message.
   * If this field is not set then no resource info is known.
   *
   * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
   */
  resource?: Resource;

  /**
   * A list of ScopeProfiles that originate from a resource.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.ScopeProfiles scope_profiles = 2;
   */
  scopeProfiles: ScopeProfiles[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_profiles" field which have their own schema_url field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ResourceProfiles.
 * Use `create(ResourceProfilesSchema)` to create a new message.
 */
export declare const ResourceProfilesSchema: GenMessage<ResourceProfiles>;

/**
 * A collection of Profiles produced by an InstrumentationScope.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ScopeProfiles
 */
export declare type ScopeProfiles = Message<"opentelemetry.proto.profiles.v1development.ScopeProfiles"> & {
  /**
   * The instrumentation scope information for the profiles in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   *
   * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
   */
  scope?: InstrumentationScope;

  /**
   * A list of Profiles that originate from an instrumentation scope.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Profile profiles = 2;
   */
  profiles: Profile[];

  /**
   * The Schema URL, if known. This is the identifier of the Schema that the profile data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "scope" field and all profiles in the
   * "profiles" field.
   *
   * @generated from field: string schema_url = 3;
   */
  schemaUrl: string;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ScopeProfiles.
 * Use `create(ScopeProfilesSchema)` to create a new message.
 */
export declare const ScopeProfilesSchema: GenMessage<ScopeProfiles>;

/**
 * Represents a complete profile, including sample types, samples, mappings to
 * binaries, stacks, locations, functions, string table, and additional
 * metadata. It modifies and annotates pprof Profile with OpenTelemetry
 * specific fields.
 *
 * Note that whilst fields in this message retain the name and field id from pprof in most cases
 * for ease of understanding data migration, it is not intended that pprof:Profile and
 * OpenTelemetry:Profile encoding be wire compatible.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Profile
 */
export declare type Profile = Message<"opentelemetry.proto.profiles.v1development.Profile"> & {
  /**
   * The type and unit of all Sample.values in this profile.
   * For a cpu or off-cpu profile this might be:
   *   ["cpu","nanoseconds"] or ["off_cpu","nanoseconds"]
   * For a heap profile, this might be:
   *   ["allocated_objects","count"] or ["allocated_space","bytes"],
   *
   * @generated from field: opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;
   */
  sampleType?: ValueType;

  /**
   * The set of samples recorded in this profile.
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Sample samples = 2;
   */
  samples: Sample[];

  /**
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   *
   * @generated from field: fixed64 time_unix_nano = 3;
   */
  timeUnixNano: bigint;

  /**
   * Duration of the profile, if a duration makes sense.
   *
   * @generated from field: uint64 duration_nano = 4;
   */
  durationNano: bigint;

  /**
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   *
   * @generated from field: opentelemetry.proto.profiles.v1development.ValueType period_type = 5;
   */
  periodType?: ValueType;

  /**
   * The number of events between sampled occurrences.
   *
   * @generated from field: int64 period = 6;
   */
  period: bigint;

  /**
   * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
   * all zeroes is considered invalid. It may be used for deduplication and signal
   * correlation purposes. It is acceptable to treat two profiles with different values
   * in this field as not equal, even if they represented the same object at an earlier
   * time.
   * This field is optional; an ID may be assigned to an ID-less profile in a later step.
   *
   * @generated from field: bytes profile_id = 7;
   */
  profileId: Uint8Array;

  /**
   * The number of attributes that were discarded. Attributes
   * can be discarded because their keys are too long or because there are too many
   * attributes. If this value is 0, then no attributes were dropped.
   *
   * @generated from field: uint32 dropped_attributes_count = 8;
   */
  droppedAttributesCount: number;

  /**
   * The original payload format. See also original_payload. Optional, but the
   * format and the bytes must be set or unset together.
   *
   * The allowed values for the format string are defined by the OpenTelemetry
   * specification. Some examples are "jfr", "pprof", "linux_perf".
   *
   * The original payload may be optionally provided when the conversion to the
   * OLTP format was done from a different format with some loss of the fidelity
   * and the receiver may want to store the original payload to allow future
   * lossless export or reinterpretation. Some examples of the original format
   * are JFR (Java Flight Recorder), pprof, Linux perf.
   *
   * Even when the original payload is in a format that is semantically close to
   * OTLP, such as pprof, a conversion may still be lossy in some cases (e.g. if
   * the pprof file contains custom extensions or conventions).
   *
   * The original payload can be large in size, so including the original
   * payload should be configurable by the profiler or collector options. The
   * default behavior should be to not include the original payload.
   *
   * @generated from field: string original_payload_format = 9;
   */
  originalPayloadFormat: string;

  /**
   * The original payload bytes. See also original_payload_format. Optional, but
   * format and the bytes must be set or unset together.
   *
   * @generated from field: bytes original_payload = 10;
   */
  originalPayload: Uint8Array;

  /**
   * References to attributes in attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 11;
   */
  attributeIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Profile.
 * Use `create(ProfileSchema)` to create a new message.
 */
export declare const ProfileSchema: GenMessage<Profile>;

/**
 * A pointer from a profile Sample to a trace Span.
 * Connects a profile sample to a trace span, identified by unique trace and span IDs.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Link
 */
export declare type Link = Message<"opentelemetry.proto.profiles.v1development.Link"> & {
  /**
   * A unique identifier of a trace that this linked span is part of. The ID is a
   * 16-byte array.
   *
   * @generated from field: bytes trace_id = 1;
   */
  traceId: Uint8Array;

  /**
   * A unique identifier for the linked span. The ID is an 8-byte array.
   *
   * @generated from field: bytes span_id = 2;
   */
  spanId: Uint8Array;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Link.
 * Use `create(LinkSchema)` to create a new message.
 */
export declare const LinkSchema: GenMessage<Link>;

/**
 * ValueType describes the type and units of a value.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ValueType
 */
export declare type ValueType = Message<"opentelemetry.proto.profiles.v1development.ValueType"> & {
  /**
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 type_strindex = 1;
   */
  typeStrindex: number;

  /**
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 unit_strindex = 2;
   */
  unitStrindex: number;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ValueType.
 * Use `create(ValueTypeSchema)` to create a new message.
 */
export declare const ValueTypeSchema: GenMessage<ValueType>;

/**
 * Each Sample records values encountered in some program context. The program
 * context is typically a stack trace, perhaps augmented with auxiliary
 * information like the thread-id, some indicator of a higher level request
 * being handled etc.
 *
 * A Sample MUST have have at least one values or timestamps_unix_nano entry. If
 * both fields are populated, they MUST contain the same number of elements, and
 * the elements at the same index MUST refer to the same event.
 *
 * Examples of different ways of representing a sample with the total value of 10:
 *
 * Report of a stacktrace at 10 timestamps (consumers must assume the value is 1 for each point):
 *    values: []
 *    timestamps_unix_nano: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *
 * Report of a stacktrace with an aggregated value without timestamps:
 *   values: [10]
 *    timestamps_unix_nano: []
 *
 * Report of a stacktrace at 4 timestamps where each point records a specific value:
 *    values: [2, 2, 3, 3]
 *    timestamps_unix_nano: [1, 2, 3, 4]
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Sample
 */
export declare type Sample = Message<"opentelemetry.proto.profiles.v1development.Sample"> & {
  /**
   * Reference to stack in ProfilesDictionary.stack_table.
   *
   * @generated from field: int32 stack_index = 1;
   */
  stackIndex: number;

  /**
   * The type and unit of each value is defined by Profile.sample_type.
   *
   * @generated from field: repeated int64 values = 2;
   */
  values: bigint[];

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 3;
   */
  attributeIndices: number[];

  /**
   * Reference to link in ProfilesDictionary.link_table. [optional]
   * It can be unset / set to 0 if no link exists, as link_table[0] is always a 'null' default value.
   *
   * @generated from field: int32 link_index = 4;
   */
  linkIndex: number;

  /**
   * Timestamps associated with Sample represented in nanoseconds. These
   * timestamps should fall within the Profile's time range.
   *
   * @generated from field: repeated fixed64 timestamps_unix_nano = 5;
   */
  timestampsUnixNano: bigint[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Sample.
 * Use `create(SampleSchema)` to create a new message.
 */
export declare const SampleSchema: GenMessage<Sample>;

/**
 * Describes the mapping of a binary in memory, including its address range,
 * file offset, and metadata like build ID
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Mapping
 */
export declare type Mapping = Message<"opentelemetry.proto.profiles.v1development.Mapping"> & {
  /**
   * Address at which the binary (or DLL) is loaded into memory.
   *
   * @generated from field: uint64 memory_start = 1;
   */
  memoryStart: bigint;

  /**
   * The limit of the address range occupied by this mapping.
   *
   * @generated from field: uint64 memory_limit = 2;
   */
  memoryLimit: bigint;

  /**
   * Offset in the binary that corresponds to the first mapped address.
   *
   * @generated from field: uint64 file_offset = 3;
   */
  fileOffset: bigint;

  /**
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   *
   * Index into ProfilesDictionary.string_table.
   *
   * @generated from field: int32 filename_strindex = 4;
   */
  filenameStrindex: number;

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 5;
   */
  attributeIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Mapping.
 * Use `create(MappingSchema)` to create a new message.
 */
export declare const MappingSchema: GenMessage<Mapping>;

/**
 * A Stack represents a stack trace as a list of locations.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Stack
 */
export declare type Stack = Message<"opentelemetry.proto.profiles.v1development.Stack"> & {
  /**
   * References to locations in ProfilesDictionary.location_table.
   * The first location is the leaf frame.
   *
   * @generated from field: repeated int32 location_indices = 1;
   */
  locationIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Stack.
 * Use `create(StackSchema)` to create a new message.
 */
export declare const StackSchema: GenMessage<Stack>;

/**
 * Describes function and line table debug information.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Location
 */
export declare type Location = Message<"opentelemetry.proto.profiles.v1development.Location"> & {
  /**
   * Reference to mapping in ProfilesDictionary.mapping_table.
   * It can be unset / set to 0 if the mapping is unknown or not applicable for
   * this profile type, as mapping_table[0] is always a 'null' default mapping.
   *
   * @generated from field: int32 mapping_index = 1;
   */
  mappingIndex: number;

  /**
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   *
   * @generated from field: uint64 address = 2;
   */
  address: bigint;

  /**
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   *
   * E.g., if memcpy() is inlined into printf:
   *    lines[0].function_name == "memcpy"
   *    lines[1].function_name == "printf"
   *
   * @generated from field: repeated opentelemetry.proto.profiles.v1development.Line lines = 3;
   */
  lines: Line[];

  /**
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   *
   * @generated from field: repeated int32 attribute_indices = 4;
   */
  attributeIndices: number[];
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export declare const LocationSchema: GenMessage<Location>;

/**
 * Details a specific line in a source code, linked to a function.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Line
 */
export declare type Line = Message<"opentelemetry.proto.profiles.v1development.Line"> & {
  /**
   * Reference to function in ProfilesDictionary.function_table.
   *
   * @generated from field: int32 function_index = 1;
   */
  functionIndex: number;

  /**
   * Line number in source code. 0 means unset.
   *
   * @generated from field: int64 line = 2;
   */
  line: bigint;

  /**
   * Column number in source code. 0 means unset.
   *
   * @generated from field: int64 column = 3;
   */
  column: bigint;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Line.
 * Use `create(LineSchema)` to create a new message.
 */
export declare const LineSchema: GenMessage<Line>;

/**
 * Describes a function, including its human-readable name, system name,
 * source file, and starting line number in the source.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Function
 */
export declare type Function = Message<"opentelemetry.proto.profiles.v1development.Function"> & {
  /**
   * The function name. Empty string if not available.
   *
   * @generated from field: int32 name_strindex = 1;
   */
  nameStrindex: number;

  /**
   * Function name, as identified by the system. For instance,
   * it can be a C++ mangled name. Empty string if not available.
   *
   * @generated from field: int32 system_name_strindex = 2;
   */
  systemNameStrindex: number;

  /**
   * Source file containing the function. Empty string if not available.
   *
   * @generated from field: int32 filename_strindex = 3;
   */
  filenameStrindex: number;

  /**
   * Line number in source file. 0 means unset.
   *
   * @generated from field: int64 start_line = 4;
   */
  startLine: bigint;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Function.
 * Use `create(FunctionSchema)` to create a new message.
 */
export declare const FunctionSchema: GenMessage<Function>;

/**
 * A custom 'dictionary native' style of encoding attributes which is more convenient
 * for profiles than opentelemetry.proto.common.v1.KeyValue
 * Specifically, uses the string table for keys and allows optional unit information.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.KeyValueAndUnit
 */
export declare type KeyValueAndUnit = Message<"opentelemetry.proto.profiles.v1development.KeyValueAndUnit"> & {
  /**
   * The index into the string table for the attribute's key.
   *
   * @generated from field: int32 key_strindex = 1;
   */
  keyStrindex: number;

  /**
   * The value of the attribute.
   *
   * @generated from field: opentelemetry.proto.common.v1.AnyValue value = 2;
   */
  value?: AnyValue;

  /**
   * The index into the string table for the attribute's unit.
   * zero indicates implicit (by semconv) or non-defined unit.
   *
   * @generated from field: int32 unit_strindex = 3;
   */
  unitStrindex: number;
};

/**
 * Describes the message opentelemetry.proto.profiles.v1development.KeyValueAndUnit.
 * Use `create(KeyValueAndUnitSchema)` to create a new message.
 */
export declare const KeyValueAndUnitSchema: GenMessage<KeyValueAndUnit>;

