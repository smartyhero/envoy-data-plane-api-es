// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/wasm/v3/wasm.proto (package envoy.extensions.wasm.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { BackoffStrategy } from "../../../config/core/v3/backoff_pb";
import type { AsyncDataSource } from "../../../config/core/v3/base_pb";
import type { Any } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file envoy/extensions/wasm/v3/wasm.proto.
 */
export declare const file_envoy_extensions_wasm_v3_wasm: GenFile;

/**
 * @generated from message envoy.extensions.wasm.v3.ReloadConfig
 */
export declare type ReloadConfig = Message<"envoy.extensions.wasm.v3.ReloadConfig"> & {
  /**
   * Backoff strategy for the VM failure reload. If not specified, the default 1s base interval
   * will be applied.
   *
   * @generated from field: envoy.config.core.v3.BackoffStrategy backoff = 1;
   */
  backoff?: BackoffStrategy;
};

/**
 * Describes the message envoy.extensions.wasm.v3.ReloadConfig.
 * Use `create(ReloadConfigSchema)` to create a new message.
 */
export declare const ReloadConfigSchema: GenMessage<ReloadConfig>;

/**
 * Configuration for restricting Proxy-Wasm capabilities available to modules.
 *
 * @generated from message envoy.extensions.wasm.v3.CapabilityRestrictionConfig
 */
export declare type CapabilityRestrictionConfig = Message<"envoy.extensions.wasm.v3.CapabilityRestrictionConfig"> & {
  /**
   * The Proxy-Wasm capabilities which will be allowed. Capabilities are mapped by
   * name. The ``SanitizationConfig`` which each capability maps to is currently unimplemented and ignored,
   * and so should be left empty.
   *
   * The capability names are given in the
   * `Proxy-Wasm ABI <https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT>`_.
   * Additionally, the following WASI capabilities from
   * `this list <https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#modules>`_
   * are implemented and can be allowed:
   * ``fd_write``, ``fd_read``, ``fd_seek``, ``fd_close``, ``fd_fdstat_get``, ``environ_get``, ``environ_sizes_get``,
   * ``args_get``, ``args_sizes_get``, ``proc_exit``, ``clock_time_get``, ``random_get``.
   *
   * @generated from field: map<string, envoy.extensions.wasm.v3.SanitizationConfig> allowed_capabilities = 1;
   */
  allowedCapabilities: { [key: string]: SanitizationConfig };
};

/**
 * Describes the message envoy.extensions.wasm.v3.CapabilityRestrictionConfig.
 * Use `create(CapabilityRestrictionConfigSchema)` to create a new message.
 */
export declare const CapabilityRestrictionConfigSchema: GenMessage<CapabilityRestrictionConfig>;

/**
 * Configuration for sanitization of inputs to an allowed capability.
 *
 * .. note::
 *   This is currently unimplemented.
 *
 * @generated from message envoy.extensions.wasm.v3.SanitizationConfig
 */
export declare type SanitizationConfig = Message<"envoy.extensions.wasm.v3.SanitizationConfig"> & {
};

/**
 * Describes the message envoy.extensions.wasm.v3.SanitizationConfig.
 * Use `create(SanitizationConfigSchema)` to create a new message.
 */
export declare const SanitizationConfigSchema: GenMessage<SanitizationConfig>;

/**
 * Configuration for a Wasm VM.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.extensions.wasm.v3.VmConfig
 */
export declare type VmConfig = Message<"envoy.extensions.wasm.v3.VmConfig"> & {
  /**
   * An ID which will be used along with a hash of the wasm code (or the name of the registered Null
   * VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
   * ``vm_id`` and code will use the same VM. May be left blank. Sharing a VM between plugins can
   * reduce memory utilization and make sharing of data easier which may have security implications.
   * [#comment: TODO: add ref for details.]
   *
   * @generated from field: string vm_id = 1;
   */
  vmId: string;

  /**
   * The Wasm runtime type, defaults to the first available Wasm engine used at Envoy build-time.
   * The priority to search for the available engine is: v8 -> wasmtime -> wamr.
   * Available Wasm runtime types are registered as extensions. The following runtimes are included
   * in Envoy code base:
   *
   * .. _extension_envoy.wasm.runtime.null:
   *
   * **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
   * Envoy binary. The registered name is given in the ``code`` field as ``inline_string``.
   *
   * .. _extension_envoy.wasm.runtime.v8:
   *
   * **envoy.wasm.runtime.v8**: `V8 <https://v8.dev/>`_-based WebAssembly runtime.
   *
   * .. _extension_envoy.wasm.runtime.wamr:
   *
   * **envoy.wasm.runtime.wamr**: `WAMR <https://github.com/bytecodealliance/wasm-micro-runtime/>`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   *
   * .. _extension_envoy.wasm.runtime.wasmtime:
   *
   * **envoy.wasm.runtime.wasmtime**: `Wasmtime <https://wasmtime.dev/>`_-based WebAssembly runtime.
   * This runtime is not enabled in the official build.
   *
   * [#extension-category: envoy.wasm.runtime]
   *
   * @generated from field: string runtime = 2;
   */
  runtime: string;

  /**
   * The Wasm code that Envoy will execute.
   *
   * @generated from field: envoy.config.core.v3.AsyncDataSource code = 3;
   */
  code?: AsyncDataSource;

  /**
   * The Wasm configuration used in initialization of a new VM
   * (``proxy_on_start``). ``google.protobuf.Struct`` is serialized as JSON before
   * passing it to the plugin. ``google.protobuf.BytesValue`` and
   * ``google.protobuf.StringValue`` are passed directly without the wrapper.
   *
   * @generated from field: google.protobuf.Any configuration = 4;
   */
  configuration?: Any;

  /**
   * Allow the wasm file to include pre-compiled code on VMs which support it.
   *
   * .. warning::
   *   This should only be enabled for trusted sources as the precompiled code is not
   *   verified.
   *
   * @generated from field: bool allow_precompiled = 5;
   */
  allowPrecompiled: boolean;

  /**
   * If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
   * update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
   * warming state.
   *
   * @generated from field: bool nack_on_code_cache_miss = 6;
   */
  nackOnCodeCacheMiss: boolean;

  /**
   * Specifies environment variables to be injected to this VM which will be available through
   * WASI's ``environ_get`` and ``environ_get_sizes`` system calls. Note that these functions
   * are generally called implicitly by your language's standard library. Therefore, you do not
   * need to call them directly. You can access environment variables in the same way you would
   * on native platforms.
   *
   * .. warning::
   *   Envoy rejects the configuration if there's conflict of key space.
   *
   * @generated from field: envoy.extensions.wasm.v3.EnvironmentVariables environment_variables = 7;
   */
  environmentVariables?: EnvironmentVariables;
};

/**
 * Describes the message envoy.extensions.wasm.v3.VmConfig.
 * Use `create(VmConfigSchema)` to create a new message.
 */
export declare const VmConfigSchema: GenMessage<VmConfig>;

/**
 * @generated from message envoy.extensions.wasm.v3.EnvironmentVariables
 */
export declare type EnvironmentVariables = Message<"envoy.extensions.wasm.v3.EnvironmentVariables"> & {
  /**
   * The keys of *Envoy's* environment variables exposed to this VM. In other words, if a key exists in Envoy's environment
   * variables, then that key-value pair will be injected. Note that if a key does not exist, it will be ignored.
   *
   * @generated from field: repeated string host_env_keys = 1;
   */
  hostEnvKeys: string[];

  /**
   * Explicitly given key-value pairs to be injected to this VM in the form of "KEY=VALUE".
   *
   * @generated from field: map<string, string> key_values = 2;
   */
  keyValues: { [key: string]: string };
};

/**
 * Describes the message envoy.extensions.wasm.v3.EnvironmentVariables.
 * Use `create(EnvironmentVariablesSchema)` to create a new message.
 */
export declare const EnvironmentVariablesSchema: GenMessage<EnvironmentVariables>;

/**
 * Base Configuration for Wasm Plugins e.g. filters and services.
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.wasm.v3.PluginConfig
 */
export declare type PluginConfig = Message<"envoy.extensions.wasm.v3.PluginConfig"> & {
  /**
   * A unique name for a filters/services in a VM for use in identifying the filter/service if
   * multiple filters/services are handled by the same ``vm_id`` and ``root_id`` and for
   * logging/debugging.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
   * if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
   * filters/services with a blank root_id with the same ``vm_id`` will share Context(s).
   *
   * @generated from field: string root_id = 2;
   */
  rootId: string;

  /**
   * Configuration for finding or starting VM.
   *
   * @generated from oneof envoy.extensions.wasm.v3.PluginConfig.vm
   */
  vm: {
    /**
     * TODO: add referential VM configurations.
     *
     * @generated from field: envoy.extensions.wasm.v3.VmConfig vm_config = 3;
     */
    value: VmConfig;
    case: "vmConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Filter/service configuration used to configure or reconfigure a plugin
   * (``proxy_on_configure``).
   * ``google.protobuf.Struct`` is serialized as JSON before
   * passing it to the plugin. ``google.protobuf.BytesValue`` and
   * ``google.protobuf.StringValue`` are passed directly without the wrapper.
   *
   * @generated from field: google.protobuf.Any configuration = 4;
   */
  configuration?: Any;

  /**
   * If there is a fatal error on the VM (e.g. exception, ``abort()``, ``on_start`` or ``on_configure`` return false),
   * then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
   * or fail open (if 'fail_open' is set to true) by bypassing the filter.
   *
   * .. note::
   *   When ``on_start`` or ``on_configure`` return ``false`` during xDS updates the xDS configuration will be rejected and when ``on_start`` or ``on_configure`` return ``false`` on
   *   initial startup the proxy will not start.
   *
   * This field is deprecated in favor of the ``failure_policy`` field.
   *
   * @generated from field: bool fail_open = 5 [deprecated = true];
   * @deprecated
   */
  failOpen: boolean;

  /**
   * The failure policy for the plugin.
   *
   * @generated from field: envoy.extensions.wasm.v3.FailurePolicy failure_policy = 7;
   */
  failurePolicy: FailurePolicy;

  /**
   * Reload configuration. This is only applied when ``failure_policy`` is set to ``FAIL_RELOAD``.
   *
   * @generated from field: envoy.extensions.wasm.v3.ReloadConfig reload_config = 8;
   */
  reloadConfig?: ReloadConfig;

  /**
   * Configuration for restricting Proxy-Wasm capabilities available to modules.
   *
   * @generated from field: envoy.extensions.wasm.v3.CapabilityRestrictionConfig capability_restriction_config = 6;
   */
  capabilityRestrictionConfig?: CapabilityRestrictionConfig;

  /**
   * Whether or not to allow plugin onRequestHeaders and onResponseHeaders callbacks to return
   * FilterHeadersStatus::StopIteration.
   *
   * @generated from field: google.protobuf.BoolValue allow_on_headers_stop_iteration = 9;
   */
  allowOnHeadersStopIteration?: boolean;
};

/**
 * Describes the message envoy.extensions.wasm.v3.PluginConfig.
 * Use `create(PluginConfigSchema)` to create a new message.
 */
export declare const PluginConfigSchema: GenMessage<PluginConfig>;

/**
 * WasmService is configured as a built-in ``envoy.wasm_service`` :ref:`WasmService
 * <config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
 *
 * @generated from message envoy.extensions.wasm.v3.WasmService
 */
export declare type WasmService = Message<"envoy.extensions.wasm.v3.WasmService"> & {
  /**
   * General plugin configuration.
   *
   * @generated from field: envoy.extensions.wasm.v3.PluginConfig config = 1;
   */
  config?: PluginConfig;

  /**
   * If true, create a single VM rather than creating one VM per worker. Such a singleton can
   * not be used with filters.
   *
   * @generated from field: bool singleton = 2;
   */
  singleton: boolean;
};

/**
 * Describes the message envoy.extensions.wasm.v3.WasmService.
 * Use `create(WasmServiceSchema)` to create a new message.
 */
export declare const WasmServiceSchema: GenMessage<WasmService>;

/**
 * If there is a fatal error on the VM (e.g. exception, ``abort()``), then the policy will be applied.
 *
 * @generated from enum envoy.extensions.wasm.v3.FailurePolicy
 */
export enum FailurePolicy {
  /**
   * No policy is specified. The default policy will be used. The default policy is ``FAIL_CLOSED``.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * New plugin instance will be created for the new request if the VM is failed. Note this will only
   * be applied to the following failures:
   *
   * * ``proxy_wasm::FailState::RuntimeError``
   *
   * This will fallback to the ``FAIL_CLOSED`` for all other failures.
   *
   * @generated from enum value: FAIL_RELOAD = 1;
   */
  FAIL_RELOAD = 1,

  /**
   * All plugins associated with the VM will return an HTTP 503 error.
   *
   * @generated from enum value: FAIL_CLOSED = 2;
   */
  FAIL_CLOSED = 2,

  /**
   * All plugins associated with the VM will be ignored and the filter chain will continue. This
   * makes sense when the plugin is optional.
   *
   * @generated from enum value: FAIL_OPEN = 3;
   */
  FAIL_OPEN = 3,
}

/**
 * Describes the enum envoy.extensions.wasm.v3.FailurePolicy.
 */
export declare const FailurePolicySchema: GenEnum<FailurePolicy>;

