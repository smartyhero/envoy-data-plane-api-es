// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/transport_sockets/tls/v3/tls.proto (package envoy.extensions.transport_sockets.tls.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { CertificateProviderPluginInstance, CertificateValidationContext, TlsCertificate, TlsParameters, TlsSessionTicketKeys } from "./common_pb";
import type { SdsSecretConfig } from "./secret_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";
import type { CidrRange } from "../../../../config/core/v3/address_pb";
import type { TypedExtensionConfig } from "../../../../config/core/v3/extension_pb";

/**
 * Describes the file envoy/extensions/transport_sockets/tls/v3/tls.proto.
 */
export declare const file_envoy_extensions_transport_sockets_tls_v3_tls: GenFile;

/**
 * [#next-free-field: 8]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
 */
export declare type UpstreamTlsContext = Message<"envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"> & {
  /**
   * Common TLS context settings.
   *
   * .. attention::
   *
   *   Server certificate verification is not enabled by default. To enable verification, configure
   *   :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
   */
  commonTlsContext?: CommonTlsContext;

  /**
   * SNI string to use when creating TLS backend connections.
   *
   * @generated from field: string sni = 2;
   */
  sni: string;

  /**
   * If true, replaces the SNI for the connection with the hostname of the upstream host, if
   * the hostname is known due to either a DNS cluster type or the
   * :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>` is set on
   * the host.
   *
   * See :ref:`SNI configuration <start_quick_start_securing_sni_client>` for details on how this
   * interacts with other validation options.
   *
   * @generated from field: bool auto_host_sni = 6;
   */
  autoHostSni: boolean;

  /**
   * If true, replaces any Subject Alternative Name (SAN) validations with a validation for a DNS SAN matching
   * the SNI value sent. The validation uses the actual requested SNI, regardless of how the SNI is configured.
   *
   * For common cases where an SNI value is present and the server certificate should include a corresponding SAN,
   * this option ensures the SAN is properly validated.
   *
   * See the :ref:`validation configuration <start_quick_start_securing_validation>` for how this interacts with
   * other validation options.
   *
   * @generated from field: bool auto_sni_san_validation = 7;
   */
  autoSniSanValidation: boolean;

  /**
   * If true, server-initiated TLS renegotiation will be allowed.
   *
   * .. attention::
   *
   *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
   *
   * @generated from field: bool allow_renegotiation = 3;
   */
  allowRenegotiation: boolean;

  /**
   * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
   * for TLSv1.2 and older) to be stored for session resumption.
   *
   * Defaults to 1, setting this to 0 disables session resumption.
   *
   * @generated from field: google.protobuf.UInt32Value max_session_keys = 4;
   */
  maxSessionKeys?: number;

  /**
   * Controls enforcement of the ``keyUsage`` extension in peer certificates. If set to ``true``, the handshake will fail if
   * the ``keyUsage`` is incompatible with TLS usage.
   *
   * .. note::
   *   The default value is ``false`` (i.e., enforcement off). It is expected to change to ``true`` in a future release.
   *
   * The ``ssl.was_key_usage_invalid`` in :ref:`listener metrics <config_listener_stats>` metric will be incremented
   * for configurations that would fail if this option were enabled.
   *
   * @generated from field: google.protobuf.BoolValue enforce_rsa_key_usage = 5;
   */
  enforceRsaKeyUsage?: boolean;
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext.
 * Use `create(UpstreamTlsContextSchema)` to create a new message.
 */
export declare const UpstreamTlsContextSchema: GenMessage<UpstreamTlsContext>;

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
 */
export declare type DownstreamTlsContext = Message<"envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext"> & {
  /**
   * Common TLS context settings.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
   */
  commonTlsContext?: CommonTlsContext;

  /**
   * If specified, Envoy will reject connections without a valid client
   * certificate.
   *
   * @generated from field: google.protobuf.BoolValue require_client_certificate = 2;
   */
  requireClientCertificate?: boolean;

  /**
   * If specified, Envoy will reject connections without a valid and matching SNI.
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.BoolValue require_sni = 3;
   */
  requireSni?: boolean;

  /**
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_type
   */
  sessionTicketKeysType: {
    /**
     * TLS session ticket key settings.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys session_ticket_keys = 4;
     */
    value: TlsSessionTicketKeys;
    case: "sessionTicketKeys";
  } | {
    /**
     * Config for fetching TLS session ticket keys via SDS API.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;
     */
    value: SdsSecretConfig;
    case: "sessionTicketKeysSdsSecretConfig";
  } | {
    /**
     * Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
     * server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
     * If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
     * the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
     * or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
     * If this config is set to false and no keys are explicitly configured, the TLS server will issue
     * TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
     * implication that sessions cannot be resumed across hot restarts or on different hosts.
     *
     * @generated from field: bool disable_stateless_session_resumption = 7;
     */
    value: boolean;
    case: "disableStatelessSessionResumption";
  } | { case: undefined; value?: undefined };

  /**
   * If ``true``, the TLS server will not maintain a session cache of TLS sessions.
   *
   * .. note::
   *   This applies only to TLSv1.2 and earlier.
   *
   *
   * @generated from field: bool disable_stateful_session_resumption = 10;
   */
  disableStatefulSessionResumption: boolean;

  /**
   * Maximum lifetime of TLS sessions. If specified, ``session_timeout`` will change the maximum lifetime
   * of the TLS session.
   *
   * This serves as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
   * Only whole seconds are considered; fractional seconds are ignored.
   *
   * @generated from field: google.protobuf.Duration session_timeout = 6;
   */
  sessionTimeout?: Duration;

  /**
   * Configuration for handling certificates without an OCSP response or with expired responses.
   *
   * Defaults to ``LENIENT_STAPLING``
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy ocsp_staple_policy = 8;
   */
  ocspStaplePolicy: DownstreamTlsContext_OcspStaplePolicy;

  /**
   * Multiple certificates are allowed in Downstream transport socket to serve different SNI.
   * This option controls the behavior when no matching certificate is found for the received SNI value,
   * or no SNI value was sent. If enabled, all certificates will be evaluated for a match for non-SNI criteria
   * such as key type and OCSP settings. If disabled, the first provided certificate will be used.
   * Defaults to ``false``. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
   *
   * @generated from field: google.protobuf.BoolValue full_scan_certs_on_sni_mismatch = 9;
   */
  fullScanCertsOnSniMismatch?: boolean;

  /**
   * If ``true``, the downstream client's preferred cipher is used during the handshake. If ``false``, Envoy
   * uses its preferred cipher.
   *
   * .. note::
   *   This has no effect when using TLSv1_3.
   *
   *
   * @generated from field: bool prefer_client_ciphers = 11;
   */
  preferClientCiphers: boolean;
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.
 * Use `create(DownstreamTlsContextSchema)` to create a new message.
 */
export declare const DownstreamTlsContextSchema: GenMessage<DownstreamTlsContext>;

/**
 * @generated from enum envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy
 */
export enum DownstreamTlsContext_OcspStaplePolicy {
  /**
   * OCSP responses are optional. If absent or expired, the certificate is used without stapling.
   *
   * @generated from enum value: LENIENT_STAPLING = 0;
   */
  LENIENT_STAPLING = 0,

  /**
   * OCSP responses are optional. If absent, the certificate is used without stapling. If present but expired,
   * the certificate is not used for subsequent connections. Connections are rejected if no suitable certificate
   * is found.
   *
   * @generated from enum value: STRICT_STAPLING = 1;
   */
  STRICT_STAPLING = 1,

  /**
   * OCSP responses are required. Connections fail if a certificate lacks a valid OCSP response. Expired responses
   * prevent certificate use in new connections, and connections are rejected if no suitable certificate is available.
   *
   * @generated from enum value: MUST_STAPLE = 2;
   */
  MUST_STAPLE = 2,
}

/**
 * Describes the enum envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy.
 */
export declare const DownstreamTlsContext_OcspStaplePolicySchema: GenEnum<DownstreamTlsContext_OcspStaplePolicy>;

/**
 * TLS key log configuration.
 * The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.TlsKeyLog
 */
export declare type TlsKeyLog = Message<"envoy.extensions.transport_sockets.tls.v3.TlsKeyLog"> & {
  /**
   * Path to save the TLS key log.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Local IP address ranges to filter connections for TLS key logging. If not set, matches any local IP address.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange local_address_range = 2;
   */
  localAddressRange: CidrRange[];

  /**
   * Remote IP address ranges to filter connections for TLS key logging. If not set, matches any remote IP address.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange remote_address_range = 3;
   */
  remoteAddressRange: CidrRange[];
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.TlsKeyLog.
 * Use `create(TlsKeyLogSchema)` to create a new message.
 */
export declare const TlsKeyLogSchema: GenMessage<TlsKeyLog>;

/**
 * TLS context shared by both client and server TLS contexts.
 * [#next-free-field: 17]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext
 */
export declare type CommonTlsContext = Message<"envoy.extensions.transport_sockets.tls.v3.CommonTlsContext"> & {
  /**
   * TLS protocol versions, cipher suites etc.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;
   */
  tlsParams?: TlsParameters;

  /**
   * Only a single TLS certificate is supported in client contexts. In server contexts,
   * :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
   * same context to allow both RSA and ECDSA certificates and support SNI-based selection.
   *
   * If ``tls_certificate_provider_instance`` is set, this field is ignored.
   * If this field is set, ``tls_certificate_sds_secret_configs`` is ignored.
   *
   * @generated from field: repeated envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;
   */
  tlsCertificates: TlsCertificate[];

  /**
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   *
   * The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
   * are valid in the certificates fetched through this setting.
   *
   * If ``tls_certificates`` or ``tls_certificate_provider_instance`` are set, this field
   * is ignored.
   *
   * @generated from field: repeated envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6;
   */
  tlsCertificateSdsSecretConfigs: SdsSecretConfig[];

  /**
   * Certificate provider instance for fetching TLS certs.
   *
   * If this field is set, ``tls_certificates`` and ``tls_certificate_provider_instance``
   * are ignored.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance tls_certificate_provider_instance = 14;
   */
  tlsCertificateProviderInstance?: CertificateProviderPluginInstance;

  /**
   * Custom TLS certificate selector.
   *
   * Select TLS certificate based on TLS client hello.
   * If empty, defaults to native TLS certificate selection behavior:
   * DNS SANs or Subject Common Name in TLS certificates is extracted as server name pattern to match SNI.
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_tls_certificate_selector = 16;
   */
  customTlsCertificateSelector?: TypedExtensionConfig;

  /**
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9 [deprecated = true];
   * @deprecated
   */
  tlsCertificateCertificateProvider?: CommonTlsContext_CertificateProvider;

  /**
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11 [deprecated = true];
   * @deprecated
   */
  tlsCertificateCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;

  /**
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.validation_context_type
   */
  validationContextType: {
    /**
     * How to validate peer certificates.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;
     */
    value: CertificateValidationContext;
    case: "validationContext";
  } | {
    /**
     * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
     * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;
     */
    value: SdsSecretConfig;
    case: "validationContextSdsSecretConfig";
  } | {
    /**
     * Combines the default ``CertificateValidationContext`` with the SDS-provided dynamic context for certificate
     * validation.
     *
     * When the SDS server returns a dynamic ``CertificateValidationContext``, it is merged
     * with the default context using ``Message::MergeFrom()``. The merging rules are as follows:
     *
     * * **Singular Fields:** Dynamic fields override the default singular fields.
     * * **Repeated Fields:** Dynamic repeated fields are concatenated with the default repeated fields.
     * * **Boolean Fields:** Boolean fields are combined using a logical OR operation.
     *
     * The resulting ``CertificateValidationContext`` is used to perform certificate validation.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;
     */
    value: CommonTlsContext_CombinedCertificateValidationContext;
    case: "combinedValidationContext";
  } | {
    /**
     * Certificate provider for fetching validation context.
     * [#not-implemented-hide:]
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10 [deprecated = true];
     * @deprecated
     */
    value: CommonTlsContext_CertificateProvider;
    case: "validationContextCertificateProvider";
  } | {
    /**
     * Certificate provider instance for fetching validation context.
     * [#not-implemented-hide:]
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12 [deprecated = true];
     * @deprecated
     */
    value: CommonTlsContext_CertificateProviderInstance;
    case: "validationContextCertificateProviderInstance";
  } | { case: undefined; value?: undefined };

  /**
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
   * parameter in the HTTP connection manager for more information):
   *
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   *
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   *
   * @generated from field: repeated string alpn_protocols = 4;
   */
  alpnProtocols: string[];

  /**
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;
   */
  customHandshaker?: TypedExtensionConfig;

  /**
   * TLS key log configuration
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsKeyLog key_log = 15;
   */
  keyLog?: TlsKeyLog;
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.
 * Use `create(CommonTlsContextSchema)` to create a new message.
 */
export declare const CommonTlsContextSchema: GenMessage<CommonTlsContext>;

/**
 * Config for the Certificate Provider to fetch certificates. Certificates are fetched/refreshed asynchronously over
 * the network relative to the TLS handshake.
 *
 * DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
 * move it out of CommonTlsContext and into common.proto, similar to the existing
 * CertificateProviderPluginInstance message.
 *
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider
 */
export declare type CommonTlsContext_CertificateProvider = Message<"envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider"> & {
  /**
   * opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Provider specific config.
   * Note: an implementation is expected to dedup multiple instances of the same config
   * to maintain a single certificate-provider instance. The sharing can happen, for
   * example, among multiple clusters or between the tls_certificate and validation_context
   * certificate providers of a cluster.
   * This config could be supplied inline or (in future) a named xDS resource.
   *
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider.config
   */
  config: {
    /**
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig typed_config = 2;
     */
    value: TypedExtensionConfig;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider.
 * Use `create(CommonTlsContext_CertificateProviderSchema)` to create a new message.
 */
export declare const CommonTlsContext_CertificateProviderSchema: GenMessage<CommonTlsContext_CertificateProvider>;

/**
 * Similar to CertificateProvider above, but allows the provider instances to be configured on
 * the client side instead of being sent from the control plane.
 *
 * DEPRECATED: This message was moved outside of CommonTlsContext
 * and now lives in common.proto.
 *
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance
 */
export declare type CommonTlsContext_CertificateProviderInstance = Message<"envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance"> & {
  /**
   * Provider instance name. This name must be defined in the client's configuration (e.g., a
   * bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
   * field that would be sent in the CertificateProvider message if the config was sent by the
   * control plane). If not present, defaults to "default".
   *
   * Instance names should generally be defined not in terms of the underlying provider
   * implementation (e.g., "file_watcher") but rather in terms of the function of the
   * certificates (e.g., "foo_deployment_identity").
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName: string;

  /**
   * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "example.com" to specify a certificate for a
   * particular domain. Not all provider instances will actually use this field, so the value
   * defaults to the empty string.
   *
   * @generated from field: string certificate_name = 2;
   */
  certificateName: string;
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.
 * Use `create(CommonTlsContext_CertificateProviderInstanceSchema)` to create a new message.
 */
export declare const CommonTlsContext_CertificateProviderInstanceSchema: GenMessage<CommonTlsContext_CertificateProviderInstance>;

/**
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext
 */
export declare type CommonTlsContext_CombinedCertificateValidationContext = Message<"envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext"> & {
  /**
   * How to validate peer certificates.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext default_validation_context = 1;
   */
  defaultValidationContext?: CertificateValidationContext;

  /**
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 2;
   */
  validationContextSdsSecretConfig?: SdsSecretConfig;

  /**
   * Certificate provider for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 3 [deprecated = true];
   * @deprecated
   */
  validationContextCertificateProvider?: CommonTlsContext_CertificateProvider;

  /**
   * Certificate provider instance for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 4 [deprecated = true];
   * @deprecated
   */
  validationContextCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;
};

/**
 * Describes the message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext.
 * Use `create(CommonTlsContext_CombinedCertificateValidationContextSchema)` to create a new message.
 */
export declare const CommonTlsContext_CombinedCertificateValidationContextSchema: GenMessage<CommonTlsContext_CombinedCertificateValidationContext>;

