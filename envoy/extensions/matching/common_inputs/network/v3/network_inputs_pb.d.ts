// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto (package envoy.extensions.matching.common_inputs.network.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto.
 */
export declare const file_envoy_extensions_matching_common_inputs_network_v3_network_inputs: GenFile;

/**
 * Specifies that matching should be performed by the destination IP address.
 * [#extension: envoy.matching.inputs.destination_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput
 */
export declare type DestinationIPInput = Message<"envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput.
 * Use `create(DestinationIPInputSchema)` to create a new message.
 */
export declare const DestinationIPInputSchema: GenMessage<DestinationIPInput>;

/**
 * Specifies that matching should be performed by the destination port.
 * [#extension: envoy.matching.inputs.destination_port]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput
 */
export declare type DestinationPortInput = Message<"envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput.
 * Use `create(DestinationPortInputSchema)` to create a new message.
 */
export declare const DestinationPortInputSchema: GenMessage<DestinationPortInput>;

/**
 * Specifies that matching should be performed by the source IP address.
 * [#extension: envoy.matching.inputs.source_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourceIPInput
 */
export declare type SourceIPInput = Message<"envoy.extensions.matching.common_inputs.network.v3.SourceIPInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.SourceIPInput.
 * Use `create(SourceIPInputSchema)` to create a new message.
 */
export declare const SourceIPInputSchema: GenMessage<SourceIPInput>;

/**
 * Specifies that matching should be performed by the source port.
 * [#extension: envoy.matching.inputs.source_port]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourcePortInput
 */
export declare type SourcePortInput = Message<"envoy.extensions.matching.common_inputs.network.v3.SourcePortInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.SourcePortInput.
 * Use `create(SourcePortInputSchema)` to create a new message.
 */
export declare const SourcePortInputSchema: GenMessage<SourcePortInput>;

/**
 * Input that matches by the directly connected source IP address (this
 * will only be different from the source IP address when using a listener
 * filter that overrides the source address, such as the :ref:`Proxy Protocol
 * listener filter <config_listener_filters_proxy_protocol>`).
 * [#extension: envoy.matching.inputs.direct_source_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput
 */
export declare type DirectSourceIPInput = Message<"envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput.
 * Use `create(DirectSourceIPInputSchema)` to create a new message.
 */
export declare const DirectSourceIPInputSchema: GenMessage<DirectSourceIPInput>;

/**
 * Input that matches by the source IP type.
 * Specifies the source IP match type. The values include:
 *
 * * ``local`` - matches a connection originating from the same host,
 * [#extension: envoy.matching.inputs.source_type]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput
 */
export declare type SourceTypeInput = Message<"envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput.
 * Use `create(SourceTypeInputSchema)` to create a new message.
 */
export declare const SourceTypeInputSchema: GenMessage<SourceTypeInput>;

/**
 * Input that matches by the requested server name (e.g. SNI in TLS).
 *
 * :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides the requested server name based on SNI,
 * when TLS protocol is detected.
 * [#extension: envoy.matching.inputs.server_name]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.ServerNameInput
 */
export declare type ServerNameInput = Message<"envoy.extensions.matching.common_inputs.network.v3.ServerNameInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.ServerNameInput.
 * Use `create(ServerNameInputSchema)` to create a new message.
 */
export declare const ServerNameInputSchema: GenMessage<ServerNameInput>;

/**
 * Input that matches by the transport protocol.
 *
 * Suggested values include:
 *
 * * ``raw_buffer`` - default, used when no transport protocol is detected,
 * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
 *   when TLS protocol is detected.
 * [#extension: envoy.matching.inputs.transport_protocol]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput
 */
export declare type TransportProtocolInput = Message<"envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput.
 * Use `create(TransportProtocolInputSchema)` to create a new message.
 */
export declare const TransportProtocolInputSchema: GenMessage<TransportProtocolInput>;

/**
 * List of quoted and comma-separated requested application protocols. The list consists of a
 * single negotiated application protocol once the network stream is established.
 *
 * Examples:
 *
 * * ``'h2','http/1.1'``
 * * ``'h2c'``
 *
 * Suggested values in the list include:
 *
 * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
 *   <config_listener_filters_tls_inspector>` and :ref:`envoy.filters.listener.http_inspector
 *   <config_listener_filters_http_inspector>`,
 * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
 * * ``h2c`` - set by :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`
 *
 * .. attention::
 *
 *   Currently, :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
 *   application protocol detection based on the requested
 *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
 *
 *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
 *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
 *   unless all connecting clients are known to use ALPN.
 * [#extension: envoy.matching.inputs.application_protocol]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput
 */
export declare type ApplicationProtocolInput = Message<"envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput.
 * Use `create(ApplicationProtocolInputSchema)` to create a new message.
 */
export declare const ApplicationProtocolInputSchema: GenMessage<ApplicationProtocolInput>;

/**
 * Input that matches by a specific filter state key.
 * The value of the provided filter state key will be the raw string representation of the filter state object
 * [#extension: envoy.matching.inputs.filter_state]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
 */
export declare type FilterStateInput = Message<"envoy.extensions.matching.common_inputs.network.v3.FilterStateInput"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.FilterStateInput.
 * Use `create(FilterStateInputSchema)` to create a new message.
 */
export declare const FilterStateInputSchema: GenMessage<FilterStateInput>;

/**
 * Input that matches dynamic metadata by key.
 * DynamicMetadataInput provides a general interface using ``filter`` and ``path`` to retrieve value from
 * :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`.
 *
 * For example, for the following Metadata:
 *
 * .. code-block:: yaml
 *
 *    filter_metadata:
 *      envoy.xxx:
 *        prop:
 *          foo: bar
 *          xyz:
 *            hello: envoy
 *
 * The following DynamicMetadataInput will retrieve a string value "bar" from the Metadata.
 *
 * .. code-block:: yaml
 *
 *    filter: envoy.xxx
 *    path:
 *    - key: prop
 *    - key: foo
 *
 * [#extension: envoy.matching.inputs.dynamic_metadata]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput
 */
export declare type DynamicMetadataInput = Message<"envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput"> & {
  /**
   * The filter name to retrieve the Struct from the Metadata.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * The path to retrieve the Value from the Struct.
   *
   * @generated from field: repeated envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment path = 2;
   */
  path: DynamicMetadataInput_PathSegment[];
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.
 * Use `create(DynamicMetadataInputSchema)` to create a new message.
 */
export declare const DynamicMetadataInputSchema: GenMessage<DynamicMetadataInput>;

/**
 * Specifies the segment in a path to retrieve value from Metadata.
 * Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
 * if the segment key refers to a list, it has to be the last segment in a path.
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment
 */
export declare type DynamicMetadataInput_PathSegment = Message<"envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment"> & {
  /**
   * @generated from oneof envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment.segment
   */
  segment: {
    /**
     * If specified, use the key to retrieve the value in a Struct.
     *
     * @generated from field: string key = 1;
     */
    value: string;
    case: "key";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.DynamicMetadataInput.PathSegment.
 * Use `create(DynamicMetadataInput_PathSegmentSchema)` to create a new message.
 */
export declare const DynamicMetadataInput_PathSegmentSchema: GenMessage<DynamicMetadataInput_PathSegment>;

/**
 * Input that matches by the network namespace of the listener address.
 * This input returns the network namespace filepath that was used to create the listening socket.
 * On Linux systems, this corresponds to the ``network_namespace_filepath`` field in the
 * :ref:`SocketAddress <envoy_v3_api_msg_config.core.v3.SocketAddress>` configuration.
 *
 * .. note::
 *
 *   This input is only meaningful on Linux systems where network namespaces are supported.
 *   On other platforms, this input will always return an empty value.
 *
 * [#extension: envoy.matching.inputs.network_namespace]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.NetworkNamespaceInput
 */
export declare type NetworkNamespaceInput = Message<"envoy.extensions.matching.common_inputs.network.v3.NetworkNamespaceInput"> & {
};

/**
 * Describes the message envoy.extensions.matching.common_inputs.network.v3.NetworkNamespaceInput.
 * Use `create(NetworkNamespaceInputSchema)` to create a new message.
 */
export declare const NetworkNamespaceInputSchema: GenMessage<NetworkNamespaceInput>;

