// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto (package envoy.extensions.filters.udp.udp_proxy.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Matcher } from "../../../../../../xds/type/matcher/v3/matcher_pb";
import type { Any, Duration } from "@bufbuild/protobuf/wkt";
import type { UdpSocketConfig } from "../../../../../config/core/v3/udp_socket_config_pb";
import type { AccessLog } from "../../../../../config/accesslog/v3/accesslog_pb";
import type { ExtensionConfigSource } from "../../../../../config/core/v3/config_source_pb";
import type { HeaderValueOption } from "../../../../../config/core/v3/base_pb";
import type { BackoffStrategy } from "../../../../../config/core/v3/backoff_pb";

/**
 * Describes the file envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto.
 */
export declare const file_envoy_extensions_filters_udp_udp_proxy_v3_udp_proxy: GenFile;

/**
 * Configuration for the UDP proxy filter.
 * [#next-free-field: 14]
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig
 */
export declare type UdpProxyConfig = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig"> & {
  /**
   * The stat prefix used when emitting UDP proxy filter stats.
   *
   * @generated from field: string stat_prefix = 1;
   */
  statPrefix: string;

  /**
   * @generated from oneof envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.route_specifier
   */
  routeSpecifier: {
    /**
     * The upstream cluster to connect to.
     * This field is deprecated in favor of
     * :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
     *
     * @generated from field: string cluster = 2 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * The match tree to use when resolving route actions for incoming requests.
     * See :ref:`Routing <config_udp_listener_filters_udp_proxy_routing>` for more information.
     *
     * @generated from field: xds.type.matcher.v3.Matcher matcher = 9;
     */
    value: Matcher;
    case: "matcher";
  } | { case: undefined; value?: undefined };

  /**
   * The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
   * the session. The default if not specified is 1 minute.
   *
   * @generated from field: google.protobuf.Duration idle_timeout = 3;
   */
  idleTimeout?: Duration;

  /**
   * Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
   * This option requires Envoy to be run with the ``CAP_NET_ADMIN`` capability on Linux.
   * And the IPv6 stack must be enabled on Linux kernel.
   * This option does not preserve the remote downstream port.
   * If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
   * This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
   * will send the packets with the remote downstream IP address as the destination. All packets will be routed
   * to the remote downstream directly if there are route rules on the upstream host side.
   * There are two options to return the packets back to the remote downstream.
   * The first one is to use DSR (Direct Server Return).
   * The other one is to configure routing rules on the upstream hosts to forward
   * all packets back to Envoy and configure iptables rules on the host running Envoy to
   * forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
   * If the platform does not support this option, Envoy will raise a configuration error.
   *
   * @generated from field: bool use_original_src_ip = 4;
   */
  useOriginalSrcIp: boolean;

  /**
   * Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   *
   * @generated from field: repeated envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy hash_policies = 5;
   */
  hashPolicies: UdpProxyConfig_HashPolicy[];

  /**
   * UDP socket configuration for upstream sockets. The default for
   * :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
   * sockets as the assumption is datagrams will be received from a single source.
   *
   * @generated from field: envoy.config.core.v3.UdpSocketConfig upstream_socket_config = 6;
   */
  upstreamSocketConfig?: UdpSocketConfig;

  /**
   * Perform per packet load balancing (upstream host selection) on each received data chunk.
   * The default if not specified is false, that means each data chunk is forwarded
   * to upstream host selected on first chunk receival for that "session" (identified by source IP/port and local IP/port).
   * Only one of use_per_packet_load_balancing or session_filters can be used.
   *
   * @generated from field: bool use_per_packet_load_balancing = 7;
   */
  usePerPacketLoadBalancing: boolean;

  /**
   * Configuration for session access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLog access_log = 8;
   */
  accessLog: AccessLog[];

  /**
   * Configuration for proxy access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLog proxy_access_log = 10;
   */
  proxyAccessLog: AccessLog[];

  /**
   * Optional session filters that will run for each UDP session.
   * Only one of use_per_packet_load_balancing or session_filters can be used.
   * [#extension-category: envoy.filters.udp.session]
   *
   * @generated from field: repeated envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter session_filters = 11;
   */
  sessionFilters: UdpProxyConfig_SessionFilter[];

  /**
   * If set, this configures UDP tunneling. See `Proxying UDP in HTTP <https://www.rfc-editor.org/rfc/rfc9298.html>`_.
   * More information can be found in the UDP Proxy and HTTP upgrade documentation.
   *
   * @generated from field: envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig tunneling_config = 12;
   */
  tunnelingConfig?: UdpProxyConfig_UdpTunnelingConfig;

  /**
   * Additional access log options for UDP Proxy.
   *
   * @generated from field: envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions access_log_options = 13;
   */
  accessLogOptions?: UdpProxyConfig_UdpAccessLogOptions;
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.
 * Use `create(UdpProxyConfigSchema)` to create a new message.
 */
export declare const UdpProxyConfigSchema: GenMessage<UdpProxyConfig>;

/**
 * Specifies the UDP hash policy.
 * The packets can be routed by hash policy.
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy
 */
export declare type UdpProxyConfig_HashPolicy = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy"> & {
  /**
   * @generated from oneof envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy.policy_specifier
   */
  policySpecifier: {
    /**
     * The source IP will be used to compute the hash used by hash-based load balancing algorithms.
     *
     * @generated from field: bool source_ip = 1;
     */
    value: boolean;
    case: "sourceIp";
  } | {
    /**
     * A given key will be used to compute the hash used by hash-based load balancing algorithms.
     * In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
     * A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
     * although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
     * (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
     *
     * @generated from field: string key = 2;
     */
    value: string;
    case: "key";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy.
 * Use `create(UdpProxyConfig_HashPolicySchema)` to create a new message.
 */
export declare const UdpProxyConfig_HashPolicySchema: GenMessage<UdpProxyConfig_HashPolicy>;

/**
 * Configuration for UDP session filters.
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter
 */
export declare type UdpProxyConfig_SessionFilter = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter"> & {
  /**
   * The name of the filter configuration.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter.config_type
   */
  configType: {
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     *
     * @generated from field: google.protobuf.Any typed_config = 2;
     */
    value: Any;
    case: "typedConfig";
  } | {
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * UDP session will be removed.
     *
     * @generated from field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 3;
     */
    value: ExtensionConfigSource;
    case: "configDiscovery";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.SessionFilter.
 * Use `create(UdpProxyConfig_SessionFilterSchema)` to create a new message.
 */
export declare const UdpProxyConfig_SessionFilterSchema: GenMessage<UdpProxyConfig_SessionFilter>;

/**
 * Configuration for tunneling UDP over other transports or application layers.
 * Tunneling is currently supported over HTTP/2.
 * [#next-free-field: 12]
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig
 */
export declare type UdpProxyConfig_UdpTunnelingConfig = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig"> & {
  /**
   * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set hostname using filter state
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      proxy_host: "%FILTER_STATE(proxy.host.key:PLAIN)%"
   *
   *
   * @generated from field: string proxy_host = 1;
   */
  proxyHost: string;

  /**
   * Optional port value to add to the HTTP request URI.
   * This value can be overridden per-session by setting the required port value for
   * the filter state key ``udp.connect.proxy_port``.
   *
   * @generated from field: google.protobuf.UInt32Value proxy_port = 2;
   */
  proxyPort?: number;

  /**
   * The target host to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set target host using filter state
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      target_host: "%FILTER_STATE(target.host.key:PLAIN)%"
   *
   *
   * @generated from field: string target_host = 3;
   */
  targetHost: string;

  /**
   * The default target port to send in the CONNECT headers to the upstream proxy.
   * This value can be overridden per-session by setting the required port value for
   * the filter state key ``udp.connect.target_port``.
   *
   * @generated from field: uint32 default_target_port = 4;
   */
  defaultTargetPort: number;

  /**
   * Use POST method instead of CONNECT method to tunnel the UDP stream.
   *
   * .. note::
   *   If use_post is set, the upstream stream does not comply with the connect-udp RFC, and
   *   instead it will be a POST request. the path used in the headers will be set from the
   *   post_path field, and the headers will not contain the target host and target port, as
   *   required by the connect-udp protocol. This flag should be used carefully.
   *
   *
   * @generated from field: bool use_post = 5;
   */
  usePost: boolean;

  /**
   * The path used with POST method. Default path is ``/``. If post path is specified and
   * use_post field isn't true, it will be rejected.
   *
   * @generated from field: string post_path = 6;
   */
  postPath: string;

  /**
   * Optional retry options, in case connecting to the upstream failed.
   *
   * @generated from field: envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions retry_options = 7;
   */
  retryOptions?: UdpProxyConfig_UdpTunnelingConfig_RetryOptions;

  /**
   * Additional request headers to upstream proxy. Neither ``:-prefixed`` pseudo-headers
   * nor the Host: header can be overridden. Values of the added headers evaluates command
   * operators if they are set in the value template.
   *
   * Example: dynamically set a header with the local port
   *
   * .. code-block:: yaml
   *
   *    headers_to_add:
   *    - header:
   *        key: original_dst_port
   *        value: "%DOWNSTREAM_LOCAL_PORT%"
   *
   *
   * @generated from field: repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 8;
   */
  headersToAdd: HeaderValueOption[];

  /**
   * If configured, the filter will buffer datagrams in case that it is waiting for the upstream to be
   * ready, whether if it is during the connection process or due to upstream buffer watermarks.
   * If this field is not configured, there will be no buffering and downstream datagrams that arrive
   * while the upstream is not ready will be dropped. In case this field is set but the options
   * are not configured, the default values will be applied as described in the ``BufferOptions``.
   *
   * @generated from field: envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions buffer_options = 9;
   */
  bufferOptions?: UdpProxyConfig_UdpTunnelingConfig_BufferOptions;

  /**
   * Save the response headers to the downstream info filter state for consumption
   * by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_headers``.
   *
   * @generated from field: bool propagate_response_headers = 10;
   */
  propagateResponseHeaders: boolean;

  /**
   * Save the response trailers to the downstream info filter state for consumption
   * by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_trailers``.
   *
   * @generated from field: bool propagate_response_trailers = 11;
   */
  propagateResponseTrailers: boolean;
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.
 * Use `create(UdpProxyConfig_UdpTunnelingConfigSchema)` to create a new message.
 */
export declare const UdpProxyConfig_UdpTunnelingConfigSchema: GenMessage<UdpProxyConfig_UdpTunnelingConfig>;

/**
 * Configuration for UDP datagrams buffering.
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions
 */
export declare type UdpProxyConfig_UdpTunnelingConfig_BufferOptions = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions"> & {
  /**
   * If set, the filter will only buffer datagrams up to the requested limit, and will drop
   * new UDP datagrams if the buffer contains the max_buffered_datagrams value at the time
   * of a new datagram arrival. If not set, the default value is 1024 datagrams.
   *
   * @generated from field: google.protobuf.UInt32Value max_buffered_datagrams = 1;
   */
  maxBufferedDatagrams?: number;

  /**
   * If set, the filter will only buffer datagrams up to the requested total buffered bytes limit,
   * and will drop new UDP datagrams if the buffer contains the max_buffered_datagrams value
   * at the time of a new datagram arrival. If not set, the default value is 16,384 (16KB).
   *
   * @generated from field: google.protobuf.UInt64Value max_buffered_bytes = 2;
   */
  maxBufferedBytes?: bigint;
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.BufferOptions.
 * Use `create(UdpProxyConfig_UdpTunnelingConfig_BufferOptionsSchema)` to create a new message.
 */
export declare const UdpProxyConfig_UdpTunnelingConfig_BufferOptionsSchema: GenMessage<UdpProxyConfig_UdpTunnelingConfig_BufferOptions>;

/**
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions
 */
export declare type UdpProxyConfig_UdpTunnelingConfig_RetryOptions = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions"> & {
  /**
   * The maximum number of unsuccessful connection attempts that will be made before giving up.
   * If the parameter is not specified, 1 connection attempt will be made.
   *
   * @generated from field: google.protobuf.UInt32Value max_connect_attempts = 1;
   */
  maxConnectAttempts?: number;

  /**
   * Sets the backoff strategy. If not set, the retries are performed without backoff.
   *
   * @generated from field: envoy.config.core.v3.BackoffStrategy backoff_options = 2;
   */
  backoffOptions?: BackoffStrategy;
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.RetryOptions.
 * Use `create(UdpProxyConfig_UdpTunnelingConfig_RetryOptionsSchema)` to create a new message.
 */
export declare const UdpProxyConfig_UdpTunnelingConfig_RetryOptionsSchema: GenMessage<UdpProxyConfig_UdpTunnelingConfig_RetryOptions>;

/**
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions
 */
export declare type UdpProxyConfig_UdpAccessLogOptions = Message<"envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions"> & {
  /**
   * The interval to flush access log. The UDP proxy will flush only one access log when the session
   * is ended by default. If this field is set, the UDP proxy will flush access log periodically with
   * the specified interval.
   * This field does not require on-tunnel-connected access logging enabled, and the other way around.
   * The interval must be at least 1ms.
   *
   * @generated from field: google.protobuf.Duration access_log_flush_interval = 1;
   */
  accessLogFlushInterval?: Duration;

  /**
   * If set to true and UDP tunneling is configured, access log will be flushed when the UDP proxy has successfully
   * established a connection tunnel with the upstream. If the connection failed, the access log will not be flushed.
   *
   * @generated from field: bool flush_access_log_on_tunnel_connected = 2;
   */
  flushAccessLogOnTunnelConnected: boolean;
};

/**
 * Describes the message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpAccessLogOptions.
 * Use `create(UdpProxyConfig_UdpAccessLogOptionsSchema)` to create a new message.
 */
export declare const UdpProxyConfig_UdpAccessLogOptionsSchema: GenMessage<UdpProxyConfig_UdpAccessLogOptions>;

