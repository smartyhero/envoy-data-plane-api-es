// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/filters/network/dubbo_proxy/v3/route.proto (package envoy.extensions.filters.network.dubbo_proxy.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { HeaderMatcher, WeightedCluster } from "../../../../../config/route/v3/route_components_pb";
import type { Metadata } from "../../../../../config/core/v3/base_pb";
import type { StringMatcher } from "../../../../../type/matcher/v3/string_pb";
import type { Int64Range } from "../../../../../type/v3/range_pb";

/**
 * Describes the file envoy/extensions/filters/network/dubbo_proxy/v3/route.proto.
 */
export declare const file_envoy_extensions_filters_network_dubbo_proxy_v3_route: GenFile;

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration
 */
export declare type RouteConfiguration = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration"> & {
  /**
   * The name of the route configuration. Reserved for future use in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The interface name of the service. Wildcard interface are supported in the suffix or prefix form.
   * e.g. ``*.methods.add`` will match ``com.dev.methods.add``, ``com.prod.methods.add``, etc.
   * ``com.dev.methods.*`` will match ``com.dev.methods.add``, ``com.dev.methods.update``, etc.
   * Special wildcard ``*`` matching any interface.
   *
   * .. note::
   *
   *  The wildcard will not match the empty string.
   *  e.g. ``*.methods.add`` will match ``com.dev.methods.add`` but not ``.methods.add``.
   *
   * @generated from field: string interface = 2;
   */
  interface: string;

  /**
   * Which group does the interface belong to.
   *
   * @generated from field: string group = 3;
   */
  group: string;

  /**
   * The version number of the interface.
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * The list of routes that will be matched, in order, against incoming requests. The first route
   * that matches will be used.
   *
   * @generated from field: repeated envoy.extensions.filters.network.dubbo_proxy.v3.Route routes = 5;
   */
  routes: Route[];
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration.
 * Use `create(RouteConfigurationSchema)` to create a new message.
 */
export declare const RouteConfigurationSchema: GenMessage<RouteConfiguration>;

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.Route
 */
export declare type Route = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.Route"> & {
  /**
   * Route matching parameters.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * Route request to some upstream cluster.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction route = 2;
   */
  route?: RouteAction;
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.Route.
 * Use `create(RouteSchema)` to create a new message.
 */
export declare const RouteSchema: GenMessage<Route>;

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch
 */
export declare type RouteMatch = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch"> & {
  /**
   * Method level routing matching.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch method = 1;
   */
  method?: MethodMatch;

  /**
   * Specifies a set of headers that the route should match on. The router will check the requestâ€™s
   * headers against all the specified headers in the route config. A match will happen if all the
   * headers in the route are present in the request with the same values (or based on presence if
   * the value field is not in the config).
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 2;
   */
  headers: HeaderMatcher[];
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch.
 * Use `create(RouteMatchSchema)` to create a new message.
 */
export declare const RouteMatchSchema: GenMessage<RouteMatch>;

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction
 */
export declare type RouteAction = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction"> & {
  /**
   * @generated from oneof envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * Indicates the upstream cluster to which the request should be routed.
     *
     * @generated from field: string cluster = 1;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     * Currently ClusterWeight only supports the name and weight fields.
     *
     * @generated from field: envoy.config.route.v3.WeightedCluster weighted_clusters = 2;
     */
    value: WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };

  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
   * the upstream cluster with metadata matching what is set in this field will be considered for
   * load balancing. The filter name should be specified as ``envoy.lb``.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata_match = 3;
   */
  metadataMatch?: Metadata;
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction.
 * Use `create(RouteActionSchema)` to create a new message.
 */
export declare const RouteActionSchema: GenMessage<RouteAction>;

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch
 */
export declare type MethodMatch = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch"> & {
  /**
   * The name of the method.
   *
   * @generated from field: envoy.type.matcher.v3.StringMatcher name = 1;
   */
  name?: StringMatcher;

  /**
   * Method parameter definition.
   * The key is the parameter index, starting from 0.
   * The value is the parameter matching type.
   *
   * @generated from field: map<uint32, envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier> params_match = 2;
   */
  paramsMatch: { [key: number]: MethodMatch_ParameterMatchSpecifier };
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.
 * Use `create(MethodMatchSchema)` to create a new message.
 */
export declare const MethodMatchSchema: GenMessage<MethodMatch>;

/**
 * The parameter matching type.
 *
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier
 */
export declare type MethodMatch_ParameterMatchSpecifier = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier"> & {
  /**
   * @generated from oneof envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier.parameter_match_specifier
   */
  parameterMatchSpecifier: {
    /**
     * If specified, header match will be performed based on the value of the header.
     *
     * @generated from field: string exact_match = 3;
     */
    value: string;
    case: "exactMatch";
  } | {
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting
     * of an optional plus or minus sign followed by a sequence of digits. The rule will not match
     * if the header value does not represent an integer. Match will fail for empty values,
     * floating point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0,
     *   "somestring", 10.9, "-1somestring"
     *
     * @generated from field: envoy.type.v3.Int64Range range_match = 4;
     */
    value: Int64Range;
    case: "rangeMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier.
 * Use `create(MethodMatch_ParameterMatchSpecifierSchema)` to create a new message.
 */
export declare const MethodMatch_ParameterMatchSpecifierSchema: GenMessage<MethodMatch_ParameterMatchSpecifier>;

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MultipleRouteConfiguration
 */
export declare type MultipleRouteConfiguration = Message<"envoy.extensions.filters.network.dubbo_proxy.v3.MultipleRouteConfiguration"> & {
  /**
   * The name of the named route configurations. This name is used in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The route table of the dubbo connection manager.
   *
   * @generated from field: repeated envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration route_config = 4;
   */
  routeConfig: RouteConfiguration[];
};

/**
 * Describes the message envoy.extensions.filters.network.dubbo_proxy.v3.MultipleRouteConfiguration.
 * Use `create(MultipleRouteConfigurationSchema)` to create a new message.
 */
export declare const MultipleRouteConfigurationSchema: GenMessage<MultipleRouteConfiguration>;

