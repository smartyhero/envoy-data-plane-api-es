// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/extensions/filters/http/api_key_auth/v3/api_key_auth.proto (package envoy.extensions.filters.http.api_key_auth.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file envoy/extensions/filters/http/api_key_auth/v3/api_key_auth.proto.
 */
export declare const file_envoy_extensions_filters_http_api_key_auth_v3_api_key_auth: GenFile;

/**
 * API Key HTTP authentication.
 *
 * For example, the following configuration configures the filter to authenticate the clients using
 * the API key from the header ``X-API-KEY``. And only the clients with the key ``real-key`` are
 * considered as authenticated. The client information is configured to be forwarded
 * in the header ``x-client-id``.
 *
 * .. code-block:: yaml
 *
 *    credentials:
 *    - key: real-key
 *      client: user
 *    key_sources:
 *     - header: "X-API-KEY"
 *    forwarding:
 *      header: "x-client-id"
 *      hide_credentials: false
 *
 *
 * @generated from message envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth
 */
export declare type ApiKeyAuth = Message<"envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth"> & {
  /**
   * The credentials that are used to authenticate the clients.
   *
   * @generated from field: repeated envoy.extensions.filters.http.api_key_auth.v3.Credential credentials = 1;
   */
  credentials: Credential[];

  /**
   * The key sources to fetch the key from the coming request.
   *
   * @generated from field: repeated envoy.extensions.filters.http.api_key_auth.v3.KeySource key_sources = 2;
   */
  keySources: KeySource[];

  /**
   * Optional configuration to control what information should be propagated to upstream services.
   *
   * @generated from field: envoy.extensions.filters.http.api_key_auth.v3.Forwarding forwarding = 3;
   */
  forwarding?: Forwarding;
};

/**
 * Describes the message envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuth.
 * Use `create(ApiKeyAuthSchema)` to create a new message.
 */
export declare const ApiKeyAuthSchema: GenMessage<ApiKeyAuth>;

/**
 * API key auth configuration of per route or per virtual host or per route configuration.
 *
 * @generated from message envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute
 */
export declare type ApiKeyAuthPerRoute = Message<"envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute"> & {
  /**
   * The credentials that are used to authenticate the clients. If this field is non-empty, then the
   * credentials in the filter level configuration will be ignored and the credentials in this
   * configuration will be used.
   *
   * @generated from field: repeated envoy.extensions.filters.http.api_key_auth.v3.Credential credentials = 1;
   */
  credentials: Credential[];

  /**
   * The key sources to fetch the key from the coming request. If this field is non-empty, then the
   * key sources in the filter level configuration will be ignored and the key sources in this
   * configuration will be used.
   *
   * @generated from field: repeated envoy.extensions.filters.http.api_key_auth.v3.KeySource key_sources = 2;
   */
  keySources: KeySource[];

  /**
   * A list of clients that are allowed to access the route or vhost. The clients listed here
   * should be subset of the clients listed in the ``credentials`` to provide authorization control
   * after the authentication is successful. If the list is empty, then all authenticated clients
   * are allowed. This provides very limited but simple authorization. If more complex authorization
   * is required, then use the :ref:`HTTP RBAC filter <config_http_filters_rbac>` instead.
   *
   * .. note::
   *   Setting this field and ``credentials`` at the same configuration entry is not an error but
   *   also makes no much sense because they provide similar functionality. Please only use
   *   one of them at same configuration entry except for the case that you want to share the same
   *   credentials list across multiple routes but still use different allowed clients for each
   *   route.
   *
   *
   * @generated from field: repeated string allowed_clients = 3;
   */
  allowedClients: string[];

  /**
   * Optional configuration to control what information should be propagated to upstream services.
   * If this field is non-empty, then the forwarding information in the filter level configuration
   * will be ignored and the forwarding in this configuration will be used.
   *
   * @generated from field: envoy.extensions.filters.http.api_key_auth.v3.Forwarding forwarding = 4;
   */
  forwarding?: Forwarding;
};

/**
 * Describes the message envoy.extensions.filters.http.api_key_auth.v3.ApiKeyAuthPerRoute.
 * Use `create(ApiKeyAuthPerRouteSchema)` to create a new message.
 */
export declare const ApiKeyAuthPerRouteSchema: GenMessage<ApiKeyAuthPerRoute>;

/**
 * Single credential entry that contains the API key and the related client id.
 *
 * @generated from message envoy.extensions.filters.http.api_key_auth.v3.Credential
 */
export declare type Credential = Message<"envoy.extensions.filters.http.api_key_auth.v3.Credential"> & {
  /**
   * The value of the unique API key.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The unique id or identity that used to identify the client or consumer.
   *
   * @generated from field: string client = 2;
   */
  client: string;
};

/**
 * Describes the message envoy.extensions.filters.http.api_key_auth.v3.Credential.
 * Use `create(CredentialSchema)` to create a new message.
 */
export declare const CredentialSchema: GenMessage<Credential>;

/**
 * @generated from message envoy.extensions.filters.http.api_key_auth.v3.KeySource
 */
export declare type KeySource = Message<"envoy.extensions.filters.http.api_key_auth.v3.KeySource"> & {
  /**
   * The header name to fetch the key. If multiple header values are present, the first one will be
   * used. If the header value starts with 'Bearer ', this prefix will be stripped to get the
   * key value.
   *
   * If set, takes precedence over ``query`` and ``cookie``.
   *
   * @generated from field: string header = 1;
   */
  header: string;

  /**
   * The query parameter name to fetch the key. If multiple query values are present, the first one
   * will be used.
   *
   * The field will be used if ``header`` is not set. If set, takes precedence over ``cookie``.
   *
   * @generated from field: string query = 2;
   */
  query: string;

  /**
   * The cookie name to fetch the key.
   *
   * The field will be used if the ``header`` and ``query`` are not set.
   *
   * @generated from field: string cookie = 3;
   */
  cookie: string;
};

/**
 * Describes the message envoy.extensions.filters.http.api_key_auth.v3.KeySource.
 * Use `create(KeySourceSchema)` to create a new message.
 */
export declare const KeySourceSchema: GenMessage<KeySource>;

/**
 * @generated from message envoy.extensions.filters.http.api_key_auth.v3.Forwarding
 */
export declare type Forwarding = Message<"envoy.extensions.filters.http.api_key_auth.v3.Forwarding"> & {
  /**
   * The header name in which to store the client information. If this field is non-empty,
   * the client string associated with the matched credential will be injected into
   * the request before forwarding upstream.
   *
   * @generated from field: string header = 1;
   */
  header: string;

  /**
   * If true, remove the API key from the request before forwarding upstream.
   *
   * This applies to all configured key sources: ``header``, ``query``, and ``cookie``.
   *
   * @generated from field: bool hide_credentials = 2;
   */
  hideCredentials: boolean;
};

/**
 * Describes the message envoy.extensions.filters.http.api_key_auth.v3.Forwarding.
 * Use `create(ForwardingSchema)` to create a new message.
 */
export declare const ForwardingSchema: GenMessage<Forwarding>;

