// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/cluster/v3/cluster.proto (package envoy.config.cluster.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { JsonObject, Message } from "@bufbuild/protobuf";
import type { CollectionEntry } from "../../../../xds/core/v3/collection_entry_pb";
import type { Any, Duration } from "@bufbuild/protobuf/wkt";
import type { ClusterLoadAssignment } from "../../endpoint/v3/endpoint_pb";
import type { HealthCheck, HealthStatusSet } from "../../core/v3/health_check_pb";
import type { CircuitBreakers } from "./circuit_breaker_pb";
import type { Http1ProtocolOptions, Http2ProtocolOptions, HttpProtocolOptions, UpstreamHttpProtocolOptions } from "../../core/v3/protocol_pb";
import type { Address, BindConfig, TcpKeepalive } from "../../core/v3/address_pb";
import type { DnsResolutionConfig } from "../../core/v3/resolver_pb";
import type { TypedExtensionConfig } from "../../core/v3/extension_pb";
import type { OutlierDetection } from "./outlier_detection_pb";
import type { Metadata, RuntimeDouble, TransportSocket } from "../../core/v3/base_pb";
import type { Filter } from "./filter_pb";
import type { ConfigSource } from "../../core/v3/config_source_pb";
import type { Percent } from "../../../type/v3/percent_pb";
import type { MetadataKey } from "../../../type/metadata/v3/metadata_pb";

/**
 * Describes the file envoy/config/cluster/v3/cluster.proto.
 */
export declare const file_envoy_config_cluster_v3_cluster: GenFile;

/**
 * Cluster list collections. Entries are ``Cluster`` resources or references.
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.config.cluster.v3.ClusterCollection
 */
export declare type ClusterCollection = Message<"envoy.config.cluster.v3.ClusterCollection"> & {
  /**
   * @generated from field: xds.core.v3.CollectionEntry entries = 1;
   */
  entries?: CollectionEntry;
};

/**
 * Describes the message envoy.config.cluster.v3.ClusterCollection.
 * Use `create(ClusterCollectionSchema)` to create a new message.
 */
export declare const ClusterCollectionSchema: GenMessage<ClusterCollection>;

/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 59]
 *
 * @generated from message envoy.config.cluster.v3.Cluster
 */
export declare type Cluster = Message<"envoy.config.cluster.v3.Cluster"> & {
  /**
   * Configuration to use different transport sockets for different endpoints. The entry of
   * ``envoy.transport_socket_match`` in the :ref:`LbEndpoint.Metadata
   * <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>` is used to match against the
   * transport sockets as they appear in the list. If a match is not found, the search continues in
   * :ref:`LocalityLbEndpoints.Metadata
   * <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.metadata>`. The first :ref:`match
   * <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used. For example, with
   * the following match
   *
   * .. code-block:: yaml
   *
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   *
   * Connections to the endpoints whose metadata value under ``envoy.transport_socket_match``
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   *
   * If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   *
   * If an endpoint metadata's value under ``envoy.transport_socket_match`` does not match any
   * ``TransportSocketMatch``, the locality metadata is then checked for a match. Barring any
   * matches in the endpoint or locality metadata, the socket configuration fallbacks to use the
   * ``tls_context`` or ``transport_socket`` specified in this cluster.
   *
   * This field allows gradual and flexible transport socket configuration changes.
   *
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   *
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * ``TransportSocketMatch`` in this field. Other client Envoys receive CDS without
   * ``transport_socket_match`` set, and still send plain text traffic to the same cluster.
   *
   * This field can be used to specify custom transport socket configurations for health
   * checks by adding matching key/value pairs in a health check's
   * :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
   *
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   *
   * @generated from field: repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 43;
   */
  transportSocketMatches: Cluster_TransportSocketMatch[];

  /**
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
   * <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An optional alternative to the cluster name to be used for observability. This name is used
   * for emitting stats for the cluster and access logging the cluster name. This will appear as
   * additional information in configuration dumps of a cluster's current status as
   * :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
   * and as an additional tag "upstream_cluster.name" while tracing.
   *
   * .. note::
   *   Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be confused with
   *   :ref:`Router Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
   *
   * @generated from field: string alt_stat_name = 28;
   */
  altStatName: string;

  /**
   * @generated from oneof envoy.config.cluster.v3.Cluster.cluster_discovery_type
   */
  clusterDiscoveryType: {
    /**
     * The :ref:`service discovery type <arch_overview_service_discovery_types>`
     * to use for resolving the cluster.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.DiscoveryType type = 2;
     */
    value: Cluster_DiscoveryType;
    case: "type";
  } | {
    /**
     * The custom cluster type.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.CustomClusterType cluster_type = 38;
     */
    value: Cluster_CustomClusterType;
    case: "clusterType";
  } | { case: undefined; value?: undefined };

  /**
   * Configuration to use for EDS updates for the Cluster.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.EdsClusterConfig eds_cluster_config = 3;
   */
  edsClusterConfig?: Cluster_EdsClusterConfig;

  /**
   * The timeout for new network connections to hosts in the cluster.
   * If not set, a default value of 5s will be used.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 4;
   */
  connectTimeout?: Duration;

  /**
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   *
   * @generated from field: google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;
   */
  perConnectionBufferLimitBytes?: number;

  /**
   * The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
   * when picking a host in the cluster.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.LbPolicy lb_policy = 6;
   */
  lbPolicy: Cluster_LbPolicy;

  /**
   * Setting this is required for specifying members of
   * :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
   * This field supersedes the ``hosts`` field in the v2 API.
   *
   * .. attention::
   *
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
   *
   *
   * @generated from field: envoy.config.endpoint.v3.ClusterLoadAssignment load_assignment = 33;
   */
  loadAssignment?: ClusterLoadAssignment;

  /**
   * Optional :ref:`active health checking <arch_overview_health_checking>`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   *
   * @generated from field: repeated envoy.config.core.v3.HealthCheck health_checks = 8;
   */
  healthChecks: HealthCheck[];

  /**
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   *
   * .. attention::
   *   This field has been deprecated in favor of the :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
   *
   * @generated from field: google.protobuf.UInt32Value max_requests_per_connection = 9 [deprecated = true];
   * @deprecated
   */
  maxRequestsPerConnection?: number;

  /**
   * Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
   *
   * @generated from field: envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 10;
   */
  circuitBreakers?: CircuitBreakers;

  /**
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * This has been deprecated in favor of
   * :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * upstream_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @generated from field: envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46 [deprecated = true];
   * @deprecated
   */
  upstreamHttpProtocolOptions?: UpstreamHttpProtocolOptions;

  /**
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * This has been deprecated in favor of
   * :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
   * in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * common_http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @generated from field: envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 29 [deprecated = true];
   * @deprecated
   */
  commonHttpProtocolOptions?: HttpProtocolOptions;

  /**
   * Additional options when handling HTTP1 requests.
   * This has been deprecated in favor of http_protocol_options fields in the
   * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @generated from field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 13 [deprecated = true];
   * @deprecated
   */
  httpProtocolOptions?: Http1ProtocolOptions;

  /**
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, ``http2_protocol_options`` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * This has been deprecated in favor of http2_protocol_options fields in the
   * :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
   * message. http2_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   * See :ref:`upstream_http_protocol_options
   * <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
   * for example usage.
   *
   * @generated from field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 14 [deprecated = true];
   * @deprecated
   */
  http2ProtocolOptions?: Http2ProtocolOptions;

  /**
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * [#next-major-version: make this a list of typed extensions.]
   * [#extension-category: envoy.upstream_options]
   *
   * @generated from field: map<string, google.protobuf.Any> typed_extension_protocol_options = 36;
   */
  typedExtensionProtocolOptions: { [key: string]: Any };

  /**
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @generated from field: google.protobuf.Duration dns_refresh_rate = 16 [deprecated = true];
   * @deprecated
   */
  dnsRefreshRate?: Duration;

  /**
   * DNS jitter can be optionally specified if the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`.
   * DNS jitter causes the cluster to refresh DNS entries later by a random amount of time to avoid a
   * stampede of DNS requests. This value sets the upper bound (exclusive) for the random amount.
   * There will be no jitter if this value is omitted. For cluster types other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @generated from field: google.protobuf.Duration dns_jitter = 58 [deprecated = true];
   * @deprecated
   */
  dnsJitter?: Duration;

  /**
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
   * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
   * ignored.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 44 [deprecated = true];
   * @deprecated
   */
  dnsFailureRefreshRate?: Cluster_RefreshRate;

  /**
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   * This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @generated from field: bool respect_dns_ttl = 39 [deprecated = true];
   * @deprecated
   */
  respectDnsTtl: boolean;

  /**
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
   * For logical and strict dns cluster, this field is deprecated in favor of using the
   * :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
   * extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 17;
   */
  dnsLookupFamily: Cluster_DnsLookupFamily;

  /**
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
   * and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
   * this setting is ignored.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   *
   * @generated from field: repeated envoy.config.core.v3.Address dns_resolvers = 18 [deprecated = true];
   * @deprecated
   */
  dnsResolvers: Address[];

  /**
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   *
   * @generated from field: bool use_tcp_for_dns_lookups = 45 [deprecated = true];
   * @deprecated
   */
  useTcpForDnsLookups: boolean;

  /**
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
   *
   * @generated from field: envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 53 [deprecated = true];
   * @deprecated
   */
  dnsResolutionConfig?: DnsResolutionConfig;

  /**
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * Also note that this field is deprecated for logical dns and strict dns clusters and will be ignored when
   * :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
   * :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
   * [#extension-category: envoy.network.dns_resolver]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 55;
   */
  typedDnsResolverConfig?: TypedExtensionConfig;

  /**
   * Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
   * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
   * or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
   * or :ref:`Redis Cluster<arch_overview_redis>`.
   * If true, cluster readiness blocks on warm-up. If false, the cluster will complete
   * initialization whether or not warm-up has completed. Defaults to true.
   *
   * @generated from field: google.protobuf.BoolValue wait_for_warm_on_init = 54;
   */
  waitForWarmOnInit?: boolean;

  /**
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
   *
   * @generated from field: envoy.config.cluster.v3.OutlierDetection outlier_detection = 19;
   */
  outlierDetection?: OutlierDetection;

  /**
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
   * this setting is ignored.
   *
   * @generated from field: google.protobuf.Duration cleanup_interval = 20;
   */
  cleanupInterval?: Duration;

  /**
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   *
   * @generated from field: envoy.config.core.v3.BindConfig upstream_bind_config = 21;
   */
  upstreamBindConfig?: BindConfig;

  /**
   * Configuration for load balancing subsetting.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.LbSubsetConfig lb_subset_config = 22;
   */
  lbSubsetConfig?: Cluster_LbSubsetConfig;

  /**
   * Optional configuration for the load balancing algorithm selected by
   * LbPolicy. Currently only
   * :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
   * :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
   * :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
   * has additional configuration options.
   * Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
   * LbPolicy will generate an error at runtime.
   *
   * @generated from oneof envoy.config.cluster.v3.Cluster.lb_config
   */
  lbConfig: {
    /**
     * Optional configuration for the Ring Hash load balancing policy.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.RingHashLbConfig ring_hash_lb_config = 23;
     */
    value: Cluster_RingHashLbConfig;
    case: "ringHashLbConfig";
  } | {
    /**
     * Optional configuration for the Maglev load balancing policy.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.MaglevLbConfig maglev_lb_config = 52;
     */
    value: Cluster_MaglevLbConfig;
    case: "maglevLbConfig";
  } | {
    /**
     * Optional configuration for the Original Destination load balancing policy.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;
     */
    value: Cluster_OriginalDstLbConfig;
    case: "originalDstLbConfig";
  } | {
    /**
     * Optional configuration for the LeastRequest load balancing policy.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig least_request_lb_config = 37;
     */
    value: Cluster_LeastRequestLbConfig;
    case: "leastRequestLbConfig";
  } | {
    /**
     * Optional configuration for the RoundRobin load balancing policy.
     *
     * @generated from field: envoy.config.cluster.v3.Cluster.RoundRobinLbConfig round_robin_lb_config = 56;
     */
    value: Cluster_RoundRobinLbConfig;
    case: "roundRobinLbConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Common configuration for all load balancer implementations.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.CommonLbConfig common_lb_config = 27;
   */
  commonLbConfig?: Cluster_CommonLbConfig;

  /**
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
   * :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the ``typed_config``.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   *
   * @generated from field: envoy.config.core.v3.TransportSocket transport_socket = 24;
   */
  transportSocket?: TransportSocket;

  /**
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as ``envoy.filters.http.router``.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata = 25;
   */
  metadata?: Metadata;

  /**
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * This has been deprecated in favor of setting explicit protocol selection
   * in the :ref:`http_protocol_options
   * <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
   * http_protocol_options can be set via the cluster's
   * :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.ClusterProtocolSelection protocol_selection = 26 [deprecated = true];
   * @deprecated
   */
  protocolSelection: Cluster_ClusterProtocolSelection;

  /**
   * Optional options for upstream connections.
   *
   * @generated from field: envoy.config.cluster.v3.UpstreamConnectionOptions upstream_connection_options = 30;
   */
  upstreamConnectionOptions?: UpstreamConnectionOptions;

  /**
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   *
   * .. note::
   *
   *   This is currently only supported for connections created by tcp_proxy.
   *
   * .. note::
   *
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   *
   * @generated from field: bool close_connections_on_host_health_failure = 31;
   */
  closeConnectionsOnHostHealthFailure: boolean;

  /**
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   *
   * @generated from field: bool ignore_health_on_host_removal = 32;
   */
  ignoreHealthOnHostRemoval: boolean;

  /**
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   *
   * @generated from field: repeated envoy.config.cluster.v3.Filter filters = 40;
   */
  filters: Filter[];

  /**
   * If this field is set and is supported by the client, it will supersede the value of
   * :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
   *
   * @generated from field: envoy.config.cluster.v3.LoadBalancingPolicy load_balancing_policy = 41;
   */
  loadBalancingPolicy?: LoadBalancingPolicy;

  /**
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   *
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   *
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   *
   * @generated from field: envoy.config.core.v3.ConfigSource lrs_server = 42;
   */
  lrsServer?: ConfigSource;

  /**
   * A list of metric names from :ref:`ORCA load reports <envoy_v3_api_msg_.xds.data.orca.v3.OrcaLoadReport>` to propagate to LRS.
   *
   * If not specified, then ORCA load reports will not be propagated to LRS.
   *
   * For map fields in the ORCA proto, the string will be of the form ``<map_field_name>.<map_key>``.
   * For example, the string ``named_metrics.foo`` will mean to look for the key ``foo`` in the ORCA
   * :ref:`named_metrics <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.named_metrics>` field.
   *
   * The special map key ``*`` means to report all entries in the map (e.g., ``named_metrics.*`` means to
   * report all entries in the ORCA named_metrics field). Note that this should be used only with trusted
   * backends.
   *
   * The metric names in LRS will follow the same semantics as this field. In other words, if this field
   * contains ``named_metrics.foo``, then the LRS load report will include the data with that same string
   * as the key.
   *
   * @generated from field: repeated string lrs_report_endpoint_metrics = 57;
   */
  lrsReportEndpointMetrics: string[];

  /**
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   *
   * .. attention::
   *
   *   This field has been deprecated in favor of ``timeout_budgets``, part of
   *   :ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
   *
   * @generated from field: bool track_timeout_budgets = 47 [deprecated = true];
   * @deprecated
   */
  trackTimeoutBudgets: boolean;

  /**
   * Optional customization and configuration of upstream connection pool, and upstream type.
   *
   * Currently this field only applies for HTTP traffic but is designed for eventual use for custom
   * TCP upstreams.
   *
   * For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
   * HTTP, using the http connection pool and the codec from ``http2_protocol_options``
   *
   * For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
   * requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
   *
   * The default pool used is the generic connection pool which creates the HTTP upstream for most
   * HTTP requests, and the TCP upstream if CONNECT termination is configured.
   *
   * If users desire custom connection pool or upstream behavior, for example terminating
   * CONNECT only if a custom filter indicates it is appropriate, the custom factories
   * can be registered and configured here.
   * [#extension-category: envoy.upstreams]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig upstream_config = 48;
   */
  upstreamConfig?: TypedExtensionConfig;

  /**
   * Configuration to track optional cluster stats.
   *
   * @generated from field: envoy.config.cluster.v3.TrackClusterStats track_cluster_stats = 49;
   */
  trackClusterStats?: TrackClusterStats;

  /**
   * Preconnect configuration for this cluster.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.PreconnectPolicy preconnect_policy = 50;
   */
  preconnectPolicy?: Cluster_PreconnectPolicy;

  /**
   * If ``connection_pool_per_downstream_connection`` is true, the cluster will use a separate
   * connection pool for every downstream connection
   *
   * @generated from field: bool connection_pool_per_downstream_connection = 51;
   */
  connectionPoolPerDownstreamConnection: boolean;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export declare const ClusterSchema: GenMessage<Cluster>;

/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.TransportSocketMatch
 */
export declare type Cluster_TransportSocketMatch = Message<"envoy.config.cluster.v3.Cluster.TransportSocketMatch"> & {
  /**
   * The name of the match, used in stats generation.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional metadata match criteria.
   * The connection to the endpoint with metadata matching what is set in this field
   * will use the transport socket configuration specified here.
   * The endpoint's metadata entry in ``envoy.transport_socket_match`` is used to match
   * against the values specified in this field.
   *
   * @generated from field: google.protobuf.Struct match = 2;
   */
  match?: JsonObject;

  /**
   * The configuration of the transport socket.
   * [#extension-category: envoy.transport_sockets.upstream]
   *
   * @generated from field: envoy.config.core.v3.TransportSocket transport_socket = 3;
   */
  transportSocket?: TransportSocket;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.TransportSocketMatch.
 * Use `create(Cluster_TransportSocketMatchSchema)` to create a new message.
 */
export declare const Cluster_TransportSocketMatchSchema: GenMessage<Cluster_TransportSocketMatch>;

/**
 * Extended cluster type.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CustomClusterType
 */
export declare type Cluster_CustomClusterType = Message<"envoy.config.cluster.v3.Cluster.CustomClusterType"> & {
  /**
   * The type of the cluster to instantiate. The name must match a supported cluster type.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Cluster specific configuration which depends on the cluster being instantiated.
   * See the supported cluster for further documentation.
   * [#extension-category: envoy.clusters]
   *
   * @generated from field: google.protobuf.Any typed_config = 2;
   */
  typedConfig?: Any;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.CustomClusterType.
 * Use `create(Cluster_CustomClusterTypeSchema)` to create a new message.
 */
export declare const Cluster_CustomClusterTypeSchema: GenMessage<Cluster_CustomClusterType>;

/**
 * Only valid when discovery type is EDS.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.EdsClusterConfig
 */
export declare type Cluster_EdsClusterConfig = Message<"envoy.config.cluster.v3.Cluster.EdsClusterConfig"> & {
  /**
   * Configuration for the source of EDS updates for this Cluster.
   *
   * @generated from field: envoy.config.core.v3.ConfigSource eds_config = 1;
   */
  edsConfig?: ConfigSource;

  /**
   * Optional alternative to cluster name to present to EDS. This does not
   * have the same restrictions as cluster name, i.e. it may be arbitrary
   * length. This may be a xdstp:// URL.
   *
   * @generated from field: string service_name = 2;
   */
  serviceName: string;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.EdsClusterConfig.
 * Use `create(Cluster_EdsClusterConfigSchema)` to create a new message.
 */
export declare const Cluster_EdsClusterConfigSchema: GenMessage<Cluster_EdsClusterConfig>;

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LbSubsetConfig
 */
export declare type Cluster_LbSubsetConfig = Message<"envoy.config.cluster.v3.Cluster.LbSubsetConfig"> & {
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata. The value defaults to
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1;
   */
  fallbackPolicy: Cluster_LbSubsetConfig_LbSubsetFallbackPolicy;

  /**
   * Specifies the default subset of endpoints used during fallback if
   * fallback_policy is
   * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
   * Each field in default_subset is
   * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
   * namespace. It is valid for no hosts to match, in which case the behavior
   * is the same as a fallback_policy of
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   *
   * @generated from field: google.protobuf.Struct default_subset = 2;
   */
  defaultSubset?: JsonObject;

  /**
   * For each entry, LbEndpoint.Metadata's
   * ``envoy.lb`` namespace is traversed and a subset is created for each unique
   * combination of key and value. For example:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "hardware_type" ] }
   *   ]}
   *
   * A subset is matched when the metadata from the selected route and
   * weighted cluster contains the same keys and values as the subset's
   * metadata. The same host may appear in multiple subsets.
   *
   * @generated from field: repeated envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;
   */
  subsetSelectors: Cluster_LbSubsetConfig_LbSubsetSelector[];

  /**
   * If true, routing to subsets will take into account the localities and locality weights of the
   * endpoints when making the routing decision.
   *
   * There are some potential pitfalls associated with enabling this feature, as the resulting
   * traffic split after applying both a subset match and locality weights might be undesirable.
   *
   * Consider for example a situation in which you have 50/50 split across two localities X/Y
   * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
   * host selected but Y having 100, then a lot more load is being dumped on the single host in X
   * than originally anticipated in the load balancing assignment delivered via EDS.
   *
   * @generated from field: bool locality_weight_aware = 4;
   */
  localityWeightAware: boolean;

  /**
   * When used with locality_weight_aware, scales the weight of each locality by the ratio
   * of hosts in the subset vs hosts in the original subset. This aims to even out the load
   * going to an individual locality if said locality is disproportionately affected by the
   * subset predicate.
   *
   * @generated from field: bool scale_locality_weight = 5;
   */
  scaleLocalityWeight: boolean;

  /**
   * If true, when a fallback policy is configured and its corresponding subset fails to find
   * a host this will cause any host to be selected instead.
   *
   * This is useful when using the default subset as the fallback policy, given the default
   * subset might become empty. With this option enabled, if that happens the LB will attempt
   * to select a host from the entire cluster.
   *
   * @generated from field: bool panic_mode_any = 6;
   */
  panicModeAny: boolean;

  /**
   * If true, metadata specified for a metadata key will be matched against the corresponding
   * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
   * and any of the elements in the list matches the criteria.
   *
   * @generated from field: bool list_as_any = 7;
   */
  listAsAny: boolean;

  /**
   * Fallback mechanism that allows to try different route metadata until a host is found.
   * If load balancing process, including all its mechanisms (like
   * :ref:`fallback_policy<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy>`)
   * fails to select a host, this policy decides if and how the process is repeated using another metadata.
   *
   * The value defaults to
   * :ref:`METADATA_NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8;
   */
  metadataFallbackPolicy: Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.LbSubsetConfig.
 * Use `create(Cluster_LbSubsetConfigSchema)` to create a new message.
 */
export declare const Cluster_LbSubsetConfigSchema: GenMessage<Cluster_LbSubsetConfig>;

/**
 * Specifications for subsets.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
 */
export declare type Cluster_LbSubsetConfig_LbSubsetSelector = Message<"envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector"> & {
  /**
   * List of keys to match with the weighted cluster metadata.
   *
   * @generated from field: repeated string keys = 1;
   */
  keys: string[];

  /**
   * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
   * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
   *
   * If a match is found to a host, that host will be used regardless of priority levels.
   *
   * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
   * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
   * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
   * present in the current configuration.
   *
   * @generated from field: bool single_host_per_subset = 4;
   */
  singleHostPerSubset: boolean;

  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2;
   */
  fallbackPolicy: Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;

  /**
   * Subset of
   * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
   * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
   * fallback policy.
   * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
   * For any other fallback policy the parameter is not used and should not be set.
   * Only values also present in
   * :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
   * ``fallback_keys_subset`` cannot be equal to ``keys``.
   *
   * @generated from field: repeated string fallback_keys_subset = 3;
   */
  fallbackKeysSubset: string[];
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.
 * Use `create(Cluster_LbSubsetConfig_LbSubsetSelectorSchema)` to create a new message.
 */
export declare const Cluster_LbSubsetConfig_LbSubsetSelectorSchema: GenMessage<Cluster_LbSubsetConfig_LbSubsetSelector>;

/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  /**
   * If NOT_DEFINED top level config fallback policy is used instead.
   *
   * @generated from enum value: NOT_DEFINED = 0;
   */
  NOT_DEFINED = 0,

  /**
   * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
   *
   * @generated from enum value: NO_FALLBACK = 1;
   */
  NO_FALLBACK = 1,

  /**
   * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
   * (subject to policy, health checks, etc).
   *
   * @generated from enum value: ANY_ENDPOINT = 2;
   */
  ANY_ENDPOINT = 2,

  /**
   * If DEFAULT_SUBSET is selected, load balancing is performed over the
   * endpoints matching the values from the default_subset field.
   *
   * @generated from enum value: DEFAULT_SUBSET = 3;
   */
  DEFAULT_SUBSET = 3,

  /**
   * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
   * keys reduced to
   * :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
   * It allows for a fallback to a different, less specific selector if some of the keys of
   * the selector are considered optional.
   *
   * @generated from enum value: KEYS_SUBSET = 4;
   */
  KEYS_SUBSET = 4,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.
 */
export declare const Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicySchema: GenEnum<Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy>;

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
  /**
   * @generated from enum value: NO_FALLBACK = 0;
   */
  NO_FALLBACK = 0,

  /**
   * @generated from enum value: ANY_ENDPOINT = 1;
   */
  ANY_ENDPOINT = 1,

  /**
   * @generated from enum value: DEFAULT_SUBSET = 2;
   */
  DEFAULT_SUBSET = 2,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.
 */
export declare const Cluster_LbSubsetConfig_LbSubsetFallbackPolicySchema: GenEnum<Cluster_LbSubsetConfig_LbSubsetFallbackPolicy>;

/**
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy
 */
export enum Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
  /**
   * No fallback. Route metadata will be used as-is.
   *
   * @generated from enum value: METADATA_NO_FALLBACK = 0;
   */
  METADATA_NO_FALLBACK = 0,

  /**
   * A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
   * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
   * be merged with route metadata, overriding keys that appear in both places.
   * ``fallback_list`` entries will be used in order until a host is found.
   *
   * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
   *
   * Example:
   *
   * for metadata:
   *
   * .. code-block:: yaml
   *
   *   version: 1.0
   *   fallback_list:
   *     - version: 2.0
   *       hardware: c64
   *     - hardware: c32
   *     - version: 3.0
   *
   * at first, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "2.0", "hardware": "c64"}
   *
   * will be used for load balancing. If no host is found, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "1.0", "hardware": "c32"}
   *
   * is next to try. If it still results in no host, finally metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "3.0"}
   *
   * is used.
   *
   * @generated from enum value: FALLBACK_LIST = 1;
   */
  FALLBACK_LIST = 1,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.
 */
export declare const Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicySchema: GenEnum<Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy>;

/**
 * Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.SlowStartConfig
 */
export declare type Cluster_SlowStartConfig = Message<"envoy.config.cluster.v3.Cluster.SlowStartConfig"> & {
  /**
   * Represents the size of slow start window.
   * If set, the newly created host remains in slow start mode starting from its creation time
   * for the duration of slow start window.
   *
   * @generated from field: google.protobuf.Duration slow_start_window = 1;
   */
  slowStartWindow?: Duration;

  /**
   * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
   * so that endpoint would get linearly increasing amount of traffic.
   * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
   * The value of aggression parameter should be greater than 0.0.
   * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
   *
   * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
   * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
   * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
   *
   * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
   * Once host exits slow start, time_factor and aggression no longer affect its weight.
   *
   * @generated from field: envoy.config.core.v3.RuntimeDouble aggression = 2;
   */
  aggression?: RuntimeDouble;

  /**
   * Configures the minimum percentage of origin weight that avoids too small new weight,
   * which may cause endpoints in slow start mode receive no traffic in slow start window.
   * If not specified, the default is 10%.
   *
   * @generated from field: envoy.type.v3.Percent min_weight_percent = 3;
   */
  minWeightPercent?: Percent;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.SlowStartConfig.
 * Use `create(Cluster_SlowStartConfigSchema)` to create a new message.
 */
export declare const Cluster_SlowStartConfigSchema: GenMessage<Cluster_SlowStartConfig>;

/**
 * Specific configuration for the RoundRobin load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
 */
export declare type Cluster_RoundRobinLbConfig = Message<"envoy.config.cluster.v3.Cluster.RoundRobinLbConfig"> & {
  /**
   * Configuration for slow start mode.
   * If this configuration is not set, slow start will not be not enabled.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 1;
   */
  slowStartConfig?: Cluster_SlowStartConfig;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.RoundRobinLbConfig.
 * Use `create(Cluster_RoundRobinLbConfigSchema)` to create a new message.
 */
export declare const Cluster_RoundRobinLbConfigSchema: GenMessage<Cluster_RoundRobinLbConfig>;

/**
 * Specific configuration for the LeastRequest load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
 */
export declare type Cluster_LeastRequestLbConfig = Message<"envoy.config.cluster.v3.Cluster.LeastRequestLbConfig"> & {
  /**
   * The number of random healthy hosts from which the host with the fewest active requests will
   * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
   *
   * @generated from field: google.protobuf.UInt32Value choice_count = 1;
   */
  choiceCount?: number;

  /**
   * The following formula is used to calculate the dynamic weights when hosts have different load
   * balancing weights:
   *
   * ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias``
   *
   * The larger the active request bias is, the more aggressively active requests will lower the
   * effective weight when all host weights are not equal.
   *
   * ``active_request_bias`` must be greater than or equal to 0.0.
   *
   * When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number
   * of active requests at the time it picks a host and behaves like the Round Robin Load
   * Balancer.
   *
   * When ``active_request_bias > 0.0`` the Least Request Load Balancer scales the load balancing
   * weight by the number of active requests at the time it does a pick.
   *
   * The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
   * host sets changes, e.g., whenever there is a host membership update or a host load balancing
   * weight change.
   *
   * .. note::
   *   This setting only takes effect if all host weights are not equal.
   *
   * @generated from field: envoy.config.core.v3.RuntimeDouble active_request_bias = 2;
   */
  activeRequestBias?: RuntimeDouble;

  /**
   * Configuration for slow start mode.
   * If this configuration is not set, slow start will not be not enabled.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.SlowStartConfig slow_start_config = 3;
   */
  slowStartConfig?: Cluster_SlowStartConfig;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.
 * Use `create(Cluster_LeastRequestLbConfigSchema)` to create a new message.
 */
export declare const Cluster_LeastRequestLbConfigSchema: GenMessage<Cluster_LeastRequestLbConfig>;

/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.RingHashLbConfig
 */
export declare type Cluster_RingHashLbConfig = Message<"envoy.config.cluster.v3.Cluster.RingHashLbConfig"> & {
  /**
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
   *
   * @generated from field: google.protobuf.UInt64Value minimum_ring_size = 1;
   */
  minimumRingSize?: bigint;

  /**
   * The hash function used to hash hosts onto the ketama ring. The value defaults to
   * :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction hash_function = 3;
   */
  hashFunction: Cluster_RingHashLbConfig_HashFunction;

  /**
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
   *
   * @generated from field: google.protobuf.UInt64Value maximum_ring_size = 4;
   */
  maximumRingSize?: bigint;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.RingHashLbConfig.
 * Use `create(Cluster_RingHashLbConfigSchema)` to create a new message.
 */
export declare const Cluster_RingHashLbConfigSchema: GenMessage<Cluster_RingHashLbConfig>;

/**
 * The hash function used to hash hosts onto the ketama ring.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
 */
export enum Cluster_RingHashLbConfig_HashFunction {
  /**
   * Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
   *
   * @generated from enum value: XX_HASH = 0;
   */
  XX_HASH = 0,

  /**
   * Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
   * std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
   * on Linux and not macOS.
   *
   * @generated from enum value: MURMUR_HASH_2 = 1;
   */
  MURMUR_HASH_2 = 1,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.
 */
export declare const Cluster_RingHashLbConfig_HashFunctionSchema: GenEnum<Cluster_RingHashLbConfig_HashFunction>;

/**
 * Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
 * load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.MaglevLbConfig
 */
export declare type Cluster_MaglevLbConfig = Message<"envoy.config.cluster.v3.Cluster.MaglevLbConfig"> & {
  /**
   * The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
   * Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
   * upstream as it was before. Increasing the table size reduces the amount of disruption.
   * The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
   *
   * @generated from field: google.protobuf.UInt64Value table_size = 1;
   */
  tableSize?: bigint;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.MaglevLbConfig.
 * Use `create(Cluster_MaglevLbConfigSchema)` to create a new message.
 */
export declare const Cluster_MaglevLbConfigSchema: GenMessage<Cluster_MaglevLbConfig>;

/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 * [#extension: envoy.clusters.original_dst]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
 */
export declare type Cluster_OriginalDstLbConfig = Message<"envoy.config.cluster.v3.Cluster.OriginalDstLbConfig"> & {
  /**
   * When true, a HTTP header can be used to override the original dst address. The default header is
   * :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`.
   *
   * .. attention::
   *
   *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
   *   route traffic to arbitrary hosts and/or ports, which may have serious security
   *   consequences.
   *
   * .. note::
   *
   *   If the header appears multiple times only the first value is used.
   *
   * @generated from field: bool use_http_header = 1;
   */
  useHttpHeader: boolean;

  /**
   * The http header to override destination address if :ref:`use_http_header <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
   * is set to true. If the value is empty, :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
   *
   * @generated from field: string http_header_name = 2;
   */
  httpHeaderName: string;

  /**
   * The port to override for the original dst address. This port
   * will take precedence over filter state and header override ports
   *
   * @generated from field: google.protobuf.UInt32Value upstream_port_override = 3;
   */
  upstreamPortOverride?: number;

  /**
   * The dynamic metadata key to override destination address.
   * First the request metadata is considered, then the connection one.
   *
   * @generated from field: envoy.type.metadata.v3.MetadataKey metadata_key = 4;
   */
  metadataKey?: MetadataKey;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.
 * Use `create(Cluster_OriginalDstLbConfigSchema)` to create a new message.
 */
export declare const Cluster_OriginalDstLbConfigSchema: GenMessage<Cluster_OriginalDstLbConfig>;

/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig
 */
export declare type Cluster_CommonLbConfig = Message<"envoy.config.cluster.v3.Cluster.CommonLbConfig"> & {
  /**
   * Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
   * If not specified, the default is 50%.
   * To disable panic mode, set to 0%.
   *
   * .. note::
   *   The specified percent will be truncated to the nearest 1%.
   *
   * @generated from field: envoy.type.v3.Percent healthy_panic_threshold = 1;
   */
  healthyPanicThreshold?: Percent;

  /**
   * @generated from oneof envoy.config.cluster.v3.Cluster.CommonLbConfig.locality_config_specifier
   */
  localityConfigSpecifier: {
    /**
     * @generated from field: envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;
     */
    value: Cluster_CommonLbConfig_ZoneAwareLbConfig;
    case: "zoneAwareLbConfig";
  } | {
    /**
     * @generated from field: envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;
     */
    value: Cluster_CommonLbConfig_LocalityWeightedLbConfig;
    case: "localityWeightedLbConfig";
  } | { case: undefined; value?: undefined };

  /**
   * If set, all health check/weight/metadata updates that happen within this duration will be
   * merged and delivered in one shot when the duration expires. The start of the duration is when
   * the first update happens. This is useful for big clusters, with potentially noisy deploys
   * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
   * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
   * cluster). Please always keep in mind that the use of sandbox technologies may change this
   * behavior.
   *
   * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
   * window to 0.
   *
   * .. note::
   *   Merging does not apply to cluster membership changes (e.g.: adds/removes); this is
   *   because merging those updates isn't currently safe. See
   *   https://github.com/envoyproxy/envoy/pull/3941.
   *
   * @generated from field: google.protobuf.Duration update_merge_window = 4;
   */
  updateMergeWindow?: Duration;

  /**
   * If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
   * when computing load balancing weights until they have been health checked for the first time.
   * This will have no effect unless active health checking is also configured.
   *
   * @generated from field: bool ignore_new_hosts_until_first_hc = 5;
   */
  ignoreNewHostsUntilFirstHc: boolean;

  /**
   * If set to ``true``, the cluster manager will drain all existing
   * connections to upstream hosts whenever hosts are added or removed from the cluster.
   *
   * @generated from field: bool close_connections_on_host_set_change = 6;
   */
  closeConnectionsOnHostSetChange: boolean;

  /**
   * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
   *
   * @generated from field: envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig consistent_hashing_lb_config = 7;
   */
  consistentHashingLbConfig?: Cluster_CommonLbConfig_ConsistentHashingLbConfig;

  /**
   * This controls what hosts are considered valid when using
   * :ref:`host overrides <arch_overview_load_balancing_override_host>`, which is used by some
   * filters to modify the load balancing decision.
   *
   * If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
   * set with an empty set of statuses then host overrides will be ignored by the load balancing.
   *
   * @generated from field: envoy.config.core.v3.HealthStatusSet override_host_status = 8;
   */
  overrideHostStatus?: HealthStatusSet;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.CommonLbConfig.
 * Use `create(Cluster_CommonLbConfigSchema)` to create a new message.
 */
export declare const Cluster_CommonLbConfigSchema: GenMessage<Cluster_CommonLbConfig>;

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
 */
export declare type Cluster_CommonLbConfig_ZoneAwareLbConfig = Message<"envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig"> & {
  /**
   * Configures percentage of requests that will be considered for zone aware routing
   * if zone aware routing is configured. If not specified, the default is 100%.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   *
   * @generated from field: envoy.type.v3.Percent routing_enabled = 1;
   */
  routingEnabled?: Percent;

  /**
   * Configures minimum upstream cluster size required for zone aware routing
   * If upstream cluster size is less than specified, zone aware routing is not performed
   * even if zone aware routing is configured. If not specified, the default is 6.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   *
   * @generated from field: google.protobuf.UInt64Value min_cluster_size = 2;
   */
  minClusterSize?: bigint;

  /**
   * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
   * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
   * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
   * failing service.
   *
   * @generated from field: bool fail_traffic_on_panic = 3;
   */
  failTrafficOnPanic: boolean;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.
 * Use `create(Cluster_CommonLbConfig_ZoneAwareLbConfigSchema)` to create a new message.
 */
export declare const Cluster_CommonLbConfig_ZoneAwareLbConfigSchema: GenMessage<Cluster_CommonLbConfig_ZoneAwareLbConfig>;

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
 */
export declare type Cluster_CommonLbConfig_LocalityWeightedLbConfig = Message<"envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig"> & {
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig.
 * Use `create(Cluster_CommonLbConfig_LocalityWeightedLbConfigSchema)` to create a new message.
 */
export declare const Cluster_CommonLbConfig_LocalityWeightedLbConfigSchema: GenMessage<Cluster_CommonLbConfig_LocalityWeightedLbConfig>;

/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
 */
export declare type Cluster_CommonLbConfig_ConsistentHashingLbConfig = Message<"envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig"> & {
  /**
   * If set to ``true``, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   *
   * @generated from field: bool use_hostname_for_hashing = 1;
   */
  useHostnameForHashing: boolean;

  /**
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   *
   * Applies to both Ring Hash and Maglev load balancers.
   *
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   *
   * If weights are specified on the hosts, they are respected.
   *
   * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
   * being probed, so use a higher value if you require better performance.
   *
   * @generated from field: google.protobuf.UInt32Value hash_balance_factor = 2;
   */
  hashBalanceFactor?: number;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.
 * Use `create(Cluster_CommonLbConfig_ConsistentHashingLbConfigSchema)` to create a new message.
 */
export declare const Cluster_CommonLbConfig_ConsistentHashingLbConfigSchema: GenMessage<Cluster_CommonLbConfig_ConsistentHashingLbConfig>;

/**
 * @generated from message envoy.config.cluster.v3.Cluster.RefreshRate
 */
export declare type Cluster_RefreshRate = Message<"envoy.config.cluster.v3.Cluster.RefreshRate"> & {
  /**
   * Specifies the base interval between refreshes. This parameter is required and must be greater
   * than zero and less than
   * :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
   *
   * @generated from field: google.protobuf.Duration base_interval = 1;
   */
  baseInterval?: Duration;

  /**
   * Specifies the maximum interval between refreshes. This parameter is optional, but must be
   * greater than or equal to the
   * :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
   * is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
   *
   * @generated from field: google.protobuf.Duration max_interval = 2;
   */
  maxInterval?: Duration;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.RefreshRate.
 * Use `create(Cluster_RefreshRateSchema)` to create a new message.
 */
export declare const Cluster_RefreshRateSchema: GenMessage<Cluster_RefreshRate>;

/**
 * @generated from message envoy.config.cluster.v3.Cluster.PreconnectPolicy
 */
export declare type Cluster_PreconnectPolicy = Message<"envoy.config.cluster.v3.Cluster.PreconnectPolicy"> & {
  /**
   * Indicates how many streams (rounded up) can be anticipated per-upstream for each
   * incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
   * will only be done if the upstream is healthy and the cluster has traffic.
   *
   * For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
   * established, one for the new incoming stream, and one for a presumed follow-up stream. For
   * HTTP/2, only one connection would be established by default as one connection can
   * serve both the original and presumed follow-up stream.
   *
   * In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
   * active streams, there would be 100 connections in use, and 50 connections preconnected.
   * This might be a useful value for something like short lived single-use connections,
   * for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
   * termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
   * or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
   * reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
   * in case of unexpected disconnects where the connection could not be reused.
   *
   * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
   * as needed to serve streams in flight. This means in steady state if a connection is torn down,
   * a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
   *
   * This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
   * harm latency more than the preconnecting helps.
   *
   * @generated from field: google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1;
   */
  perUpstreamPreconnectRatio?: number;

  /**
   * Indicates how many streams (rounded up) can be anticipated across a cluster for each
   * stream, useful for low QPS services. This is currently supported for a subset of
   * deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
   * Unlike ``per_upstream_preconnect_ratio`` this preconnects across the upstream instances in a
   * cluster, doing best effort predictions of what upstream would be picked next and
   * pre-establishing a connection.
   *
   * Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
   * only be done if there are healthy upstreams and the cluster has traffic.
   *
   * For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
   * incoming stream, 2 connections will be preconnected - one to the first upstream for this
   * cluster, one to the second on the assumption there will be a follow-up stream.
   *
   * If this value is not set, or set explicitly to one, Envoy will fetch as many connections
   * as needed to serve streams in flight, so during warm up and in steady state if a connection
   * is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
   * connection establishment.
   *
   * If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
   * basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
   * upstream.
   *
   * @generated from field: google.protobuf.DoubleValue predictive_preconnect_ratio = 2;
   */
  predictivePreconnectRatio?: number;
};

/**
 * Describes the message envoy.config.cluster.v3.Cluster.PreconnectPolicy.
 * Use `create(Cluster_PreconnectPolicySchema)` to create a new message.
 */
export declare const Cluster_PreconnectPolicySchema: GenMessage<Cluster_PreconnectPolicy>;

/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.DiscoveryType
 */
export enum Cluster_DiscoveryType {
  /**
   * Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
   * for an explanation.
   *
   * @generated from enum value: STATIC = 0;
   */
  STATIC = 0,

  /**
   * Refer to the :ref:`strict DNS discovery
   * type<arch_overview_service_discovery_types_strict_dns>`
   * for an explanation.
   *
   * @generated from enum value: STRICT_DNS = 1;
   */
  STRICT_DNS = 1,

  /**
   * Refer to the :ref:`logical DNS discovery
   * type<arch_overview_service_discovery_types_logical_dns>`
   * for an explanation.
   *
   * @generated from enum value: LOGICAL_DNS = 2;
   */
  LOGICAL_DNS = 2,

  /**
   * Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
   * for an explanation.
   *
   * @generated from enum value: EDS = 3;
   */
  EDS = 3,

  /**
   * Refer to the :ref:`original destination discovery
   * type<arch_overview_service_discovery_types_original_destination>`
   * for an explanation.
   *
   * @generated from enum value: ORIGINAL_DST = 4;
   */
  ORIGINAL_DST = 4,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.DiscoveryType.
 */
export declare const Cluster_DiscoveryTypeSchema: GenEnum<Cluster_DiscoveryType>;

/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbPolicy
 */
export enum Cluster_LbPolicy {
  /**
   * Refer to the :ref:`round robin load balancing
   * policy<arch_overview_load_balancing_types_round_robin>`
   * for an explanation.
   *
   * @generated from enum value: ROUND_ROBIN = 0;
   */
  ROUND_ROBIN = 0,

  /**
   * Refer to the :ref:`least request load balancing
   * policy<arch_overview_load_balancing_types_least_request>`
   * for an explanation.
   *
   * @generated from enum value: LEAST_REQUEST = 1;
   */
  LEAST_REQUEST = 1,

  /**
   * Refer to the :ref:`ring hash load balancing
   * policy<arch_overview_load_balancing_types_ring_hash>`
   * for an explanation.
   *
   * @generated from enum value: RING_HASH = 2;
   */
  RING_HASH = 2,

  /**
   * Refer to the :ref:`random load balancing
   * policy<arch_overview_load_balancing_types_random>`
   * for an explanation.
   *
   * @generated from enum value: RANDOM = 3;
   */
  RANDOM = 3,

  /**
   * Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
   * for an explanation.
   *
   * @generated from enum value: MAGLEV = 5;
   */
  MAGLEV = 5,

  /**
   * This load balancer type must be specified if the configured cluster provides a cluster
   * specific load balancer. Consult the configured cluster's documentation for whether to set
   * this option or not.
   *
   * @generated from enum value: CLUSTER_PROVIDED = 6;
   */
  CLUSTER_PROVIDED = 6,

  /**
   * Use the new :ref:`load_balancing_policy
   * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
   * This has been deprecated in favor of using the :ref:`load_balancing_policy
   * <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
   * setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
   *
   * @generated from enum value: LOAD_BALANCING_POLICY_CONFIG = 7;
   */
  LOAD_BALANCING_POLICY_CONFIG = 7,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.LbPolicy.
 */
export declare const Cluster_LbPolicySchema: GenEnum<Cluster_LbPolicy>;

/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * This is semantically equivalent to a non-existent V6_PREFERRED option.
 * AUTO is a legacy name that is more opaque than
 * necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
 * If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
 * IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
 * target will only get v6 addresses if there were NO v4 addresses to return.
 * If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
 * and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
 * upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
 * for more information.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 * [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.DnsLookupFamily
 */
export enum Cluster_DnsLookupFamily {
  /**
   * @generated from enum value: AUTO = 0;
   */
  AUTO = 0,

  /**
   * @generated from enum value: V4_ONLY = 1;
   */
  V4_ONLY = 1,

  /**
   * @generated from enum value: V6_ONLY = 2;
   */
  V6_ONLY = 2,

  /**
   * @generated from enum value: V4_PREFERRED = 3;
   */
  V4_PREFERRED = 3,

  /**
   * @generated from enum value: ALL = 4;
   */
  ALL = 4,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.DnsLookupFamily.
 */
export declare const Cluster_DnsLookupFamilySchema: GenEnum<Cluster_DnsLookupFamily>;

/**
 * @generated from enum envoy.config.cluster.v3.Cluster.ClusterProtocolSelection
 */
export enum Cluster_ClusterProtocolSelection {
  /**
   * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
   * If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
   * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
   *
   * @generated from enum value: USE_CONFIGURED_PROTOCOL = 0;
   */
  USE_CONFIGURED_PROTOCOL = 0,

  /**
   * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
   *
   * @generated from enum value: USE_DOWNSTREAM_PROTOCOL = 1;
   */
  USE_DOWNSTREAM_PROTOCOL = 1,
}

/**
 * Describes the enum envoy.config.cluster.v3.Cluster.ClusterProtocolSelection.
 */
export declare const Cluster_ClusterProtocolSelectionSchema: GenEnum<Cluster_ClusterProtocolSelection>;

/**
 * Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 *
 * @generated from message envoy.config.cluster.v3.LoadBalancingPolicy
 */
export declare type LoadBalancingPolicy = Message<"envoy.config.cluster.v3.LoadBalancingPolicy"> & {
  /**
   * Each client will iterate over the list in order and stop at the first policy that it
   * supports. This provides a mechanism for starting to use new LB policies that are not yet
   * supported by all clients.
   *
   * @generated from field: repeated envoy.config.cluster.v3.LoadBalancingPolicy.Policy policies = 1;
   */
  policies: LoadBalancingPolicy_Policy[];
};

/**
 * Describes the message envoy.config.cluster.v3.LoadBalancingPolicy.
 * Use `create(LoadBalancingPolicySchema)` to create a new message.
 */
export declare const LoadBalancingPolicySchema: GenMessage<LoadBalancingPolicy>;

/**
 * @generated from message envoy.config.cluster.v3.LoadBalancingPolicy.Policy
 */
export declare type LoadBalancingPolicy_Policy = Message<"envoy.config.cluster.v3.LoadBalancingPolicy.Policy"> & {
  /**
   * [#extension-category: envoy.load_balancing_policies]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig typed_extension_config = 4;
   */
  typedExtensionConfig?: TypedExtensionConfig;
};

/**
 * Describes the message envoy.config.cluster.v3.LoadBalancingPolicy.Policy.
 * Use `create(LoadBalancingPolicy_PolicySchema)` to create a new message.
 */
export declare const LoadBalancingPolicy_PolicySchema: GenMessage<LoadBalancingPolicy_Policy>;

/**
 * @generated from message envoy.config.cluster.v3.UpstreamConnectionOptions
 */
export declare type UpstreamConnectionOptions = Message<"envoy.config.cluster.v3.UpstreamConnectionOptions"> & {
  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @generated from field: envoy.config.core.v3.TcpKeepalive tcp_keepalive = 1;
   */
  tcpKeepalive?: TcpKeepalive;

  /**
   * If enabled, associates the interface name of the local address with the upstream connection.
   * This can be used by extensions during processing of requests. The association mechanism is
   * implementation specific. Defaults to false due to performance concerns.
   *
   * @generated from field: bool set_local_interface_name_on_upstream_connections = 2;
   */
  setLocalInterfaceNameOnUpstreamConnections: boolean;

  /**
   * Configurations for happy eyeballs algorithm.
   * Add configs for first_address_family_version and first_address_family_count
   * when sorting destination ip addresses.
   *
   * @generated from field: envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig happy_eyeballs_config = 3;
   */
  happyEyeballsConfig?: UpstreamConnectionOptions_HappyEyeballsConfig;
};

/**
 * Describes the message envoy.config.cluster.v3.UpstreamConnectionOptions.
 * Use `create(UpstreamConnectionOptionsSchema)` to create a new message.
 */
export declare const UpstreamConnectionOptionsSchema: GenMessage<UpstreamConnectionOptions>;

/**
 * @generated from message envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig
 */
export declare type UpstreamConnectionOptions_HappyEyeballsConfig = Message<"envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig"> & {
  /**
   * Specify the IP address family to attempt connection first in happy
   * eyeballs algorithm according to RFC8305#section-4.
   *
   * @generated from field: envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersion first_address_family_version = 1;
   */
  firstAddressFamilyVersion: UpstreamConnectionOptions_FirstAddressFamilyVersion;

  /**
   * Specify the number of addresses of the first_address_family_version being
   * attempted for connection before the other address family.
   *
   * @generated from field: google.protobuf.UInt32Value first_address_family_count = 2;
   */
  firstAddressFamilyCount?: number;
};

/**
 * Describes the message envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig.
 * Use `create(UpstreamConnectionOptions_HappyEyeballsConfigSchema)` to create a new message.
 */
export declare const UpstreamConnectionOptions_HappyEyeballsConfigSchema: GenMessage<UpstreamConnectionOptions_HappyEyeballsConfig>;

/**
 * @generated from enum envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersion
 */
export enum UpstreamConnectionOptions_FirstAddressFamilyVersion {
  /**
   * respect the native ranking of destination ip addresses returned from dns
   * resolution
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: V4 = 1;
   */
  V4 = 1,

  /**
   * @generated from enum value: V6 = 2;
   */
  V6 = 2,
}

/**
 * Describes the enum envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersion.
 */
export declare const UpstreamConnectionOptions_FirstAddressFamilyVersionSchema: GenEnum<UpstreamConnectionOptions_FirstAddressFamilyVersion>;

/**
 * @generated from message envoy.config.cluster.v3.TrackClusterStats
 */
export declare type TrackClusterStats = Message<"envoy.config.cluster.v3.TrackClusterStats"> & {
  /**
   * If timeout_budgets is true, the :ref:`timeout budget histograms
   * <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   *
   * @generated from field: bool timeout_budgets = 1;
   */
  timeoutBudgets: boolean;

  /**
   * If request_response_sizes is true, then the :ref:`histograms
   * <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
   * of requests and responses will be published. Additionally, number of headers in the requests and responses will be tracked.
   *
   * @generated from field: bool request_response_sizes = 2;
   */
  requestResponseSizes: boolean;

  /**
   * If true, some stats will be emitted per-endpoint, similar to the stats in admin ``/clusters``
   * output.
   *
   * This does not currently output correct stats during a hot-restart.
   *
   * This is not currently implemented by all stat sinks.
   *
   * These stats do not honor filtering or tag extraction rules in :ref:`StatsConfig
   * <envoy_v3_api_msg_config.metrics.v3.StatsConfig>` (but fixed-value tags are supported). Admin
   * endpoint filtering is supported.
   *
   * This may not be used at the same time as
   * :ref:`load_stats_config <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.load_stats_config>`.
   *
   * @generated from field: bool per_endpoint_stats = 3;
   */
  perEndpointStats: boolean;
};

/**
 * Describes the message envoy.config.cluster.v3.TrackClusterStats.
 * Use `create(TrackClusterStatsSchema)` to create a new message.
 */
export declare const TrackClusterStatsSchema: GenMessage<TrackClusterStats>;

