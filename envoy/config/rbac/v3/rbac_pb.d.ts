// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/rbac/v3/rbac.proto (package envoy.config.rbac.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { TypedExtensionConfig } from "../../core/v3/extension_pb";
import type { Expr } from "../../../../google/api/expr/v1alpha1/syntax_pb";
import type { CheckedExpr } from "../../../../google/api/expr/v1alpha1/checked_pb";
import type { MetadataMatcher } from "../../../type/matcher/v3/metadata_pb";
import type { HeaderMatcher } from "../../route/v3/route_components_pb";
import type { PathMatcher } from "../../../type/matcher/v3/path_pb";
import type { CidrRange } from "../../core/v3/address_pb";
import type { Int32Range } from "../../../type/v3/range_pb";
import type { StringMatcher } from "../../../type/matcher/v3/string_pb";
import type { FilterStateMatcher } from "../../../type/matcher/v3/filter_state_pb";

/**
 * Describes the file envoy/config/rbac/v3/rbac.proto.
 */
export declare const file_envoy_config_rbac_v3_rbac: GenFile;

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
 * found. For instance, if the action is ALLOW and a matching policy is found the request should be
 * allowed.
 *
 * RBAC can also be used to make access logging decisions by communicating with access loggers
 * through dynamic metadata. When the action is LOG and at least one policy matches, the
 * ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
 * the request should be logged.
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header:
 *                     name: ":method"
 *                     string_match:
 *                       exact: "GET"
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 *
 *
 * @generated from message envoy.config.rbac.v3.RBAC
 */
export declare type RBAC = Message<"envoy.config.rbac.v3.RBAC"> & {
  /**
   * The action to take if a policy matches. Every action either allows or denies a request,
   * and can also carry out action-specific operations.
   *
   * Actions:
   *
   *  * ``ALLOW``: Allows the request if and only if there is a policy that matches
   *    the request.
   *  * ``DENY``: Allows the request if and only if there are no policies that
   *    match the request.
   *  * ``LOG``: Allows all requests. If at least one policy matches, the dynamic
   *    metadata key ``access_log_hint`` is set to the value ``true`` under the shared
   *    key namespace ``envoy.common``. If no policies match, it is set to ``false``.
   *    Other actions do not modify this key.
   *
   *
   * @generated from field: envoy.config.rbac.v3.RBAC.Action action = 1;
   */
  action: RBAC_Action;

  /**
   * Maps from policy name to policy. A match occurs when at least one policy matches the request.
   * The policies are evaluated in lexicographic order of the policy name.
   *
   * @generated from field: map<string, envoy.config.rbac.v3.Policy> policies = 2;
   */
  policies: { [key: string]: Policy };

  /**
   * Audit logging options that include the condition for audit logging to happen
   * and audit logger configurations.
   *
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.config.rbac.v3.RBAC.AuditLoggingOptions audit_logging_options = 3;
   */
  auditLoggingOptions?: RBAC_AuditLoggingOptions;
};

/**
 * Describes the message envoy.config.rbac.v3.RBAC.
 * Use `create(RBACSchema)` to create a new message.
 */
export declare const RBACSchema: GenMessage<RBAC>;

/**
 * @generated from message envoy.config.rbac.v3.RBAC.AuditLoggingOptions
 */
export declare type RBAC_AuditLoggingOptions = Message<"envoy.config.rbac.v3.RBAC.AuditLoggingOptions"> & {
  /**
   * Condition for the audit logging to happen.
   * If this condition is met, all the audit loggers configured here will be invoked.
   *
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition audit_condition = 1;
   */
  auditCondition: RBAC_AuditLoggingOptions_AuditCondition;

  /**
   * Configurations for RBAC-based authorization audit loggers.
   *
   * [#not-implemented-hide:]
   *
   * @generated from field: repeated envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig logger_configs = 2;
   */
  loggerConfigs: RBAC_AuditLoggingOptions_AuditLoggerConfig[];
};

/**
 * Describes the message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.
 * Use `create(RBAC_AuditLoggingOptionsSchema)` to create a new message.
 */
export declare const RBAC_AuditLoggingOptionsSchema: GenMessage<RBAC_AuditLoggingOptions>;

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig
 */
export declare type RBAC_AuditLoggingOptions_AuditLoggerConfig = Message<"envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig"> & {
  /**
   * Typed logger configuration.
   *
   * [#extension-category: envoy.rbac.audit_loggers]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig audit_logger = 1;
   */
  auditLogger?: TypedExtensionConfig;

  /**
   * If true, when the logger is not supported, the data plane will not NACK but simply ignore it.
   *
   * @generated from field: bool is_optional = 2;
   */
  isOptional: boolean;
};

/**
 * Describes the message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig.
 * Use `create(RBAC_AuditLoggingOptions_AuditLoggerConfigSchema)` to create a new message.
 */
export declare const RBAC_AuditLoggingOptions_AuditLoggerConfigSchema: GenMessage<RBAC_AuditLoggingOptions_AuditLoggerConfig>;

/**
 * Deny and allow here refer to RBAC decisions, not actions.
 *
 * @generated from enum envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition
 */
export enum RBAC_AuditLoggingOptions_AuditCondition {
  /**
   * Never audit.
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * Audit when RBAC denies the request.
   *
   * @generated from enum value: ON_DENY = 1;
   */
  ON_DENY = 1,

  /**
   * Audit when RBAC allows the request.
   *
   * @generated from enum value: ON_ALLOW = 2;
   */
  ON_ALLOW = 2,

  /**
   * Audit whether RBAC allows or denies the request.
   *
   * @generated from enum value: ON_DENY_AND_ALLOW = 3;
   */
  ON_DENY_AND_ALLOW = 3,
}

/**
 * Describes the enum envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition.
 */
export declare const RBAC_AuditLoggingOptions_AuditConditionSchema: GenEnum<RBAC_AuditLoggingOptions_AuditCondition>;

/**
 * Should we do safe-list or block-list style access control?
 *
 * @generated from enum envoy.config.rbac.v3.RBAC.Action
 */
export enum RBAC_Action {
  /**
   * The policies grant access to principals. The rest are denied. This is safe-list style
   * access control. This is the default type.
   *
   * @generated from enum value: ALLOW = 0;
   */
  ALLOW = 0,

  /**
   * The policies deny access to principals. The rest are allowed. This is block-list style
   * access control.
   *
   * @generated from enum value: DENY = 1;
   */
  DENY = 1,

  /**
   * The policies set the ``access_log_hint`` dynamic metadata key based on if requests match.
   * All requests are allowed.
   *
   * @generated from enum value: LOG = 2;
   */
  LOG = 2,
}

/**
 * Describes the enum envoy.config.rbac.v3.RBAC.Action.
 */
export declare const RBAC_ActionSchema: GenEnum<RBAC_Action>;

/**
 * Policy specifies a role and the principals that are assigned/denied the role.
 * A policy matches if and only if at least one of its permissions match the
 * action taking place AND at least one of its principals match the downstream
 * AND the condition is true if specified.
 *
 * @generated from message envoy.config.rbac.v3.Policy
 */
export declare type Policy = Message<"envoy.config.rbac.v3.Policy"> & {
  /**
   * Required. The set of permissions that define a role. Each permission is
   * matched with OR semantics. To match all actions for this policy, a single
   * Permission with the ``any`` field set to true should be used.
   *
   * @generated from field: repeated envoy.config.rbac.v3.Permission permissions = 1;
   */
  permissions: Permission[];

  /**
   * Required. The set of principals that are assigned/denied the role based on
   * “action”. Each principal is matched with OR semantics. To match all
   * downstreams for this policy, a single Principal with the ``any`` field set to
   * true should be used.
   *
   * @generated from field: repeated envoy.config.rbac.v3.Principal principals = 2;
   */
  principals: Principal[];

  /**
   * An optional symbolic expression specifying an access control
   * :ref:`condition <arch_overview_condition>`. The condition is combined
   * with the permissions and the principals as a clause with AND semantics.
   * Only be used when checked_condition is not used.
   *
   * @generated from field: google.api.expr.v1alpha1.Expr condition = 3;
   */
  condition?: Expr;

  /**
   * [#not-implemented-hide:]
   * An optional symbolic expression that has been successfully type checked.
   * Only be used when condition is not used.
   *
   * @generated from field: google.api.expr.v1alpha1.CheckedExpr checked_condition = 4;
   */
  checkedCondition?: CheckedExpr;
};

/**
 * Describes the message envoy.config.rbac.v3.Policy.
 * Use `create(PolicySchema)` to create a new message.
 */
export declare const PolicySchema: GenMessage<Policy>;

/**
 * SourcedMetadata enables matching against metadata from different sources in the request processing
 * pipeline. It extends the base MetadataMatcher functionality by allowing specification of where the
 * metadata should be sourced from, rather than only matching against dynamic metadata.
 *
 * The matcher can be configured to look up metadata from:
 *
 * * Dynamic metadata: Runtime metadata added by filters during request processing
 * * Route metadata: Static metadata configured on the route entry
 *
 *
 * @generated from message envoy.config.rbac.v3.SourcedMetadata
 */
export declare type SourcedMetadata = Message<"envoy.config.rbac.v3.SourcedMetadata"> & {
  /**
   * Metadata matcher configuration that defines what metadata to match against. This includes the filter name,
   * metadata key path, and expected value.
   *
   * @generated from field: envoy.type.matcher.v3.MetadataMatcher metadata_matcher = 1;
   */
  metadataMatcher?: MetadataMatcher;

  /**
   * Specifies which metadata source should be used for matching. If not set,
   * defaults to DYNAMIC (dynamic metadata). Set to ROUTE to match against
   * static metadata configured on the route entry.
   *
   * @generated from field: envoy.config.rbac.v3.MetadataSource metadata_source = 2;
   */
  metadataSource: MetadataSource;
};

/**
 * Describes the message envoy.config.rbac.v3.SourcedMetadata.
 * Use `create(SourcedMetadataSchema)` to create a new message.
 */
export declare const SourcedMetadataSchema: GenMessage<SourcedMetadata>;

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 15]
 *
 * @generated from message envoy.config.rbac.v3.Permission
 */
export declare type Permission = Message<"envoy.config.rbac.v3.Permission"> & {
  /**
   * @generated from oneof envoy.config.rbac.v3.Permission.rule
   */
  rule: {
    /**
     * A set of rules that all must match in order to define the action.
     *
     * @generated from field: envoy.config.rbac.v3.Permission.Set and_rules = 1;
     */
    value: Permission_Set;
    case: "andRules";
  } | {
    /**
     * A set of rules where at least one must match in order to define the action.
     *
     * @generated from field: envoy.config.rbac.v3.Permission.Set or_rules = 2;
     */
    value: Permission_Set;
    case: "orRules";
  } | {
    /**
     * When any is set, it matches any action.
     *
     * @generated from field: bool any = 3;
     */
    value: boolean;
    case: "any";
  } | {
    /**
     * A header (or pseudo-header such as ``:path`` or ``:method``) on the incoming HTTP request. Only available
     * for HTTP request.
     *
     * .. note::
     *
     *   The pseudo-header ``:path`` includes the query and fragment string. Use the ``url_path`` field if you
     *   want to match the URL path without the query and fragment string.
     *
     *
     * @generated from field: envoy.config.route.v3.HeaderMatcher header = 4;
     */
    value: HeaderMatcher;
    case: "header";
  } | {
    /**
     * A URL path on the incoming HTTP request. Only available for HTTP.
     *
     * @generated from field: envoy.type.matcher.v3.PathMatcher url_path = 10;
     */
    value: PathMatcher;
    case: "urlPath";
  } | {
    /**
     * A CIDR block that describes the destination IP.
     *
     * @generated from field: envoy.config.core.v3.CidrRange destination_ip = 5;
     */
    value: CidrRange;
    case: "destinationIp";
  } | {
    /**
     * A port number that describes the destination port connecting to.
     *
     * @generated from field: uint32 destination_port = 6;
     */
    value: number;
    case: "destinationPort";
  } | {
    /**
     * A port number range that describes a range of destination ports connecting to.
     *
     * @generated from field: envoy.type.v3.Int32Range destination_port_range = 11;
     */
    value: Int32Range;
    case: "destinationPortRange";
  } | {
    /**
     * Metadata that describes additional information about the action. This field is deprecated; please use
     * :ref:`sourced_metadata<envoy_v3_api_field_config.rbac.v3.Permission.sourced_metadata>` instead.
     *
     * @generated from field: envoy.type.matcher.v3.MetadataMatcher metadata = 7 [deprecated = true];
     * @deprecated
     */
    value: MetadataMatcher;
    case: "metadata";
  } | {
    /**
     * Negates matching the provided permission. For instance, if the value of
     * ``not_rule`` would match, this permission would not match. Conversely, if
     * the value of ``not_rule`` would not match, this permission would match.
     *
     * @generated from field: envoy.config.rbac.v3.Permission not_rule = 8;
     */
    value: Permission;
    case: "notRule";
  } | {
    /**
     * The request server from the client's connection request. This is typically TLS SNI.
     *
     * .. attention::
     *
     *   The behavior of this field may be affected by how Envoy is configured
     *   as explained below.
     *
     *   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
     *     filter is not added, and if a ``FilterChainMatch`` is not defined for
     *     the :ref:`server name
     *     <envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
     *     a TLS connection's requested SNI server name will be treated as if it
     *     wasn't present.
     *
     *   * A :ref:`listener filter <arch_overview_listener_filters>` may
     *     overwrite a connection's requested server name within Envoy.
     *
     * Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn how to setup SNI.
     *
     * @generated from field: envoy.type.matcher.v3.StringMatcher requested_server_name = 9;
     */
    value: StringMatcher;
    case: "requestedServerName";
  } | {
    /**
     * Extension for configuring custom matchers for RBAC.
     * [#extension-category: envoy.rbac.matchers]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig matcher = 12;
     */
    value: TypedExtensionConfig;
    case: "matcher";
  } | {
    /**
     * URI template path matching.
     * [#extension-category: envoy.path.match]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig uri_template = 13;
     */
    value: TypedExtensionConfig;
    case: "uriTemplate";
  } | {
    /**
     * Matches against metadata from either dynamic state or route configuration. Preferred over the
     * ``metadata`` field as it provides more flexibility in metadata source selection.
     *
     * @generated from field: envoy.config.rbac.v3.SourcedMetadata sourced_metadata = 14;
     */
    value: SourcedMetadata;
    case: "sourcedMetadata";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.rbac.v3.Permission.
 * Use `create(PermissionSchema)` to create a new message.
 */
export declare const PermissionSchema: GenMessage<Permission>;

/**
 * Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v3.Permission.Set
 */
export declare type Permission_Set = Message<"envoy.config.rbac.v3.Permission.Set"> & {
  /**
   * @generated from field: repeated envoy.config.rbac.v3.Permission rules = 1;
   */
  rules: Permission[];
};

/**
 * Describes the message envoy.config.rbac.v3.Permission.Set.
 * Use `create(Permission_SetSchema)` to create a new message.
 */
export declare const Permission_SetSchema: GenMessage<Permission_Set>;

/**
 * Principal defines an identity or a group of identities for a downstream
 * subject.
 * [#next-free-field: 15]
 *
 * @generated from message envoy.config.rbac.v3.Principal
 */
export declare type Principal = Message<"envoy.config.rbac.v3.Principal"> & {
  /**
   * @generated from oneof envoy.config.rbac.v3.Principal.identifier
   */
  identifier: {
    /**
     * A set of identifiers that all must match in order to define the downstream.
     *
     * @generated from field: envoy.config.rbac.v3.Principal.Set and_ids = 1;
     */
    value: Principal_Set;
    case: "andIds";
  } | {
    /**
     * A set of identifiers at least one must match in order to define the downstream.
     *
     * @generated from field: envoy.config.rbac.v3.Principal.Set or_ids = 2;
     */
    value: Principal_Set;
    case: "orIds";
  } | {
    /**
     * When any is set, it matches any downstream.
     *
     * @generated from field: bool any = 3;
     */
    value: boolean;
    case: "any";
  } | {
    /**
     * Authenticated attributes that identify the downstream.
     * It is recommended to NOT use this field, but instead use
     * :ref:`MTlsAuthenticated <envoy_v3_api_msg_extensions.rbac.principals.mtls_authenticated.v3.Config>`,
     * configured via :ref:`custom <envoy_v3_api_field_config.rbac.v3.Principal.custom>`,
     * which should be used for most use cases due to its improved security.
     *
     * @generated from field: envoy.config.rbac.v3.Principal.Authenticated authenticated = 4;
     */
    value: Principal_Authenticated;
    case: "authenticated";
  } | {
    /**
     * A CIDR block that describes the downstream IP.
     * This address will honor proxy protocol, but will not honor XFF.
     *
     * This field is deprecated; either use :ref:`remote_ip
     * <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` for the same
     * behavior, or use
     * :ref:`direct_remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`.
     *
     * @generated from field: envoy.config.core.v3.CidrRange source_ip = 5 [deprecated = true];
     * @deprecated
     */
    value: CidrRange;
    case: "sourceIp";
  } | {
    /**
     * A CIDR block that describes the downstream remote/origin address.
     *
     * .. note::
     *
     *   This is always the physical peer even if the
     *   :ref:`remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is inferred from the
     *   x-forwarder-for header, the proxy protocol, etc.
     *
     *
     * @generated from field: envoy.config.core.v3.CidrRange direct_remote_ip = 10;
     */
    value: CidrRange;
    case: "directRemoteIp";
  } | {
    /**
     * A CIDR block that describes the downstream remote/origin address.
     *
     * .. note::
     *
     *   This may not be the physical peer and could be different from the :ref:`direct_remote_ip
     *   <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the remote ip is inferred from
     *   the x-forwarder-for header, the proxy protocol, etc.
     *
     *
     * @generated from field: envoy.config.core.v3.CidrRange remote_ip = 11;
     */
    value: CidrRange;
    case: "remoteIp";
  } | {
    /**
     * A header (or pseudo-header such as ``:path`` or ``:method``) on the incoming HTTP request. Only available
     * for HTTP request.
     *
     * .. note::
     *
     *   The pseudo-header ``:path`` includes the query and fragment string. Use the ``url_path`` field if you
     *   want to match the URL path without the query and fragment string.
     *
     *
     * @generated from field: envoy.config.route.v3.HeaderMatcher header = 6;
     */
    value: HeaderMatcher;
    case: "header";
  } | {
    /**
     * A URL path on the incoming HTTP request. Only available for HTTP.
     *
     * @generated from field: envoy.type.matcher.v3.PathMatcher url_path = 9;
     */
    value: PathMatcher;
    case: "urlPath";
  } | {
    /**
     * Metadata that describes additional information about the principal. This field is deprecated; please use
     * :ref:`sourced_metadata<envoy_v3_api_field_config.rbac.v3.Principal.sourced_metadata>` instead.
     *
     * @generated from field: envoy.type.matcher.v3.MetadataMatcher metadata = 7 [deprecated = true];
     * @deprecated
     */
    value: MetadataMatcher;
    case: "metadata";
  } | {
    /**
     * Identifies the principal using a filter state object.
     *
     * @generated from field: envoy.type.matcher.v3.FilterStateMatcher filter_state = 12;
     */
    value: FilterStateMatcher;
    case: "filterState";
  } | {
    /**
     * Negates matching the provided principal. For instance, if the value of
     * ``not_id`` would match, this principal would not match. Conversely, if the
     * value of ``not_id`` would not match, this principal would match.
     *
     * @generated from field: envoy.config.rbac.v3.Principal not_id = 8;
     */
    value: Principal;
    case: "notId";
  } | {
    /**
     * Matches against metadata from either dynamic state or route configuration. Preferred over the
     * ``metadata`` field as it provides more flexibility in metadata source selection.
     *
     * @generated from field: envoy.config.rbac.v3.SourcedMetadata sourced_metadata = 13;
     */
    value: SourcedMetadata;
    case: "sourcedMetadata";
  } | {
    /**
     * Extension for configuring custom principals for RBAC.
     * [#extension-category: envoy.rbac.principals]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom = 14;
     */
    value: TypedExtensionConfig;
    case: "custom";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.rbac.v3.Principal.
 * Use `create(PrincipalSchema)` to create a new message.
 */
export declare const PrincipalSchema: GenMessage<Principal>;

/**
 * Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
 * Depending on the context, each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v3.Principal.Set
 */
export declare type Principal_Set = Message<"envoy.config.rbac.v3.Principal.Set"> & {
  /**
   * @generated from field: repeated envoy.config.rbac.v3.Principal ids = 1;
   */
  ids: Principal[];
};

/**
 * Describes the message envoy.config.rbac.v3.Principal.Set.
 * Use `create(Principal_SetSchema)` to create a new message.
 */
export declare const Principal_SetSchema: GenMessage<Principal_Set>;

/**
 * Authentication attributes for a downstream.
 * It is recommended to NOT use this type, but instead use
 * :ref:`MTlsAuthenticated <envoy_v3_api_msg_extensions.rbac.principals.mtls_authenticated.v3.Config>`,
 * configured via :ref:`custom <envoy_v3_api_field_config.rbac.v3.Principal.custom>`,
 * which should be used for most use cases due to its improved security.
 *
 * @generated from message envoy.config.rbac.v3.Principal.Authenticated
 */
export declare type Principal_Authenticated = Message<"envoy.config.rbac.v3.Principal.Authenticated"> & {
  /**
   * The name of the principal. If set, The URI SAN or DNS SAN in that order
   * is used from the certificate, otherwise the subject field is used. If
   * unset, it applies to any user that is allowed by the downstream TLS configuration.
   * If :ref:`require_client_certificate <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`
   * is false or :ref:`trust_chain_verification <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trust_chain_verification>`
   * is set to :ref:`ACCEPT_UNTRUSTED <envoy_v3_api_enum_value_extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification.ACCEPT_UNTRUSTED>`,
   * then no authentication is required.
   *
   * @generated from field: envoy.type.matcher.v3.StringMatcher principal_name = 2;
   */
  principalName?: StringMatcher;
};

/**
 * Describes the message envoy.config.rbac.v3.Principal.Authenticated.
 * Use `create(Principal_AuthenticatedSchema)` to create a new message.
 */
export declare const Principal_AuthenticatedSchema: GenMessage<Principal_Authenticated>;

/**
 * Action defines the result of allowance or denial when a request matches the matcher.
 *
 * @generated from message envoy.config.rbac.v3.Action
 */
export declare type Action = Message<"envoy.config.rbac.v3.Action"> & {
  /**
   * The name indicates the policy name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The action to take if the matcher matches. Every action either allows or denies a request,
   * and can also carry out action-specific operations.
   *
   * **Actions:**
   *
   *  * ``ALLOW``: If the request gets matched on ALLOW, it is permitted.
   *  * ``DENY``: If the request gets matched on DENY, it is not permitted.
   *  * ``LOG``: If the request gets matched on LOG, it is permitted. Besides, the
   *    dynamic metadata key ``access_log_hint`` under the shared key namespace
   *    ``envoy.common`` will be set to the value ``true``.
   *  * If the request cannot get matched, it will fallback to ``DENY``.
   *
   * **Log behavior:**
   *
   *  If the RBAC matcher contains at least one LOG action, the dynamic
   *  metadata key ``access_log_hint`` will be set based on if the request
   *  get matched on the LOG action.
   *
   *
   * @generated from field: envoy.config.rbac.v3.RBAC.Action action = 2;
   */
  action: RBAC_Action;
};

/**
 * Describes the message envoy.config.rbac.v3.Action.
 * Use `create(ActionSchema)` to create a new message.
 */
export declare const ActionSchema: GenMessage<Action>;

/**
 * @generated from enum envoy.config.rbac.v3.MetadataSource
 */
export enum MetadataSource {
  /**
   * Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
   *
   * @generated from enum value: DYNAMIC = 0;
   */
  DYNAMIC = 0,

  /**
   * Query :ref:`route metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
   *
   * @generated from enum value: ROUTE = 1;
   */
  ROUTE = 1,
}

/**
 * Describes the enum envoy.config.rbac.v3.MetadataSource.
 */
export declare const MetadataSourceSchema: GenEnum<MetadataSource>;

