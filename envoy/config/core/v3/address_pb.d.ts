// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/core/v3/address.proto (package envoy.config.core.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { SocketOption, SocketOptionsOverride } from "./socket_option_pb";
import type { TypedExtensionConfig } from "./extension_pb";

/**
 * Describes the file envoy/config/core/v3/address.proto.
 */
export declare const file_envoy_config_core_v3_address: GenFile;

/**
 * @generated from message envoy.config.core.v3.Pipe
 */
export declare type Pipe = Message<"envoy.config.core.v3.Pipe"> & {
  /**
   * Unix Domain Socket path. On Linux, paths starting with '@' will use the
   * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
   * Paths starting with '@' will result in an error in environments other than
   * Linux.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * The mode for the Pipe. Not applicable for abstract sockets.
   *
   * @generated from field: uint32 mode = 2;
   */
  mode: number;
};

/**
 * Describes the message envoy.config.core.v3.Pipe.
 * Use `create(PipeSchema)` to create a new message.
 */
export declare const PipeSchema: GenMessage<Pipe>;

/**
 * The address represents an envoy internal listener.
 * [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
 *
 * @generated from message envoy.config.core.v3.EnvoyInternalAddress
 */
export declare type EnvoyInternalAddress = Message<"envoy.config.core.v3.EnvoyInternalAddress"> & {
  /**
   * @generated from oneof envoy.config.core.v3.EnvoyInternalAddress.address_name_specifier
   */
  addressNameSpecifier: {
    /**
     * Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
     * internal listener.
     *
     * @generated from field: string server_listener_name = 1;
     */
    value: string;
    case: "serverListenerName";
  } | { case: undefined; value?: undefined };

  /**
   * Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
   * single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
   * example, may be set to the final destination IP for the target internal listener.
   *
   * @generated from field: string endpoint_id = 2;
   */
  endpointId: string;
};

/**
 * Describes the message envoy.config.core.v3.EnvoyInternalAddress.
 * Use `create(EnvoyInternalAddressSchema)` to create a new message.
 */
export declare const EnvoyInternalAddressSchema: GenMessage<EnvoyInternalAddress>;

/**
 * [#next-free-field: 8]
 *
 * @generated from message envoy.config.core.v3.SocketAddress
 */
export declare type SocketAddress = Message<"envoy.config.core.v3.SocketAddress"> & {
  /**
   * @generated from field: envoy.config.core.v3.SocketAddress.Protocol protocol = 1;
   */
  protocol: SocketAddress_Protocol;

  /**
   * The address for this socket. :ref:`Listeners <config_listeners>` will bind
   * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
   * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
   * It is possible to distinguish a Listener address via the prefix/suffix matching
   * in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
   * within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
   * controls the source address of outbound connections. For :ref:`clusters
   * <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
   * address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
   * (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
   * via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * @generated from oneof envoy.config.core.v3.SocketAddress.port_specifier
   */
  portSpecifier: {
    /**
     * @generated from field: uint32 port_value = 3;
     */
    value: number;
    case: "portValue";
  } | {
    /**
     * This is only valid if :ref:`resolver_name
     * <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
     * named resolver is capable of named port resolution.
     *
     * @generated from field: string named_port = 4;
     */
    value: string;
    case: "namedPort";
  } | { case: undefined; value?: undefined };

  /**
   * The name of the custom resolver. This must have been registered with Envoy. If
   * this is empty, a context dependent default applies. If the address is a concrete
   * IP address, no resolution will occur. If address is a hostname this
   * should be set for resolution other than DNS. Specifying a custom resolver with
   * ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
   *
   * @generated from field: string resolver_name = 5;
   */
  resolverName: string;

  /**
   * When binding to an IPv6 address above, this enables `IPv4 compatibility
   * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
   * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
   * IPv6 space as ``::FFFF:<IPv4-address>``.
   *
   * @generated from field: bool ipv4_compat = 6;
   */
  ipv4Compat: boolean;

  /**
   * Filepath that specifies the Linux network namespace this socket will be created in (see ``man 7
   * network_namespaces``). If this field is set, Envoy will create the socket in the specified
   * network namespace.
   *
   * .. note::
   *    Setting this parameter requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
   *
   * .. attention::
   *     Network namespaces are only configurable on Linux. Otherwise, this field has no effect.
   *
   * @generated from field: string network_namespace_filepath = 7;
   */
  networkNamespaceFilepath: string;
};

/**
 * Describes the message envoy.config.core.v3.SocketAddress.
 * Use `create(SocketAddressSchema)` to create a new message.
 */
export declare const SocketAddressSchema: GenMessage<SocketAddress>;

/**
 * @generated from enum envoy.config.core.v3.SocketAddress.Protocol
 */
export enum SocketAddress_Protocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: UDP = 1;
   */
  UDP = 1,
}

/**
 * Describes the enum envoy.config.core.v3.SocketAddress.Protocol.
 */
export declare const SocketAddress_ProtocolSchema: GenEnum<SocketAddress_Protocol>;

/**
 * @generated from message envoy.config.core.v3.TcpKeepalive
 */
export declare type TcpKeepalive = Message<"envoy.config.core.v3.TcpKeepalive"> & {
  /**
   * Maximum number of keepalive probes to send without response before deciding
   * the connection is dead. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 9.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_probes = 1;
   */
  keepaliveProbes?: number;

  /**
   * The number of seconds a connection needs to be idle before keep-alive probes
   * start being sent. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 7200s (i.e., 2 hours.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_time = 2;
   */
  keepaliveTime?: number;

  /**
   * The number of seconds between keep-alive probes. Default is to use the OS
   * level configuration (unless overridden, Linux defaults to 75s.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_interval = 3;
   */
  keepaliveInterval?: number;
};

/**
 * Describes the message envoy.config.core.v3.TcpKeepalive.
 * Use `create(TcpKeepaliveSchema)` to create a new message.
 */
export declare const TcpKeepaliveSchema: GenMessage<TcpKeepalive>;

/**
 * @generated from message envoy.config.core.v3.ExtraSourceAddress
 */
export declare type ExtraSourceAddress = Message<"envoy.config.core.v3.ExtraSourceAddress"> & {
  /**
   * The additional address to bind.
   *
   * @generated from field: envoy.config.core.v3.SocketAddress address = 1;
   */
  address?: SocketAddress;

  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. If specified, this will override the
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
   * in the BindConfig. If specified with no
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
   * or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
   * it means no socket option will apply.
   *
   * @generated from field: envoy.config.core.v3.SocketOptionsOverride socket_options = 2;
   */
  socketOptions?: SocketOptionsOverride;
};

/**
 * Describes the message envoy.config.core.v3.ExtraSourceAddress.
 * Use `create(ExtraSourceAddressSchema)` to create a new message.
 */
export declare const ExtraSourceAddressSchema: GenMessage<ExtraSourceAddress>;

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.core.v3.BindConfig
 */
export declare type BindConfig = Message<"envoy.config.core.v3.BindConfig"> & {
  /**
   * The address to bind to when creating a socket.
   *
   * @generated from field: envoy.config.core.v3.SocketAddress source_address = 1;
   */
  sourceAddress?: SocketAddress;

  /**
   * Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
   * flag is set to true, allows the :ref:`source_address
   * <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
   * that is not configured on the system running Envoy. When this flag is set
   * to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
   * flag is not set (default), the socket is not modified, i.e. the option is
   * neither enabled nor disabled.
   *
   * @generated from field: google.protobuf.BoolValue freebind = 2;
   */
  freebind?: boolean;

  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   *
   * @generated from field: repeated envoy.config.core.v3.SocketOption socket_options = 3;
   */
  socketOptions: SocketOption[];

  /**
   * Extra source addresses appended to the address specified in the ``source_address``
   * field. This enables to specify multiple source addresses.
   * The source address selection is determined by :ref:`local_address_selector
   * <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>`.
   *
   * @generated from field: repeated envoy.config.core.v3.ExtraSourceAddress extra_source_addresses = 5;
   */
  extraSourceAddresses: ExtraSourceAddress[];

  /**
   * Deprecated by
   * :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
   *
   * @generated from field: repeated envoy.config.core.v3.SocketAddress additional_source_addresses = 4 [deprecated = true];
   * @deprecated
   */
  additionalSourceAddresses: SocketAddress[];

  /**
   * Custom local address selector to override the default (i.e.
   * :ref:`DefaultLocalAddressSelector
   * <envoy_v3_api_msg_config.upstream.local_address_selector.v3.DefaultLocalAddressSelector>`).
   * [#extension-category: envoy.upstream.local_address_selector]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig local_address_selector = 6;
   */
  localAddressSelector?: TypedExtensionConfig;
};

/**
 * Describes the message envoy.config.core.v3.BindConfig.
 * Use `create(BindConfigSchema)` to create a new message.
 */
export declare const BindConfigSchema: GenMessage<BindConfig>;

/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 *
 * @generated from message envoy.config.core.v3.Address
 */
export declare type Address = Message<"envoy.config.core.v3.Address"> & {
  /**
   * @generated from oneof envoy.config.core.v3.Address.address
   */
  address: {
    /**
     * @generated from field: envoy.config.core.v3.SocketAddress socket_address = 1;
     */
    value: SocketAddress;
    case: "socketAddress";
  } | {
    /**
     * @generated from field: envoy.config.core.v3.Pipe pipe = 2;
     */
    value: Pipe;
    case: "pipe";
  } | {
    /**
     * Specifies a user-space address handled by :ref:`internal listeners
     * <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
     *
     * @generated from field: envoy.config.core.v3.EnvoyInternalAddress envoy_internal_address = 3;
     */
    value: EnvoyInternalAddress;
    case: "envoyInternalAddress";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.core.v3.Address.
 * Use `create(AddressSchema)` to create a new message.
 */
export declare const AddressSchema: GenMessage<Address>;

/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 *
 * @generated from message envoy.config.core.v3.CidrRange
 */
export declare type CidrRange = Message<"envoy.config.core.v3.CidrRange"> & {
  /**
   * IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
   *
   * @generated from field: string address_prefix = 1;
   */
  addressPrefix: string;

  /**
   * Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
   *
   * @generated from field: google.protobuf.UInt32Value prefix_len = 2;
   */
  prefixLen?: number;
};

/**
 * Describes the message envoy.config.core.v3.CidrRange.
 * Use `create(CidrRangeSchema)` to create a new message.
 */
export declare const CidrRangeSchema: GenMessage<CidrRange>;

