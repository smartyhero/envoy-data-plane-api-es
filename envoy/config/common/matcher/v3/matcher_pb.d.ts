// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/common/matcher/v3/matcher.proto (package envoy.config.common.matcher.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { TypedExtensionConfig } from "../../../core/v3/extension_pb";
import type { StringMatcher } from "../../../../type/matcher/v3/string_pb";
import type { HeaderMatcher } from "../../../route/v3/route_components_pb";

/**
 * Describes the file envoy/config/common/matcher/v3/matcher.proto.
 */
export declare const file_envoy_config_common_matcher_v3_matcher: GenFile;

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 *
 * .. note::
 *   Please use the syntactically equivalent :ref:`matching API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher
 */
export declare type Matcher = Message<"envoy.config.common.matcher.v3.Matcher"> & {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.matcher_type
   */
  matcherType: {
    /**
     * A linear list of matchers to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList matcher_list = 1;
     */
    value: Matcher_MatcherList;
    case: "matcherList";
  } | {
    /**
     * A match tree to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree matcher_tree = 2;
     */
    value: Matcher_MatcherTree;
    case: "matcherTree";
  } | { case: undefined; value?: undefined };

  /**
   * Optional ``OnMatch`` to use if the matcher failed.
   * If specified, the ``OnMatch`` is used, and the matcher is considered
   * to have matched.
   * If not specified, the matcher is considered not to have matched.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.OnMatch on_no_match = 3;
   */
  onNoMatch?: Matcher_OnMatch;
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.
 * Use `create(MatcherSchema)` to create a new message.
 */
export declare const MatcherSchema: GenMessage<Matcher>;

/**
 * What to do if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.OnMatch
 */
export declare type Matcher_OnMatch = Message<"envoy.config.common.matcher.v3.Matcher.OnMatch"> & {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.OnMatch.on_match
   */
  onMatch: {
    /**
     * Nested matcher to evaluate.
     * If the nested matcher does not match and does not specify
     * on_no_match, then this matcher is considered not to have
     * matched, even if a predicate at this level or above returned
     * true.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher matcher = 1;
     */
    value: Matcher;
    case: "matcher";
  } | {
    /**
     * Protocol-specific action to take.
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig action = 2;
     */
    value: TypedExtensionConfig;
    case: "action";
  } | { case: undefined; value?: undefined };

  /**
   * If true, the action will be taken but the caller will behave as if no
   * match was found. This applies both to actions directly encoded in the
   * action field and to actions returned from a nested matcher tree in the
   * matcher field. A subsequent matcher on_no_match action will be used
   * instead.
   *
   * This field is not supported in all contexts in which the matcher API is
   * used. If this field is set in a context in which it's not supported,
   * the resource will be rejected.
   *
   * @generated from field: bool keep_matching = 3;
   */
  keepMatching: boolean;
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.OnMatch.
 * Use `create(Matcher_OnMatchSchema)` to create a new message.
 */
export declare const Matcher_OnMatchSchema: GenMessage<Matcher_OnMatch>;

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList
 */
export declare type Matcher_MatcherList = Message<"envoy.config.common.matcher.v3.Matcher.MatcherList"> & {
  /**
   * A list of matchers. First match wins.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher matchers = 1;
   */
  matchers: Matcher_MatcherList_FieldMatcher[];
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherList.
 * Use `create(Matcher_MatcherListSchema)` to create a new message.
 */
export declare const Matcher_MatcherListSchema: GenMessage<Matcher_MatcherList>;

/**
 * Predicate to determine if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate
 */
export declare type Matcher_MatcherList_Predicate = Message<"envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate"> & {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.match_type
   */
  matchType: {
    /**
     * A single predicate to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate single_predicate = 1;
     */
    value: Matcher_MatcherList_Predicate_SinglePredicate;
    case: "singlePredicate";
  } | {
    /**
     * A list of predicates to be OR-ed together.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList or_matcher = 2;
     */
    value: Matcher_MatcherList_Predicate_PredicateList;
    case: "orMatcher";
  } | {
    /**
     * A list of predicates to be AND-ed together.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList and_matcher = 3;
     */
    value: Matcher_MatcherList_Predicate_PredicateList;
    case: "andMatcher";
  } | {
    /**
     * The inverse of a predicate
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate not_matcher = 4;
     */
    value: Matcher_MatcherList_Predicate;
    case: "notMatcher";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.
 * Use `create(Matcher_MatcherList_PredicateSchema)` to create a new message.
 */
export declare const Matcher_MatcherList_PredicateSchema: GenMessage<Matcher_MatcherList_Predicate>;

/**
 * Predicate for a single input field.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate
 */
export declare type Matcher_MatcherList_Predicate_SinglePredicate = Message<"envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate"> & {
  /**
   * Protocol-specific specification of input field to match on.
   * [#extension-category: envoy.matching.common_inputs]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig input = 1;
   */
  input?: TypedExtensionConfig;

  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate.matcher
   */
  matcher: {
    /**
     * Built-in string matcher.
     *
     * @generated from field: envoy.type.matcher.v3.StringMatcher value_match = 2;
     */
    value: StringMatcher;
    case: "valueMatch";
  } | {
    /**
     * Extension for custom matching logic.
     * [#extension-category: envoy.matching.input_matchers]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_match = 3;
     */
    value: TypedExtensionConfig;
    case: "customMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate.
 * Use `create(Matcher_MatcherList_Predicate_SinglePredicateSchema)` to create a new message.
 */
export declare const Matcher_MatcherList_Predicate_SinglePredicateSchema: GenMessage<Matcher_MatcherList_Predicate_SinglePredicate>;

/**
 * A list of two or more matchers. Used to allow using a list within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList
 */
export declare type Matcher_MatcherList_Predicate_PredicateList = Message<"envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList"> & {
  /**
   * @generated from field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
   */
  predicate: Matcher_MatcherList_Predicate[];
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList.
 * Use `create(Matcher_MatcherList_Predicate_PredicateListSchema)` to create a new message.
 */
export declare const Matcher_MatcherList_Predicate_PredicateListSchema: GenMessage<Matcher_MatcherList_Predicate_PredicateList>;

/**
 * An individual matcher.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher
 */
export declare type Matcher_MatcherList_FieldMatcher = Message<"envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher"> & {
  /**
   * Determines if the match succeeds.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
   */
  predicate?: Matcher_MatcherList_Predicate;

  /**
   * What to do if the match succeeds.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.OnMatch on_match = 2;
   */
  onMatch?: Matcher_OnMatch;
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher.
 * Use `create(Matcher_MatcherList_FieldMatcherSchema)` to create a new message.
 */
export declare const Matcher_MatcherList_FieldMatcherSchema: GenMessage<Matcher_MatcherList_FieldMatcher>;

/**
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree
 */
export declare type Matcher_MatcherTree = Message<"envoy.config.common.matcher.v3.Matcher.MatcherTree"> & {
  /**
   * Protocol-specific specification of input field to match on.
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig input = 1;
   */
  input?: TypedExtensionConfig;

  /**
   * Exact or prefix match maps in which to look up the input value.
   * If the lookup succeeds, the match is considered successful, and
   * the corresponding OnMatch is used.
   *
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherTree.tree_type
   */
  treeType: {
    /**
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap exact_match_map = 2;
     */
    value: Matcher_MatcherTree_MatchMap;
    case: "exactMatchMap";
  } | {
    /**
     * Longest matching prefix wins.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap prefix_match_map = 3;
     */
    value: Matcher_MatcherTree_MatchMap;
    case: "prefixMatchMap";
  } | {
    /**
     * Extension for custom matching logic.
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_match = 4;
     */
    value: TypedExtensionConfig;
    case: "customMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherTree.
 * Use `create(Matcher_MatcherTreeSchema)` to create a new message.
 */
export declare const Matcher_MatcherTreeSchema: GenMessage<Matcher_MatcherTree>;

/**
 * A map of configured matchers. Used to allow using a map within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap
 */
export declare type Matcher_MatcherTree_MatchMap = Message<"envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap"> & {
  /**
   * @generated from field: map<string, envoy.config.common.matcher.v3.Matcher.OnMatch> map = 1;
   */
  map: { [key: string]: Matcher_OnMatch };
};

/**
 * Describes the message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.
 * Use `create(Matcher_MatcherTree_MatchMapSchema)` to create a new message.
 */
export declare const Matcher_MatcherTree_MatchMapSchema: GenMessage<Matcher_MatcherTree_MatchMap>;

/**
 * Match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate
 */
export declare type MatchPredicate = Message<"envoy.config.common.matcher.v3.MatchPredicate"> & {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.MatchPredicate.rule
   */
  rule: {
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet or_match = 1;
     */
    value: MatchPredicate_MatchSet;
    case: "orMatch";
  } | {
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet and_match = 2;
     */
    value: MatchPredicate_MatchSet;
    case: "andMatch";
  } | {
    /**
     * A negation match. The match configuration will match if the negated match condition matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate not_match = 3;
     */
    value: MatchPredicate;
    case: "notMatch";
  } | {
    /**
     * The match configuration will always match.
     *
     * @generated from field: bool any_match = 4;
     */
    value: boolean;
    case: "anyMatch";
  } | {
    /**
     * HTTP request headers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_headers_match = 5;
     */
    value: HttpHeadersMatch;
    case: "httpRequestHeadersMatch";
  } | {
    /**
     * HTTP request trailers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_trailers_match = 6;
     */
    value: HttpHeadersMatch;
    case: "httpRequestTrailersMatch";
  } | {
    /**
     * HTTP response headers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_headers_match = 7;
     */
    value: HttpHeadersMatch;
    case: "httpResponseHeadersMatch";
  } | {
    /**
     * HTTP response trailers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_trailers_match = 8;
     */
    value: HttpHeadersMatch;
    case: "httpResponseTrailersMatch";
  } | {
    /**
     * HTTP request generic body match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_request_generic_body_match = 9;
     */
    value: HttpGenericBodyMatch;
    case: "httpRequestGenericBodyMatch";
  } | {
    /**
     * HTTP response generic body match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_response_generic_body_match = 10;
     */
    value: HttpGenericBodyMatch;
    case: "httpResponseGenericBodyMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.common.matcher.v3.MatchPredicate.
 * Use `create(MatchPredicateSchema)` to create a new message.
 */
export declare const MatchPredicateSchema: GenMessage<MatchPredicate>;

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate.MatchSet
 */
export declare type MatchPredicate_MatchSet = Message<"envoy.config.common.matcher.v3.MatchPredicate.MatchSet"> & {
  /**
   * The list of rules that make up the set.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.MatchPredicate rules = 1;
   */
  rules: MatchPredicate[];
};

/**
 * Describes the message envoy.config.common.matcher.v3.MatchPredicate.MatchSet.
 * Use `create(MatchPredicate_MatchSetSchema)` to create a new message.
 */
export declare const MatchPredicate_MatchSetSchema: GenMessage<MatchPredicate_MatchSet>;

/**
 * HTTP headers match configuration.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpHeadersMatch
 */
export declare type HttpHeadersMatch = Message<"envoy.config.common.matcher.v3.HttpHeadersMatch"> & {
  /**
   * HTTP headers to match.
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 1;
   */
  headers: HeaderMatcher[];
};

/**
 * Describes the message envoy.config.common.matcher.v3.HttpHeadersMatch.
 * Use `create(HttpHeadersMatchSchema)` to create a new message.
 */
export declare const HttpHeadersMatchSchema: GenMessage<HttpHeadersMatch>;

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially CPU-intensive. For each specified pattern, HTTP body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the HTTP body.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch
 */
export declare type HttpGenericBodyMatch = Message<"envoy.config.common.matcher.v3.HttpGenericBodyMatch"> & {
  /**
   * Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
   *
   * @generated from field: uint32 bytes_limit = 1;
   */
  bytesLimit: number;

  /**
   * List of patterns to match.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2;
   */
  patterns: HttpGenericBodyMatch_GenericTextMatch[];
};

/**
 * Describes the message envoy.config.common.matcher.v3.HttpGenericBodyMatch.
 * Use `create(HttpGenericBodyMatchSchema)` to create a new message.
 */
export declare const HttpGenericBodyMatchSchema: GenMessage<HttpGenericBodyMatch>;

/**
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export declare type HttpGenericBodyMatch_GenericTextMatch = Message<"envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch"> & {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch.rule
   */
  rule: {
    /**
     * Text string to be located in HTTP body.
     *
     * @generated from field: string string_match = 1;
     */
    value: string;
    case: "stringMatch";
  } | {
    /**
     * Sequence of bytes to be located in HTTP body.
     *
     * @generated from field: bytes binary_match = 2;
     */
    value: Uint8Array;
    case: "binaryMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch.
 * Use `create(HttpGenericBodyMatch_GenericTextMatchSchema)` to create a new message.
 */
export declare const HttpGenericBodyMatch_GenericTextMatchSchema: GenMessage<HttpGenericBodyMatch_GenericTextMatch>;

