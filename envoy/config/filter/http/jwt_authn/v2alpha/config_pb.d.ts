// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/filter/http/jwt_authn/v2alpha/config.proto (package envoy.config.filter.http.jwt_authn.v2alpha, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { DataSource } from "../../../../../api/v2/core/base_pb";
import type { HttpUri } from "../../../../../api/v2/core/http_uri_pb";
import type { Duration, Empty } from "@bufbuild/protobuf/wkt";
import type { RouteMatch } from "../../../../../api/v2/route/route_components_pb";

/**
 * Describes the file envoy/config/filter/http/jwt_authn/v2alpha/config.proto.
 */
export declare const file_envoy_config_filter_http_jwt_authn_v2alpha_config: GenFile;

/**
 * Please see following for JWT authentication flow:
 *
 * * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
 * * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
 * * `OpenID Connect <http://openid.net/connect>`_
 *
 * A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
 *
 * * issuer: the principal that issues the JWT. It has to match the one from the token.
 * * allowed audiences: the ones in the token have to be listed here.
 * * how to fetch public key JWKS to verify the token signature.
 * * how to extract the JWT in the request.
 * * how to pass successfully verified token payload.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *     issuer: https://example.com
 *     audiences:
 *     - bookstore_android.apps.googleusercontent.com
 *     - bookstore_web.apps.googleusercontent.com
 *     remote_jwks:
 *       http_uri:
 *         uri: https://example.com/.well-known/jwks.json
 *         cluster: example_jwks_cluster
 *       cache_duration:
 *         seconds: 300
 *
 * [#next-free-field: 10]
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider
 */
export declare type JwtProvider = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider"> & {
  /**
   * Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
   * the JWT, usually a URL or an email address.
   *
   * Example: https://securetoken.google.com
   * Example: 1234567-compute@developer.gserviceaccount.com
   *
   *
   * @generated from field: string issuer = 1;
   */
  issuer: string;

  /**
   * The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
   * allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
   * will not check audiences in the token.
   *
   * Example:
   *
   * .. code-block:: yaml
   *
   *     audiences:
   *     - bookstore_android.apps.googleusercontent.com
   *     - bookstore_web.apps.googleusercontent.com
   *
   *
   * @generated from field: repeated string audiences = 2;
   */
  audiences: string[];

  /**
   * `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
   * validate signature of a JWT. This field specifies where to fetch JWKS.
   *
   * @generated from oneof envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider.jwks_source_specifier
   */
  jwksSourceSpecifier: {
    /**
     * JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
     * URI and how the fetched JWKS should be cached.
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    remote_jwks:
     *      http_uri:
     *        uri: https://www.googleapis.com/oauth2/v1/certs
     *        cluster: jwt.www.googleapis.com|443
     *      cache_duration:
     *        seconds: 300
     *
     *
     * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks remote_jwks = 3;
     */
    value: RemoteJwks;
    case: "remoteJwks";
  } | {
    /**
     * JWKS is in local data source. It could be either in a local file or embedded in the
     * inline_string.
     *
     * Example: local file
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      filename: /etc/envoy/jwks/jwks1.txt
     *
     * Example: inline_string
     *
     * .. code-block:: yaml
     *
     *    local_jwks:
     *      inline_string: ACADADADADA
     *
     *
     * @generated from field: envoy.api.v2.core.DataSource local_jwks = 4;
     */
    value: DataSource;
    case: "localJwks";
  } | { case: undefined; value?: undefined };

  /**
   * If false, the JWT is removed in the request after a success verification. If true, the JWT is
   * not removed in the request. Default value is false.
   *
   * @generated from field: bool forward = 5;
   */
  forward: boolean;

  /**
   * Two fields below define where to extract the JWT from an HTTP request.
   *
   * If no explicit location is specified, the following default locations are tried in order:
   *
   * 1. The Authorization header using the `Bearer schema
   * <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
   *
   *    Authorization: Bearer <token>.
   *
   * 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
   *
   * Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
   * its provider specified or from the default locations.
   *
   * Specify the HTTP headers to extract the JWT. For examples, following config:
   *
   * .. code-block:: yaml
   *
   *   from_headers:
   *   - name: x-goog-iap-jwt-assertion
   *
   * can be used to extract token from header::
   *
   *   ``x-goog-iap-jwt-assertion: <JWT>``.
   *
   *
   * @generated from field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader from_headers = 6;
   */
  fromHeaders: JwtHeader[];

  /**
   * JWT is sent in a query parameter. `jwt_params` represents the query parameter names.
   *
   * For example, if config is:
   *
   * .. code-block:: yaml
   *
   *   from_params:
   *   - jwt_token
   *
   * The JWT format in query parameter is::
   *
   *    /path?jwt_token=<JWT>
   *
   *
   * @generated from field: repeated string from_params = 7;
   */
  fromParams: string[];

  /**
   * This field specifies the header name to forward a successfully verified JWT payload to the
   * backend. The forwarded data is::
   *
   *    base64url_encoded(jwt_payload_in_JSON)
   *
   * If it is not specified, the payload will not be forwarded.
   *
   * @generated from field: string forward_payload_header = 8;
   */
  forwardPayloadHeader: string;

  /**
   * If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
   * in the format as: *namespace* is the jwt_authn filter name as **envoy.filters.http.jwt_authn**
   * The value is the *protobuf::Struct*. The value of this field will be the key for its *fields*
   * and the value is the *protobuf::Struct* converted from JWT JSON payload.
   *
   * For example, if payload_in_metadata is *my_payload*:
   *
   * .. code-block:: yaml
   *
   *   envoy.filters.http.jwt_authn:
   *     my_payload:
   *       iss: https://example.com
   *       sub: test@example.com
   *       aud: https://example.com
   *       exp: 1501281058
   *
   *
   * @generated from field: string payload_in_metadata = 9;
   */
  payloadInMetadata: string;
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider.
 * Use `create(JwtProviderSchema)` to create a new message.
 */
export declare const JwtProviderSchema: GenMessage<JwtProvider>;

/**
 * This message specifies how to fetch JWKS from remote and how to cache it.
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks
 */
export declare type RemoteJwks = Message<"envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks"> & {
  /**
   * The HTTP URI to fetch the JWKS. For example:
   *
   * .. code-block:: yaml
   *
   *    http_uri:
   *      uri: https://www.googleapis.com/oauth2/v1/certs
   *      cluster: jwt.www.googleapis.com|443
   *
   *
   * @generated from field: envoy.api.v2.core.HttpUri http_uri = 1;
   */
  httpUri?: HttpUri;

  /**
   * Duration after which the cached JWKS should be expired. If not specified, default cache
   * duration is 5 minutes.
   *
   * @generated from field: google.protobuf.Duration cache_duration = 2;
   */
  cacheDuration?: Duration;
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks.
 * Use `create(RemoteJwksSchema)` to create a new message.
 */
export declare const RemoteJwksSchema: GenMessage<RemoteJwks>;

/**
 * This message specifies a header location to extract JWT.
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader
 */
export declare type JwtHeader = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader"> & {
  /**
   * The HTTP header name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The value prefix. The value format is "value_prefix<token>"
   * For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
   * end.
   *
   * @generated from field: string value_prefix = 2;
   */
  valuePrefix: string;
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader.
 * Use `create(JwtHeaderSchema)` to create a new message.
 */
export declare const JwtHeaderSchema: GenMessage<JwtHeader>;

/**
 * Specify a required provider with audiences.
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences
 */
export declare type ProviderWithAudiences = Message<"envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences"> & {
  /**
   * Specify a required provider name.
   *
   * @generated from field: string provider_name = 1;
   */
  providerName: string;

  /**
   * This field overrides the one specified in the JwtProvider.
   *
   * @generated from field: repeated string audiences = 2;
   */
  audiences: string[];
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences.
 * Use `create(ProviderWithAudiencesSchema)` to create a new message.
 */
export declare const ProviderWithAudiencesSchema: GenMessage<ProviderWithAudiences>;

/**
 * This message specifies a Jwt requirement. An empty message means JWT verification is not
 * required. Here are some config examples:
 *
 * .. code-block:: yaml
 *
 *  # Example 1: not required with an empty message
 *
 *  # Example 2: require A
 *  provider_name: provider-A
 *
 *  # Example 3: require A or B
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 4: require A and B
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 5: require A and (B or C)
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_any:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 6: require A or (B and C)
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_all:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
 *  missing token.)
 *  requires_any:
 *    requirements:
 *    - provider_name: provider-A
 *    - allow_missing: {}
 *
 *  # Example 8: A is optional and B is required.
 *  requires_all:
 *    requirements:
 *    - requires_any:
 *        requirements:
 *        - provider_name: provider-A
 *        - allow_missing: {}
 *    - provider_name: provider-B
 *
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement
 */
export declare type JwtRequirement = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement"> & {
  /**
   * @generated from oneof envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement.requires_type
   */
  requiresType: {
    /**
     * Specify a required provider name.
     *
     * @generated from field: string provider_name = 1;
     */
    value: string;
    case: "providerName";
  } | {
    /**
     * Specify a required provider with audiences.
     *
     * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences provider_and_audiences = 2;
     */
    value: ProviderWithAudiences;
    case: "providerAndAudiences";
  } | {
    /**
     * Specify list of JwtRequirement. Their results are OR-ed.
     * If any one of them passes, the result is passed.
     *
     * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList requires_any = 3;
     */
    value: JwtRequirementOrList;
    case: "requiresAny";
  } | {
    /**
     * Specify list of JwtRequirement. Their results are AND-ed.
     * All of them must pass, if one of them fails or missing, it fails.
     *
     * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList requires_all = 4;
     */
    value: JwtRequirementAndList;
    case: "requiresAll";
  } | {
    /**
     * The requirement is always satisfied even if JWT is missing or the JWT
     * verification fails. A typical usage is: this filter is used to only verify
     * JWTs and pass the verified JWT payloads to another filter, the other filter
     * will make decision. In this mode, all JWTs will be verified.
     *
     * @generated from field: google.protobuf.Empty allow_missing_or_failed = 5;
     */
    value: Empty;
    case: "allowMissingOrFailed";
  } | {
    /**
     * The requirement is satisfied if JWT is missing, but failed if JWT is
     * presented but invalid. Similar to allow_missing_or_failed, this is used
     * to only verify JWTs and pass the verified payload to another filter. The
     * different is this mode will reject requests with invalid tokens.
     *
     * @generated from field: google.protobuf.Empty allow_missing = 6;
     */
    value: Empty;
    case: "allowMissing";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement.
 * Use `create(JwtRequirementSchema)` to create a new message.
 */
export declare const JwtRequirementSchema: GenMessage<JwtRequirement>;

/**
 * This message specifies a list of RequiredProvider.
 * Their results are OR-ed; if any one of them passes, the result is passed
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList
 */
export declare type JwtRequirementOrList = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList"> & {
  /**
   * Specify a list of JwtRequirement.
   *
   * @generated from field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;
   */
  requirements: JwtRequirement[];
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList.
 * Use `create(JwtRequirementOrListSchema)` to create a new message.
 */
export declare const JwtRequirementOrListSchema: GenMessage<JwtRequirementOrList>;

/**
 * This message specifies a list of RequiredProvider.
 * Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList
 */
export declare type JwtRequirementAndList = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList"> & {
  /**
   * Specify a list of JwtRequirement.
   *
   * @generated from field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;
   */
  requirements: JwtRequirement[];
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList.
 * Use `create(JwtRequirementAndListSchema)` to create a new message.
 */
export declare const JwtRequirementAndListSchema: GenMessage<JwtRequirementAndList>;

/**
 * This message specifies a Jwt requirement for a specific Route condition.
 * Example 1:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /healthz
 *
 * In above example, "requires" field is empty for /healthz prefix match,
 * it means that requests matching the path prefix don't require JWT authentication.
 *
 * Example 2:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /
 *      requires: { provider_name: provider-A }
 *
 * In above example, all requests matched the path prefix require jwt authentication
 * from "provider-A".
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule
 */
export declare type RequirementRule = Message<"envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule"> & {
  /**
   * The route matching parameter. Only when the match is satisfied, the "requires" field will
   * apply.
   *
   * For example: following match will match all requests.
   *
   * .. code-block:: yaml
   *
   *    match:
   *      prefix: /
   *
   *
   * @generated from field: envoy.api.v2.route.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * Specify a Jwt Requirement. Please detail comment in message JwtRequirement.
   *
   * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requires = 2;
   */
  requires?: JwtRequirement;
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule.
 * Use `create(RequirementRuleSchema)` to create a new message.
 */
export declare const RequirementRuleSchema: GenMessage<RequirementRule>;

/**
 * This message specifies Jwt requirements based on stream_info.filterState.
 * This FilterState should use `Router::StringAccessor` object to set a string value.
 * Other HTTP filters can use it to specify Jwt requirements dynamically.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *    name: jwt_selector
 *    requires:
 *      issuer_1:
 *        provider_name: issuer1
 *      issuer_2:
 *        provider_name: issuer2
 *
 * If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
 * jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule
 */
export declare type FilterStateRule = Message<"envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule"> & {
  /**
   * The filter state name to retrieve the `Router::StringAccessor` object.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A map of string keys to requirements. The string key is the string value
   * in the FilterState with the name specified in the *name* field above.
   *
   * @generated from field: map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement> requires = 3;
   */
  requires: { [key: string]: JwtRequirement };
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.
 * Use `create(FilterStateRuleSchema)` to create a new message.
 */
export declare const FilterStateRuleSchema: GenMessage<FilterStateRule>;

/**
 * This is the Envoy HTTP filter config for JWT authentication.
 *
 * For example:
 *
 * .. code-block:: yaml
 *
 *   providers:
 *      provider1:
 *        issuer: issuer1
 *        audiences:
 *        - audience1
 *        - audience2
 *        remote_jwks:
 *          http_uri:
 *            uri: https://example.com/.well-known/jwks.json
 *            cluster: example_jwks_cluster
 *      provider2:
 *        issuer: issuer2
 *        local_jwks:
 *          inline_string: jwks_string
 *
 *   rules:
 *      # Not jwt verification is required for /health path
 *      - match:
 *          prefix: /health
 *
 *      # Jwt verification for provider1 is required for path prefixed with "prefix"
 *      - match:
 *          prefix: /prefix
 *        requires:
 *          provider_name: provider1
 *
 *      # Jwt verification for either provider1 or provider2 is required for all other requests.
 *      - match:
 *          prefix: /
 *        requires:
 *          requires_any:
 *            requirements:
 *              - provider_name: provider1
 *              - provider_name: provider2
 *
 *
 * @generated from message envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication
 */
export declare type JwtAuthentication = Message<"envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication"> & {
  /**
   * Map of provider names to JwtProviders.
   *
   * .. code-block:: yaml
   *
   *   providers:
   *     provider1:
   *        issuer: issuer1
   *        audiences:
   *        - audience1
   *        - audience2
   *        remote_jwks:
   *          http_uri:
   *            uri: https://example.com/.well-known/jwks.json
   *            cluster: example_jwks_cluster
   *      provider2:
   *        issuer: provider2
   *        local_jwks:
   *          inline_string: jwks_string
   *
   *
   * @generated from field: map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider> providers = 1;
   */
  providers: { [key: string]: JwtProvider };

  /**
   * Specifies requirements based on the route matches. The first matched requirement will be
   * applied. If there are overlapped match conditions, please put the most specific match first.
   *
   * Examples
   *
   * .. code-block:: yaml
   *
   *   rules:
   *     - match:
   *         prefix: /healthz
   *     - match:
   *         prefix: /baz
   *       requires:
   *         provider_name: provider1
   *     - match:
   *         prefix: /foo
   *       requires:
   *         requires_any:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   *     - match:
   *         prefix: /bar
   *       requires:
   *         requires_all:
   *           requirements:
   *             - provider_name: provider1
   *             - provider_name: provider2
   *
   *
   * @generated from field: repeated envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule rules = 2;
   */
  rules: RequirementRule[];

  /**
   * This message specifies Jwt requirements based on stream_info.filterState.
   * Other HTTP filters can use it to specify Jwt requirements dynamically.
   * The *rules* field above is checked first, if it could not find any matches,
   * check this one.
   *
   * @generated from field: envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule filter_state_rules = 3;
   */
  filterStateRules?: FilterStateRule;

  /**
   * When set to true, bypass the `CORS preflight request
   * <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
   * requirements specified in the rules.
   *
   * @generated from field: bool bypass_cors_preflight = 4;
   */
  bypassCorsPreflight: boolean;
};

/**
 * Describes the message envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.
 * Use `create(JwtAuthenticationSchema)` to create a new message.
 */
export declare const JwtAuthenticationSchema: GenMessage<JwtAuthentication>;

