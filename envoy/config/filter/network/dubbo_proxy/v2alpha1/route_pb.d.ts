// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/config/filter/network/dubbo_proxy/v2alpha1/route.proto (package envoy.config.filter.network.dubbo_proxy.v2alpha1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { HeaderMatcher, WeightedCluster } from "../../../../../api/v2/route/route_components_pb";
import type { StringMatcher } from "../../../../../type/matcher/string_pb";
import type { Int64Range } from "../../../../../type/range_pb";

/**
 * Describes the file envoy/config/filter/network/dubbo_proxy/v2alpha1/route.proto.
 */
export declare const file_envoy_config_filter_network_dubbo_proxy_v2alpha1_route: GenFile;

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration
 */
export declare type RouteConfiguration = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration"> & {
  /**
   * The name of the route configuration. Reserved for future use in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The interface name of the service.
   *
   * @generated from field: string interface = 2;
   */
  interface: string;

  /**
   * Which group does the interface belong to.
   *
   * @generated from field: string group = 3;
   */
  group: string;

  /**
   * The version number of the interface.
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * The list of routes that will be matched, in order, against incoming requests. The first route
   * that matches will be used.
   *
   * @generated from field: repeated envoy.config.filter.network.dubbo_proxy.v2alpha1.Route routes = 5;
   */
  routes: Route[];
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration.
 * Use `create(RouteConfigurationSchema)` to create a new message.
 */
export declare const RouteConfigurationSchema: GenMessage<RouteConfiguration>;

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.Route
 */
export declare type Route = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.Route"> & {
  /**
   * Route matching parameters.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * Route request to some upstream cluster.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction route = 2;
   */
  route?: RouteAction;
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.Route.
 * Use `create(RouteSchema)` to create a new message.
 */
export declare const RouteSchema: GenMessage<Route>;

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch
 */
export declare type RouteMatch = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch"> & {
  /**
   * Method level routing matching.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch method = 1;
   */
  method?: MethodMatch;

  /**
   * Specifies a set of headers that the route should match on. The router will check the requestâ€™s
   * headers against all the specified headers in the route config. A match will happen if all the
   * headers in the route are present in the request with the same values (or based on presence if
   * the value field is not in the config).
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher headers = 2;
   */
  headers: HeaderMatcher[];
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch.
 * Use `create(RouteMatchSchema)` to create a new message.
 */
export declare const RouteMatchSchema: GenMessage<RouteMatch>;

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction
 */
export declare type RouteAction = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction"> & {
  /**
   * @generated from oneof envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * Indicates the upstream cluster to which the request should be routed.
     *
     * @generated from field: string cluster = 1;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     * Currently ClusterWeight only supports the name and weight fields.
     *
     * @generated from field: envoy.api.v2.route.WeightedCluster weighted_clusters = 2;
     */
    value: WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction.
 * Use `create(RouteActionSchema)` to create a new message.
 */
export declare const RouteActionSchema: GenMessage<RouteAction>;

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch
 */
export declare type MethodMatch = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch"> & {
  /**
   * The name of the method.
   *
   * @generated from field: envoy.type.matcher.StringMatcher name = 1;
   */
  name?: StringMatcher;

  /**
   * Method parameter definition.
   * The key is the parameter index, starting from 0.
   * The value is the parameter matching type.
   *
   * @generated from field: map<uint32, envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier> params_match = 2;
   */
  paramsMatch: { [key: number]: MethodMatch_ParameterMatchSpecifier };
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.
 * Use `create(MethodMatchSchema)` to create a new message.
 */
export declare const MethodMatchSchema: GenMessage<MethodMatch>;

/**
 * The parameter matching type.
 *
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier
 */
export declare type MethodMatch_ParameterMatchSpecifier = Message<"envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier"> & {
  /**
   * @generated from oneof envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier.parameter_match_specifier
   */
  parameterMatchSpecifier: {
    /**
     * If specified, header match will be performed based on the value of the header.
     *
     * @generated from field: string exact_match = 3;
     */
    value: string;
    case: "exactMatch";
  } | {
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting
     * of an optional plus or minus sign followed by a sequence of digits. The rule will not match
     * if the header value does not represent an integer. Match will fail for empty values,
     * floating point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0,
     *   "somestring", 10.9, "-1somestring"
     *
     * @generated from field: envoy.type.Int64Range range_match = 4;
     */
    value: Int64Range;
    case: "rangeMatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier.
 * Use `create(MethodMatch_ParameterMatchSpecifierSchema)` to create a new message.
 */
export declare const MethodMatch_ParameterMatchSpecifierSchema: GenMessage<MethodMatch_ParameterMatchSpecifier>;

