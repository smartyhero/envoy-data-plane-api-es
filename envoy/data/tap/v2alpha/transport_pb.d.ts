// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/data/tap/v2alpha/transport.proto (package envoy.data.tap.v2alpha, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Address } from "../../../api/v2/core/address_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import type { Body } from "./common_pb";

/**
 * Describes the file envoy/data/tap/v2alpha/transport.proto.
 */
export declare const file_envoy_data_tap_v2alpha_transport: GenFile;

/**
 * Connection properties.
 *
 * @generated from message envoy.data.tap.v2alpha.Connection
 */
export declare type Connection = Message<"envoy.data.tap.v2alpha.Connection"> & {
  /**
   * Local address.
   *
   * @generated from field: envoy.api.v2.core.Address local_address = 2;
   */
  localAddress?: Address;

  /**
   * Remote address.
   *
   * @generated from field: envoy.api.v2.core.Address remote_address = 3;
   */
  remoteAddress?: Address;
};

/**
 * Describes the message envoy.data.tap.v2alpha.Connection.
 * Use `create(ConnectionSchema)` to create a new message.
 */
export declare const ConnectionSchema: GenMessage<Connection>;

/**
 * Event in a socket trace.
 *
 * @generated from message envoy.data.tap.v2alpha.SocketEvent
 */
export declare type SocketEvent = Message<"envoy.data.tap.v2alpha.SocketEvent"> & {
  /**
   * Timestamp for event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * Read or write with content as bytes string.
   *
   * @generated from oneof envoy.data.tap.v2alpha.SocketEvent.event_selector
   */
  eventSelector: {
    /**
     * @generated from field: envoy.data.tap.v2alpha.SocketEvent.Read read = 2;
     */
    value: SocketEvent_Read;
    case: "read";
  } | {
    /**
     * @generated from field: envoy.data.tap.v2alpha.SocketEvent.Write write = 3;
     */
    value: SocketEvent_Write;
    case: "write";
  } | {
    /**
     * @generated from field: envoy.data.tap.v2alpha.SocketEvent.Closed closed = 4;
     */
    value: SocketEvent_Closed;
    case: "closed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketEvent.
 * Use `create(SocketEventSchema)` to create a new message.
 */
export declare const SocketEventSchema: GenMessage<SocketEvent>;

/**
 * Data read by Envoy from the transport socket.
 *
 * TODO(htuch): Half-close for reads.
 *
 * @generated from message envoy.data.tap.v2alpha.SocketEvent.Read
 */
export declare type SocketEvent_Read = Message<"envoy.data.tap.v2alpha.SocketEvent.Read"> & {
  /**
   * Binary data read.
   *
   * @generated from field: envoy.data.tap.v2alpha.Body data = 1;
   */
  data?: Body;
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketEvent.Read.
 * Use `create(SocketEvent_ReadSchema)` to create a new message.
 */
export declare const SocketEvent_ReadSchema: GenMessage<SocketEvent_Read>;

/**
 * Data written by Envoy to the transport socket.
 *
 * @generated from message envoy.data.tap.v2alpha.SocketEvent.Write
 */
export declare type SocketEvent_Write = Message<"envoy.data.tap.v2alpha.SocketEvent.Write"> & {
  /**
   * Binary data written.
   *
   * @generated from field: envoy.data.tap.v2alpha.Body data = 1;
   */
  data?: Body;

  /**
   * Stream was half closed after this write.
   *
   * @generated from field: bool end_stream = 2;
   */
  endStream: boolean;
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketEvent.Write.
 * Use `create(SocketEvent_WriteSchema)` to create a new message.
 */
export declare const SocketEvent_WriteSchema: GenMessage<SocketEvent_Write>;

/**
 * The connection was closed.
 *
 * TODO(mattklein123): Close event type.
 *
 * @generated from message envoy.data.tap.v2alpha.SocketEvent.Closed
 */
export declare type SocketEvent_Closed = Message<"envoy.data.tap.v2alpha.SocketEvent.Closed"> & {
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketEvent.Closed.
 * Use `create(SocketEvent_ClosedSchema)` to create a new message.
 */
export declare const SocketEvent_ClosedSchema: GenMessage<SocketEvent_Closed>;

/**
 * Sequence of read/write events that constitute a buffered trace on a socket.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.data.tap.v2alpha.SocketBufferedTrace
 */
export declare type SocketBufferedTrace = Message<"envoy.data.tap.v2alpha.SocketBufferedTrace"> & {
  /**
   * Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
   * for long term stable uniqueness. Matches connection IDs used in Envoy logs.
   *
   * @generated from field: uint64 trace_id = 1;
   */
  traceId: bigint;

  /**
   * Connection properties.
   *
   * @generated from field: envoy.data.tap.v2alpha.Connection connection = 2;
   */
  connection?: Connection;

  /**
   * Sequence of observed events.
   *
   * @generated from field: repeated envoy.data.tap.v2alpha.SocketEvent events = 3;
   */
  events: SocketEvent[];

  /**
   * Set to true if read events were truncated due to the :ref:`max_buffered_rx_bytes
   * <envoy_api_field_service.tap.v2alpha.OutputConfig.max_buffered_rx_bytes>` setting.
   *
   * @generated from field: bool read_truncated = 4;
   */
  readTruncated: boolean;

  /**
   * Set to true if write events were truncated due to the :ref:`max_buffered_tx_bytes
   * <envoy_api_field_service.tap.v2alpha.OutputConfig.max_buffered_tx_bytes>` setting.
   *
   * @generated from field: bool write_truncated = 5;
   */
  writeTruncated: boolean;
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketBufferedTrace.
 * Use `create(SocketBufferedTraceSchema)` to create a new message.
 */
export declare const SocketBufferedTraceSchema: GenMessage<SocketBufferedTrace>;

/**
 * A streamed socket trace segment. Multiple segments make up a full trace.
 *
 * @generated from message envoy.data.tap.v2alpha.SocketStreamedTraceSegment
 */
export declare type SocketStreamedTraceSegment = Message<"envoy.data.tap.v2alpha.SocketStreamedTraceSegment"> & {
  /**
   * Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
   * for long term stable uniqueness. Matches connection IDs used in Envoy logs.
   *
   * @generated from field: uint64 trace_id = 1;
   */
  traceId: bigint;

  /**
   * @generated from oneof envoy.data.tap.v2alpha.SocketStreamedTraceSegment.message_piece
   */
  messagePiece: {
    /**
     * Connection properties.
     *
     * @generated from field: envoy.data.tap.v2alpha.Connection connection = 2;
     */
    value: Connection;
    case: "connection";
  } | {
    /**
     * Socket event.
     *
     * @generated from field: envoy.data.tap.v2alpha.SocketEvent event = 3;
     */
    value: SocketEvent;
    case: "event";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.data.tap.v2alpha.SocketStreamedTraceSegment.
 * Use `create(SocketStreamedTraceSegmentSchema)` to create a new message.
 */
export declare const SocketStreamedTraceSegmentSchema: GenMessage<SocketStreamedTraceSegment>;

