// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/data/dns/v3/dns_table.proto (package envoy.data.dns.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { StringMatcher } from "../../../type/matcher/v3/string_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file envoy/data/dns/v3/dns_table.proto.
 */
export declare const file_envoy_data_dns_v3_dns_table: GenFile;

/**
 * This message contains the configuration for the DNS Filter if populated
 * from the control plane
 *
 * @generated from message envoy.data.dns.v3.DnsTable
 */
export declare type DnsTable = Message<"envoy.data.dns.v3.DnsTable"> & {
  /**
   * Control how many times Envoy makes an attempt to forward a query to an external DNS server
   *
   * @generated from field: uint32 external_retry_count = 1;
   */
  externalRetryCount: number;

  /**
   * Fully qualified domain names for which Envoy will respond to DNS queries. By leaving this
   * list empty, Envoy will forward all queries to external resolvers
   *
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsVirtualDomain virtual_domains = 2;
   */
  virtualDomains: DnsTable_DnsVirtualDomain[];

  /**
   * This field is deprecated and no longer used in Envoy. The filter's behavior has changed
   * internally to use a different data structure allowing the filter to determine whether a
   * query is for known domain without the use of this field.
   *
   * This field serves to help Envoy determine whether it can authoritatively answer a query
   * for a name matching a suffix in this list. If the query name does not match a suffix in
   * this list, Envoy will forward the query to an upstream DNS server
   *
   * @generated from field: repeated envoy.type.matcher.v3.StringMatcher known_suffixes = 3 [deprecated = true];
   * @deprecated
   */
  knownSuffixes: StringMatcher[];
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.
 * Use `create(DnsTableSchema)` to create a new message.
 */
export declare const DnsTableSchema: GenMessage<DnsTable>;

/**
 * This message contains a list of IP addresses returned for a query for a known name
 *
 * @generated from message envoy.data.dns.v3.DnsTable.AddressList
 */
export declare type DnsTable_AddressList = Message<"envoy.data.dns.v3.DnsTable.AddressList"> & {
  /**
   * This field contains a well formed IP address that is returned in the answer for a
   * name query. The address field can be an IPv4 or IPv6 address. Address family
   * detection is done automatically when Envoy parses the string. Since this field is
   * repeated, Envoy will return as many entries from this list in the DNS response while
   * keeping the response under 512 bytes
   *
   * @generated from field: repeated string address = 1;
   */
  address: string[];
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.AddressList.
 * Use `create(DnsTable_AddressListSchema)` to create a new message.
 */
export declare const DnsTable_AddressListSchema: GenMessage<DnsTable_AddressList>;

/**
 * Specify the service protocol using a numeric or string value
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceProtocol
 */
export declare type DnsTable_DnsServiceProtocol = Message<"envoy.data.dns.v3.DnsTable.DnsServiceProtocol"> & {
  /**
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsServiceProtocol.protocol_config
   */
  protocolConfig: {
    /**
     * Specify the protocol number for the service. Envoy will try to resolve the number to
     * the protocol name. For example, 6 will resolve to "tcp". Refer to:
     * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
     * for protocol names and numbers
     *
     * @generated from field: uint32 number = 1;
     */
    value: number;
    case: "number";
  } | {
    /**
     * Specify the protocol name for the service.
     *
     * @generated from field: string name = 2;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsServiceProtocol.
 * Use `create(DnsTable_DnsServiceProtocolSchema)` to create a new message.
 */
export declare const DnsTable_DnsServiceProtocolSchema: GenMessage<DnsTable_DnsServiceProtocol>;

/**
 * Specify the target for a given DNS service
 * [#next-free-field: 6]
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceTarget
 */
export declare type DnsTable_DnsServiceTarget = Message<"envoy.data.dns.v3.DnsTable.DnsServiceTarget"> & {
  /**
   * Specify the name of the endpoint for the Service. The name is a hostname or a cluster
   *
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsServiceTarget.endpoint_type
   */
  endpointType: {
    /**
     * Use a resolvable hostname as the endpoint for a service.
     *
     * @generated from field: string host_name = 1;
     */
    value: string;
    case: "hostName";
  } | {
    /**
     * Use a cluster name as the endpoint for a service.
     *
     * @generated from field: string cluster_name = 2;
     */
    value: string;
    case: "clusterName";
  } | { case: undefined; value?: undefined };

  /**
   * The priority of the service record target
   *
   * @generated from field: uint32 priority = 3;
   */
  priority: number;

  /**
   * The weight of the service record target
   *
   * @generated from field: uint32 weight = 4;
   */
  weight: number;

  /**
   * The port to which the service is bound. This value is optional if the target is a
   * cluster. Setting port to zero in this case makes the filter use the port value
   * from the cluster host
   *
   * @generated from field: uint32 port = 5;
   */
  port: number;
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsServiceTarget.
 * Use `create(DnsTable_DnsServiceTargetSchema)` to create a new message.
 */
export declare const DnsTable_DnsServiceTargetSchema: GenMessage<DnsTable_DnsServiceTarget>;

/**
 * This message defines a service selection record returned for a service query in a domain
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsService
 */
export declare type DnsTable_DnsService = Message<"envoy.data.dns.v3.DnsTable.DnsService"> & {
  /**
   * The name of the service without the protocol or domain name
   *
   * @generated from field: string service_name = 1;
   */
  serviceName: string;

  /**
   * The service protocol. This can be specified as a string or the numeric value of the protocol
   *
   * @generated from field: envoy.data.dns.v3.DnsTable.DnsServiceProtocol protocol = 2;
   */
  protocol?: DnsTable_DnsServiceProtocol;

  /**
   * The service entry time to live. This is independent from the DNS Answer record TTL
   *
   * @generated from field: google.protobuf.Duration ttl = 3;
   */
  ttl?: Duration;

  /**
   * The list of targets hosting the service
   *
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsServiceTarget targets = 4;
   */
  targets: DnsTable_DnsServiceTarget[];
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsService.
 * Use `create(DnsTable_DnsServiceSchema)` to create a new message.
 */
export declare const DnsTable_DnsServiceSchema: GenMessage<DnsTable_DnsService>;

/**
 * Define a list of service records for a given service
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceList
 */
export declare type DnsTable_DnsServiceList = Message<"envoy.data.dns.v3.DnsTable.DnsServiceList"> & {
  /**
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsService services = 1;
   */
  services: DnsTable_DnsService[];
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsServiceList.
 * Use `create(DnsTable_DnsServiceListSchema)` to create a new message.
 */
export declare const DnsTable_DnsServiceListSchema: GenMessage<DnsTable_DnsServiceList>;

/**
 * @generated from message envoy.data.dns.v3.DnsTable.DnsEndpoint
 */
export declare type DnsTable_DnsEndpoint = Message<"envoy.data.dns.v3.DnsTable.DnsEndpoint"> & {
  /**
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsEndpoint.endpoint_config
   */
  endpointConfig: {
    /**
     * Define a list of addresses to return for the specified endpoint
     *
     * @generated from field: envoy.data.dns.v3.DnsTable.AddressList address_list = 1;
     */
    value: DnsTable_AddressList;
    case: "addressList";
  } | {
    /**
     * Define a cluster whose addresses are returned for the specified endpoint
     *
     * @generated from field: string cluster_name = 2;
     */
    value: string;
    case: "clusterName";
  } | {
    /**
     * Define a DNS Service List for the specified endpoint
     *
     * @generated from field: envoy.data.dns.v3.DnsTable.DnsServiceList service_list = 3;
     */
    value: DnsTable_DnsServiceList;
    case: "serviceList";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsEndpoint.
 * Use `create(DnsTable_DnsEndpointSchema)` to create a new message.
 */
export declare const DnsTable_DnsEndpointSchema: GenMessage<DnsTable_DnsEndpoint>;

/**
 * @generated from message envoy.data.dns.v3.DnsTable.DnsVirtualDomain
 */
export declare type DnsTable_DnsVirtualDomain = Message<"envoy.data.dns.v3.DnsTable.DnsVirtualDomain"> & {
  /**
   * A domain name for which Envoy will respond to query requests.
   * Wildcard records are supported on the first label only, e.g. ``*.example.com`` or ``*.subdomain.example.com``.
   * Names such as ``*example.com``, ``subdomain.*.example.com``, ``*subdomain.example.com``, etc
   * are not valid wildcard names and asterisk will be interpreted as a literal ``*`` character.
   * Wildcard records match subdomains on any levels, e.g. ``*.example.com`` will match
   * ``foo.example.com``, ``bar.foo.example.com``, ``baz.bar.foo.example.com``, etc. In case there are multiple
   * wildcard records, the longest wildcard match will be used, e.g. if there are wildcard records for
   * ``*.example.com`` and ``*.foo.example.com`` and the query is for ``bar.foo.example.com``, the latter will be used.
   * Specific records will always take precedence over wildcard records.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The configuration containing the method to determine the address of this endpoint
   *
   * @generated from field: envoy.data.dns.v3.DnsTable.DnsEndpoint endpoint = 2;
   */
  endpoint?: DnsTable_DnsEndpoint;

  /**
   * Sets the TTL in DNS answers from Envoy returned to the client. The default TTL is 300s
   *
   * @generated from field: google.protobuf.Duration answer_ttl = 3;
   */
  answerTtl?: Duration;
};

/**
 * Describes the message envoy.data.dns.v3.DnsTable.DnsVirtualDomain.
 * Use `create(DnsTable_DnsVirtualDomainSchema)` to create a new message.
 */
export declare const DnsTable_DnsVirtualDomainSchema: GenMessage<DnsTable_DnsVirtualDomain>;

