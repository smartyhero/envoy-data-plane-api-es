// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/api/v2/core/address.proto (package envoy.api.v2.core, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { SocketOption } from "./socket_option_pb";

/**
 * Describes the file envoy/api/v2/core/address.proto.
 */
export declare const file_envoy_api_v2_core_address: GenFile;

/**
 * @generated from message envoy.api.v2.core.Pipe
 */
export declare type Pipe = Message<"envoy.api.v2.core.Pipe"> & {
  /**
   * Unix Domain Socket path. On Linux, paths starting with '@' will use the
   * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
   * Paths starting with '@' will result in an error in environments other than
   * Linux.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * The mode for the Pipe. Not applicable for abstract sockets.
   *
   * @generated from field: uint32 mode = 2;
   */
  mode: number;
};

/**
 * Describes the message envoy.api.v2.core.Pipe.
 * Use `create(PipeSchema)` to create a new message.
 */
export declare const PipeSchema: GenMessage<Pipe>;

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.core.SocketAddress
 */
export declare type SocketAddress = Message<"envoy.api.v2.core.SocketAddress"> & {
  /**
   * @generated from field: envoy.api.v2.core.SocketAddress.Protocol protocol = 1;
   */
  protocol: SocketAddress_Protocol;

  /**
   * The address for this socket. :ref:`Listeners <config_listeners>` will bind
   * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
   * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
   * It is possible to distinguish a Listener address via the prefix/suffix matching
   * in :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>`.] When used
   * within an upstream :ref:`BindConfig <envoy_api_msg_core.BindConfig>`, the address
   * controls the source address of outbound connections. For :ref:`clusters
   * <envoy_api_msg_Cluster>`, the cluster type determines whether the
   * address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS
   * (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized
   * via :ref:`resolver_name <envoy_api_field_core.SocketAddress.resolver_name>`.
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * @generated from oneof envoy.api.v2.core.SocketAddress.port_specifier
   */
  portSpecifier: {
    /**
     * @generated from field: uint32 port_value = 3;
     */
    value: number;
    case: "portValue";
  } | {
    /**
     * This is only valid if :ref:`resolver_name
     * <envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
     * named resolver is capable of named port resolution.
     *
     * @generated from field: string named_port = 4;
     */
    value: string;
    case: "namedPort";
  } | { case: undefined; value?: undefined };

  /**
   * The name of the custom resolver. This must have been registered with Envoy. If
   * this is empty, a context dependent default applies. If the address is a concrete
   * IP address, no resolution will occur. If address is a hostname this
   * should be set for resolution other than DNS. Specifying a custom resolver with
   * *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
   *
   * @generated from field: string resolver_name = 5;
   */
  resolverName: string;

  /**
   * When binding to an IPv6 address above, this enables `IPv4 compatibility
   * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
   * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
   * IPv6 space as ``::FFFF:<IPv4-address>``.
   *
   * @generated from field: bool ipv4_compat = 6;
   */
  ipv4Compat: boolean;
};

/**
 * Describes the message envoy.api.v2.core.SocketAddress.
 * Use `create(SocketAddressSchema)` to create a new message.
 */
export declare const SocketAddressSchema: GenMessage<SocketAddress>;

/**
 * @generated from enum envoy.api.v2.core.SocketAddress.Protocol
 */
export enum SocketAddress_Protocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: UDP = 1;
   */
  UDP = 1,
}

/**
 * Describes the enum envoy.api.v2.core.SocketAddress.Protocol.
 */
export declare const SocketAddress_ProtocolSchema: GenEnum<SocketAddress_Protocol>;

/**
 * @generated from message envoy.api.v2.core.TcpKeepalive
 */
export declare type TcpKeepalive = Message<"envoy.api.v2.core.TcpKeepalive"> & {
  /**
   * Maximum number of keepalive probes to send without response before deciding
   * the connection is dead. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 9.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_probes = 1;
   */
  keepaliveProbes?: number;

  /**
   * The number of seconds a connection needs to be idle before keep-alive probes
   * start being sent. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 7200s (i.e., 2 hours.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_time = 2;
   */
  keepaliveTime?: number;

  /**
   * The number of seconds between keep-alive probes. Default is to use the OS
   * level configuration (unless overridden, Linux defaults to 75s.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_interval = 3;
   */
  keepaliveInterval?: number;
};

/**
 * Describes the message envoy.api.v2.core.TcpKeepalive.
 * Use `create(TcpKeepaliveSchema)` to create a new message.
 */
export declare const TcpKeepaliveSchema: GenMessage<TcpKeepalive>;

/**
 * @generated from message envoy.api.v2.core.BindConfig
 */
export declare type BindConfig = Message<"envoy.api.v2.core.BindConfig"> & {
  /**
   * The address to bind to when creating a socket.
   *
   * @generated from field: envoy.api.v2.core.SocketAddress source_address = 1;
   */
  sourceAddress?: SocketAddress;

  /**
   * Whether to set the *IP_FREEBIND* option when creating the socket. When this
   * flag is set to true, allows the :ref:`source_address
   * <envoy_api_field_UpstreamBindConfig.source_address>` to be an IP address
   * that is not configured on the system running Envoy. When this flag is set
   * to false, the option *IP_FREEBIND* is disabled on the socket. When this
   * flag is not set (default), the socket is not modified, i.e. the option is
   * neither enabled nor disabled.
   *
   * @generated from field: google.protobuf.BoolValue freebind = 2;
   */
  freebind?: boolean;

  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   *
   * @generated from field: repeated envoy.api.v2.core.SocketOption socket_options = 3;
   */
  socketOptions: SocketOption[];
};

/**
 * Describes the message envoy.api.v2.core.BindConfig.
 * Use `create(BindConfigSchema)` to create a new message.
 */
export declare const BindConfigSchema: GenMessage<BindConfig>;

/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 *
 * @generated from message envoy.api.v2.core.Address
 */
export declare type Address = Message<"envoy.api.v2.core.Address"> & {
  /**
   * @generated from oneof envoy.api.v2.core.Address.address
   */
  address: {
    /**
     * @generated from field: envoy.api.v2.core.SocketAddress socket_address = 1;
     */
    value: SocketAddress;
    case: "socketAddress";
  } | {
    /**
     * @generated from field: envoy.api.v2.core.Pipe pipe = 2;
     */
    value: Pipe;
    case: "pipe";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.api.v2.core.Address.
 * Use `create(AddressSchema)` to create a new message.
 */
export declare const AddressSchema: GenMessage<Address>;

/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 *
 * @generated from message envoy.api.v2.core.CidrRange
 */
export declare type CidrRange = Message<"envoy.api.v2.core.CidrRange"> & {
  /**
   * IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
   *
   * @generated from field: string address_prefix = 1;
   */
  addressPrefix: string;

  /**
   * Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
   *
   * @generated from field: google.protobuf.UInt32Value prefix_len = 2;
   */
  prefixLen?: number;
};

/**
 * Describes the message envoy.api.v2.core.CidrRange.
 * Use `create(CidrRangeSchema)` to create a new message.
 */
export declare const CidrRangeSchema: GenMessage<CidrRange>;

