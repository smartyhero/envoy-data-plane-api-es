// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/service/accesslog/v2/als.proto (package envoy.service.accesslog.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Node } from "../../../api/v2/core/base_pb";
import type { HTTPAccessLogEntry, TCPAccessLogEntry } from "../../../data/accesslog/v2/accesslog_pb";

/**
 * Describes the file envoy/service/accesslog/v2/als.proto.
 */
export declare const file_envoy_service_accesslog_v2_als: GenFile;

/**
 * Empty response for the StreamAccessLogs API. Will never be sent. See below.
 *
 * @generated from message envoy.service.accesslog.v2.StreamAccessLogsResponse
 */
export declare type StreamAccessLogsResponse = Message<"envoy.service.accesslog.v2.StreamAccessLogsResponse"> & {
};

/**
 * Describes the message envoy.service.accesslog.v2.StreamAccessLogsResponse.
 * Use `create(StreamAccessLogsResponseSchema)` to create a new message.
 */
export declare const StreamAccessLogsResponseSchema: GenMessage<StreamAccessLogsResponse>;

/**
 * Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
 * access logs without ever expecting a response.
 *
 * @generated from message envoy.service.accesslog.v2.StreamAccessLogsMessage
 */
export declare type StreamAccessLogsMessage = Message<"envoy.service.accesslog.v2.StreamAccessLogsMessage"> & {
  /**
   * Identifier data that will only be sent in the first message on the stream. This is effectively
   * structured metadata and is a performance optimization.
   *
   * @generated from field: envoy.service.accesslog.v2.StreamAccessLogsMessage.Identifier identifier = 1;
   */
  identifier?: StreamAccessLogsMessage_Identifier;

  /**
   * Batches of log entries of a single type. Generally speaking, a given stream should only
   * ever include one type of log entry.
   *
   * @generated from oneof envoy.service.accesslog.v2.StreamAccessLogsMessage.log_entries
   */
  logEntries: {
    /**
     * @generated from field: envoy.service.accesslog.v2.StreamAccessLogsMessage.HTTPAccessLogEntries http_logs = 2;
     */
    value: StreamAccessLogsMessage_HTTPAccessLogEntries;
    case: "httpLogs";
  } | {
    /**
     * @generated from field: envoy.service.accesslog.v2.StreamAccessLogsMessage.TCPAccessLogEntries tcp_logs = 3;
     */
    value: StreamAccessLogsMessage_TCPAccessLogEntries;
    case: "tcpLogs";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.service.accesslog.v2.StreamAccessLogsMessage.
 * Use `create(StreamAccessLogsMessageSchema)` to create a new message.
 */
export declare const StreamAccessLogsMessageSchema: GenMessage<StreamAccessLogsMessage>;

/**
 * @generated from message envoy.service.accesslog.v2.StreamAccessLogsMessage.Identifier
 */
export declare type StreamAccessLogsMessage_Identifier = Message<"envoy.service.accesslog.v2.StreamAccessLogsMessage.Identifier"> & {
  /**
   * The node sending the access log messages over the stream.
   *
   * @generated from field: envoy.api.v2.core.Node node = 1;
   */
  node?: Node;

  /**
   * The friendly name of the log configured in :ref:`CommonGrpcAccessLogConfig
   * <envoy_api_msg_config.accesslog.v2.CommonGrpcAccessLogConfig>`.
   *
   * @generated from field: string log_name = 2;
   */
  logName: string;
};

/**
 * Describes the message envoy.service.accesslog.v2.StreamAccessLogsMessage.Identifier.
 * Use `create(StreamAccessLogsMessage_IdentifierSchema)` to create a new message.
 */
export declare const StreamAccessLogsMessage_IdentifierSchema: GenMessage<StreamAccessLogsMessage_Identifier>;

/**
 * Wrapper for batches of HTTP access log entries.
 *
 * @generated from message envoy.service.accesslog.v2.StreamAccessLogsMessage.HTTPAccessLogEntries
 */
export declare type StreamAccessLogsMessage_HTTPAccessLogEntries = Message<"envoy.service.accesslog.v2.StreamAccessLogsMessage.HTTPAccessLogEntries"> & {
  /**
   * @generated from field: repeated envoy.data.accesslog.v2.HTTPAccessLogEntry log_entry = 1;
   */
  logEntry: HTTPAccessLogEntry[];
};

/**
 * Describes the message envoy.service.accesslog.v2.StreamAccessLogsMessage.HTTPAccessLogEntries.
 * Use `create(StreamAccessLogsMessage_HTTPAccessLogEntriesSchema)` to create a new message.
 */
export declare const StreamAccessLogsMessage_HTTPAccessLogEntriesSchema: GenMessage<StreamAccessLogsMessage_HTTPAccessLogEntries>;

/**
 * Wrapper for batches of TCP access log entries.
 *
 * @generated from message envoy.service.accesslog.v2.StreamAccessLogsMessage.TCPAccessLogEntries
 */
export declare type StreamAccessLogsMessage_TCPAccessLogEntries = Message<"envoy.service.accesslog.v2.StreamAccessLogsMessage.TCPAccessLogEntries"> & {
  /**
   * @generated from field: repeated envoy.data.accesslog.v2.TCPAccessLogEntry log_entry = 1;
   */
  logEntry: TCPAccessLogEntry[];
};

/**
 * Describes the message envoy.service.accesslog.v2.StreamAccessLogsMessage.TCPAccessLogEntries.
 * Use `create(StreamAccessLogsMessage_TCPAccessLogEntriesSchema)` to create a new message.
 */
export declare const StreamAccessLogsMessage_TCPAccessLogEntriesSchema: GenMessage<StreamAccessLogsMessage_TCPAccessLogEntries>;

/**
 * Service for streaming access logs from Envoy to an access log server.
 *
 * @generated from service envoy.service.accesslog.v2.AccessLogService
 */
export declare const AccessLogService: GenService<{
  /**
   * Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
   * response to be sent as nothing would be done in the case of failure. The server should
   * disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
   * API for "critical" access logs in which Envoy will buffer access logs for some period of time
   * until it gets an ACK so it could then retry. This API is designed for high throughput with the
   * expectation that it might be lossy.
   *
   * @generated from rpc envoy.service.accesslog.v2.AccessLogService.StreamAccessLogs
   */
  streamAccessLogs: {
    methodKind: "client_streaming";
    input: typeof StreamAccessLogsMessageSchema;
    output: typeof StreamAccessLogsResponseSchema;
  },
}>;

