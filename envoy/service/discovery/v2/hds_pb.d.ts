// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/service/discovery/v2/hds.proto (package envoy.service.discovery.v2, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Locality, Node } from "../../../api/v2/core/base_pb";
import type { Endpoint } from "../../../api/v2/endpoint/endpoint_components_pb";
import type { HealthCheck, HealthStatus } from "../../../api/v2/core/health_check_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file envoy/service/discovery/v2/hds.proto.
 */
export declare const file_envoy_service_discovery_v2_hds: GenFile;

/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 *
 * @generated from message envoy.service.discovery.v2.Capability
 */
export declare type Capability = Message<"envoy.service.discovery.v2.Capability"> & {
  /**
   * @generated from field: repeated envoy.service.discovery.v2.Capability.Protocol health_check_protocols = 1;
   */
  healthCheckProtocols: Capability_Protocol[];
};

/**
 * Describes the message envoy.service.discovery.v2.Capability.
 * Use `create(CapabilitySchema)` to create a new message.
 */
export declare const CapabilitySchema: GenMessage<Capability>;

/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 *
 * @generated from enum envoy.service.discovery.v2.Capability.Protocol
 */
export enum Capability_Protocol {
  /**
   * @generated from enum value: HTTP = 0;
   */
  HTTP = 0,

  /**
   * @generated from enum value: TCP = 1;
   */
  TCP = 1,

  /**
   * @generated from enum value: REDIS = 2;
   */
  REDIS = 2,
}

/**
 * Describes the enum envoy.service.discovery.v2.Capability.Protocol.
 */
export declare const Capability_ProtocolSchema: GenEnum<Capability_Protocol>;

/**
 * @generated from message envoy.service.discovery.v2.HealthCheckRequest
 */
export declare type HealthCheckRequest = Message<"envoy.service.discovery.v2.HealthCheckRequest"> & {
  /**
   * @generated from field: envoy.api.v2.core.Node node = 1;
   */
  node?: Node;

  /**
   * @generated from field: envoy.service.discovery.v2.Capability capability = 2;
   */
  capability?: Capability;
};

/**
 * Describes the message envoy.service.discovery.v2.HealthCheckRequest.
 * Use `create(HealthCheckRequestSchema)` to create a new message.
 */
export declare const HealthCheckRequestSchema: GenMessage<HealthCheckRequest>;

/**
 * @generated from message envoy.service.discovery.v2.EndpointHealth
 */
export declare type EndpointHealth = Message<"envoy.service.discovery.v2.EndpointHealth"> & {
  /**
   * @generated from field: envoy.api.v2.endpoint.Endpoint endpoint = 1;
   */
  endpoint?: Endpoint;

  /**
   * @generated from field: envoy.api.v2.core.HealthStatus health_status = 2;
   */
  healthStatus: HealthStatus;
};

/**
 * Describes the message envoy.service.discovery.v2.EndpointHealth.
 * Use `create(EndpointHealthSchema)` to create a new message.
 */
export declare const EndpointHealthSchema: GenMessage<EndpointHealth>;

/**
 * @generated from message envoy.service.discovery.v2.EndpointHealthResponse
 */
export declare type EndpointHealthResponse = Message<"envoy.service.discovery.v2.EndpointHealthResponse"> & {
  /**
   * @generated from field: repeated envoy.service.discovery.v2.EndpointHealth endpoints_health = 1;
   */
  endpointsHealth: EndpointHealth[];
};

/**
 * Describes the message envoy.service.discovery.v2.EndpointHealthResponse.
 * Use `create(EndpointHealthResponseSchema)` to create a new message.
 */
export declare const EndpointHealthResponseSchema: GenMessage<EndpointHealthResponse>;

/**
 * @generated from message envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse
 */
export declare type HealthCheckRequestOrEndpointHealthResponse = Message<"envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse"> & {
  /**
   * @generated from oneof envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse.request_type
   */
  requestType: {
    /**
     * @generated from field: envoy.service.discovery.v2.HealthCheckRequest health_check_request = 1;
     */
    value: HealthCheckRequest;
    case: "healthCheckRequest";
  } | {
    /**
     * @generated from field: envoy.service.discovery.v2.EndpointHealthResponse endpoint_health_response = 2;
     */
    value: EndpointHealthResponse;
    case: "endpointHealthResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse.
 * Use `create(HealthCheckRequestOrEndpointHealthResponseSchema)` to create a new message.
 */
export declare const HealthCheckRequestOrEndpointHealthResponseSchema: GenMessage<HealthCheckRequestOrEndpointHealthResponse>;

/**
 * @generated from message envoy.service.discovery.v2.LocalityEndpoints
 */
export declare type LocalityEndpoints = Message<"envoy.service.discovery.v2.LocalityEndpoints"> & {
  /**
   * @generated from field: envoy.api.v2.core.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * @generated from field: repeated envoy.api.v2.endpoint.Endpoint endpoints = 2;
   */
  endpoints: Endpoint[];
};

/**
 * Describes the message envoy.service.discovery.v2.LocalityEndpoints.
 * Use `create(LocalityEndpointsSchema)` to create a new message.
 */
export declare const LocalityEndpointsSchema: GenMessage<LocalityEndpoints>;

/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 *
 * @generated from message envoy.service.discovery.v2.ClusterHealthCheck
 */
export declare type ClusterHealthCheck = Message<"envoy.service.discovery.v2.ClusterHealthCheck"> & {
  /**
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * @generated from field: repeated envoy.api.v2.core.HealthCheck health_checks = 2;
   */
  healthChecks: HealthCheck[];

  /**
   * @generated from field: repeated envoy.service.discovery.v2.LocalityEndpoints locality_endpoints = 3;
   */
  localityEndpoints: LocalityEndpoints[];
};

/**
 * Describes the message envoy.service.discovery.v2.ClusterHealthCheck.
 * Use `create(ClusterHealthCheckSchema)` to create a new message.
 */
export declare const ClusterHealthCheckSchema: GenMessage<ClusterHealthCheck>;

/**
 * @generated from message envoy.service.discovery.v2.HealthCheckSpecifier
 */
export declare type HealthCheckSpecifier = Message<"envoy.service.discovery.v2.HealthCheckSpecifier"> & {
  /**
   * @generated from field: repeated envoy.service.discovery.v2.ClusterHealthCheck cluster_health_checks = 1;
   */
  clusterHealthChecks: ClusterHealthCheck[];

  /**
   * The default is 1 second.
   *
   * @generated from field: google.protobuf.Duration interval = 2;
   */
  interval?: Duration;
};

/**
 * Describes the message envoy.service.discovery.v2.HealthCheckSpecifier.
 * Use `create(HealthCheckSpecifierSchema)` to create a new message.
 */
export declare const HealthCheckSpecifierSchema: GenMessage<HealthCheckSpecifier>;

/**
 * HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
 * service by designating this Envoy to be a healthchecker for a subset of hosts
 * in the cluster. The status of these health checks will be reported to the
 * management server, where it can be aggregated etc and redistributed back to
 * Envoy through EDS.
 *
 * @generated from service envoy.service.discovery.v2.HealthDiscoveryService
 */
export declare const HealthDiscoveryService: GenService<{
  /**
   * 1. Envoy starts up and if its can_healthcheck option in the static
   *    bootstrap config is enabled, sends HealthCheckRequest to the management
   *    server. It supplies its capabilities (which protocol it can health check
   *    with, what zone it resides in, etc.).
   * 2. In response to (1), the management server designates this Envoy as a
   *    healthchecker to health check a subset of all upstream hosts for a given
   *    cluster (for example upstream Host 1 and Host 2). It streams
   *    HealthCheckSpecifier messages with cluster related configuration for all
   *    clusters this Envoy is designated to health check. Subsequent
   *    HealthCheckSpecifier message will be sent on changes to:
   *    a. Endpoints to health checks
   *    b. Per cluster configuration change
   * 3. Envoy creates a health probe based on the HealthCheck config and sends
   *    it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
   *    configuration Envoy waits upon the arrival of the probe response and
   *    looks at the content of the response to decide whether the endpoint is
   *    healthy or not. If a response hasn't been received within the timeout
   *    interval, the endpoint health status is considered TIMEOUT.
   * 4. Envoy reports results back in an EndpointHealthResponse message.
   *    Envoy streams responses as often as the interval configured by the
   *    management server in HealthCheckSpecifier.
   * 5. The management Server collects health statuses for all endpoints in the
   *    cluster (for all clusters) and uses this information to construct
   *    EndpointDiscoveryResponse messages.
   * 6. Once Envoy has a list of upstream endpoints to send traffic to, it load
   *    balances traffic to them without additional health checking. It may
   *    use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
   *    failed to a particular endpoint to account for health status propagation
   *    delay between HDS and EDS).
   * By default, can_healthcheck is true. If can_healthcheck is false, Cluster
   * configuration may not contain HealthCheck message.
   * TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
   * invariant?
   * TODO(htuch): Add @amb67's diagram.
   *
   * @generated from rpc envoy.service.discovery.v2.HealthDiscoveryService.StreamHealthCheck
   */
  streamHealthCheck: {
    methodKind: "bidi_streaming";
    input: typeof HealthCheckRequestOrEndpointHealthResponseSchema;
    output: typeof HealthCheckSpecifierSchema;
  },
  /**
   * TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
   * request/response. Should we add an identifier to the HealthCheckSpecifier
   * to bind with the response?
   *
   * @generated from rpc envoy.service.discovery.v2.HealthDiscoveryService.FetchHealthCheck
   */
  fetchHealthCheck: {
    methodKind: "unary";
    input: typeof HealthCheckRequestOrEndpointHealthResponseSchema;
    output: typeof HealthCheckSpecifierSchema;
  },
}>;

