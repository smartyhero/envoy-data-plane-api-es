// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/service/health/v3/hds.proto (package envoy.service.health.v3, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Locality, Node } from "../../../config/core/v3/base_pb";
import type { Endpoint } from "../../../config/endpoint/v3/endpoint_components_pb";
import type { HealthCheck, HealthStatus } from "../../../config/core/v3/health_check_pb";
import type { Cluster_TransportSocketMatch } from "../../../config/cluster/v3/cluster_pb";
import type { BindConfig } from "../../../config/core/v3/address_pb";
import type { Duration } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file envoy/service/health/v3/hds.proto.
 */
export declare const file_envoy_service_health_v3_hds: GenFile;

/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 *
 * @generated from message envoy.service.health.v3.Capability
 */
export declare type Capability = Message<"envoy.service.health.v3.Capability"> & {
  /**
   * @generated from field: repeated envoy.service.health.v3.Capability.Protocol health_check_protocols = 1;
   */
  healthCheckProtocols: Capability_Protocol[];
};

/**
 * Describes the message envoy.service.health.v3.Capability.
 * Use `create(CapabilitySchema)` to create a new message.
 */
export declare const CapabilitySchema: GenMessage<Capability>;

/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 *
 * @generated from enum envoy.service.health.v3.Capability.Protocol
 */
export enum Capability_Protocol {
  /**
   * @generated from enum value: HTTP = 0;
   */
  HTTP = 0,

  /**
   * @generated from enum value: TCP = 1;
   */
  TCP = 1,

  /**
   * @generated from enum value: REDIS = 2;
   */
  REDIS = 2,
}

/**
 * Describes the enum envoy.service.health.v3.Capability.Protocol.
 */
export declare const Capability_ProtocolSchema: GenEnum<Capability_Protocol>;

/**
 * @generated from message envoy.service.health.v3.HealthCheckRequest
 */
export declare type HealthCheckRequest = Message<"envoy.service.health.v3.HealthCheckRequest"> & {
  /**
   * @generated from field: envoy.config.core.v3.Node node = 1;
   */
  node?: Node;

  /**
   * @generated from field: envoy.service.health.v3.Capability capability = 2;
   */
  capability?: Capability;
};

/**
 * Describes the message envoy.service.health.v3.HealthCheckRequest.
 * Use `create(HealthCheckRequestSchema)` to create a new message.
 */
export declare const HealthCheckRequestSchema: GenMessage<HealthCheckRequest>;

/**
 * @generated from message envoy.service.health.v3.EndpointHealth
 */
export declare type EndpointHealth = Message<"envoy.service.health.v3.EndpointHealth"> & {
  /**
   * @generated from field: envoy.config.endpoint.v3.Endpoint endpoint = 1;
   */
  endpoint?: Endpoint;

  /**
   * @generated from field: envoy.config.core.v3.HealthStatus health_status = 2;
   */
  healthStatus: HealthStatus;
};

/**
 * Describes the message envoy.service.health.v3.EndpointHealth.
 * Use `create(EndpointHealthSchema)` to create a new message.
 */
export declare const EndpointHealthSchema: GenMessage<EndpointHealth>;

/**
 * Group endpoint health by locality under each cluster.
 *
 * @generated from message envoy.service.health.v3.LocalityEndpointsHealth
 */
export declare type LocalityEndpointsHealth = Message<"envoy.service.health.v3.LocalityEndpointsHealth"> & {
  /**
   * @generated from field: envoy.config.core.v3.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * @generated from field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 2;
   */
  endpointsHealth: EndpointHealth[];
};

/**
 * Describes the message envoy.service.health.v3.LocalityEndpointsHealth.
 * Use `create(LocalityEndpointsHealthSchema)` to create a new message.
 */
export declare const LocalityEndpointsHealthSchema: GenMessage<LocalityEndpointsHealth>;

/**
 * The health status of endpoints in a cluster. The cluster name and locality
 * should match the corresponding fields in ClusterHealthCheck message.
 *
 * @generated from message envoy.service.health.v3.ClusterEndpointsHealth
 */
export declare type ClusterEndpointsHealth = Message<"envoy.service.health.v3.ClusterEndpointsHealth"> & {
  /**
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * @generated from field: repeated envoy.service.health.v3.LocalityEndpointsHealth locality_endpoints_health = 2;
   */
  localityEndpointsHealth: LocalityEndpointsHealth[];
};

/**
 * Describes the message envoy.service.health.v3.ClusterEndpointsHealth.
 * Use `create(ClusterEndpointsHealthSchema)` to create a new message.
 */
export declare const ClusterEndpointsHealthSchema: GenMessage<ClusterEndpointsHealth>;

/**
 * @generated from message envoy.service.health.v3.EndpointHealthResponse
 */
export declare type EndpointHealthResponse = Message<"envoy.service.health.v3.EndpointHealthResponse"> & {
  /**
   * Deprecated - Flat list of endpoint health information.
   *
   * @generated from field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 1 [deprecated = true];
   * @deprecated
   */
  endpointsHealth: EndpointHealth[];

  /**
   * Organize Endpoint health information by cluster.
   *
   * @generated from field: repeated envoy.service.health.v3.ClusterEndpointsHealth cluster_endpoints_health = 2;
   */
  clusterEndpointsHealth: ClusterEndpointsHealth[];
};

/**
 * Describes the message envoy.service.health.v3.EndpointHealthResponse.
 * Use `create(EndpointHealthResponseSchema)` to create a new message.
 */
export declare const EndpointHealthResponseSchema: GenMessage<EndpointHealthResponse>;

/**
 * @generated from message envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse
 */
export declare type HealthCheckRequestOrEndpointHealthResponse = Message<"envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse"> & {
  /**
   * @generated from oneof envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse.request_type
   */
  requestType: {
    /**
     * @generated from field: envoy.service.health.v3.HealthCheckRequest health_check_request = 1;
     */
    value: HealthCheckRequest;
    case: "healthCheckRequest";
  } | {
    /**
     * @generated from field: envoy.service.health.v3.EndpointHealthResponse endpoint_health_response = 2;
     */
    value: EndpointHealthResponse;
    case: "endpointHealthResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse.
 * Use `create(HealthCheckRequestOrEndpointHealthResponseSchema)` to create a new message.
 */
export declare const HealthCheckRequestOrEndpointHealthResponseSchema: GenMessage<HealthCheckRequestOrEndpointHealthResponse>;

/**
 * @generated from message envoy.service.health.v3.LocalityEndpoints
 */
export declare type LocalityEndpoints = Message<"envoy.service.health.v3.LocalityEndpoints"> & {
  /**
   * @generated from field: envoy.config.core.v3.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * @generated from field: repeated envoy.config.endpoint.v3.Endpoint endpoints = 2;
   */
  endpoints: Endpoint[];
};

/**
 * Describes the message envoy.service.health.v3.LocalityEndpoints.
 * Use `create(LocalityEndpointsSchema)` to create a new message.
 */
export declare const LocalityEndpointsSchema: GenMessage<LocalityEndpoints>;

/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.service.health.v3.ClusterHealthCheck
 */
export declare type ClusterHealthCheck = Message<"envoy.service.health.v3.ClusterHealthCheck"> & {
  /**
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * @generated from field: repeated envoy.config.core.v3.HealthCheck health_checks = 2;
   */
  healthChecks: HealthCheck[];

  /**
   * @generated from field: repeated envoy.service.health.v3.LocalityEndpoints locality_endpoints = 3;
   */
  localityEndpoints: LocalityEndpoints[];

  /**
   * Optional map that gets filtered by :ref:`health_checks.transport_socket_match_criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>`
   * on connection when health checking. For more details, see
   * :ref:`config.cluster.v3.Cluster.transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
   *
   * @generated from field: repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 4;
   */
  transportSocketMatches: Cluster_TransportSocketMatch[];

  /**
   * Optional configuration used to bind newly established upstream connections.
   * If the address and port are empty, no bind will be performed.
   *
   * @generated from field: envoy.config.core.v3.BindConfig upstream_bind_config = 5;
   */
  upstreamBindConfig?: BindConfig;
};

/**
 * Describes the message envoy.service.health.v3.ClusterHealthCheck.
 * Use `create(ClusterHealthCheckSchema)` to create a new message.
 */
export declare const ClusterHealthCheckSchema: GenMessage<ClusterHealthCheck>;

/**
 * @generated from message envoy.service.health.v3.HealthCheckSpecifier
 */
export declare type HealthCheckSpecifier = Message<"envoy.service.health.v3.HealthCheckSpecifier"> & {
  /**
   * @generated from field: repeated envoy.service.health.v3.ClusterHealthCheck cluster_health_checks = 1;
   */
  clusterHealthChecks: ClusterHealthCheck[];

  /**
   * The default is 1 second.
   *
   * @generated from field: google.protobuf.Duration interval = 2;
   */
  interval?: Duration;
};

/**
 * Describes the message envoy.service.health.v3.HealthCheckSpecifier.
 * Use `create(HealthCheckSpecifierSchema)` to create a new message.
 */
export declare const HealthCheckSpecifierSchema: GenMessage<HealthCheckSpecifier>;

/**
 * [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
 * services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
 *
 * @generated from message envoy.service.health.v3.HdsDummy
 */
export declare type HdsDummy = Message<"envoy.service.health.v3.HdsDummy"> & {
};

/**
 * Describes the message envoy.service.health.v3.HdsDummy.
 * Use `create(HdsDummySchema)` to create a new message.
 */
export declare const HdsDummySchema: GenMessage<HdsDummy>;

/**
 * HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
 * service by designating this Envoy to be a healthchecker for a subset of hosts
 * in the cluster. The status of these health checks will be reported to the
 * management server, where it can be aggregated etc and redistributed back to
 * Envoy through EDS.
 *
 * @generated from service envoy.service.health.v3.HealthDiscoveryService
 */
export declare const HealthDiscoveryService: GenService<{
  /**
   * 1. Envoy starts up and if its can_healthcheck option in the static
   *    bootstrap config is enabled, sends HealthCheckRequest to the management
   *    server. It supplies its capabilities (which protocol it can health check
   *    with, what zone it resides in, etc.).
   * 2. In response to (1), the management server designates this Envoy as a
   *    healthchecker to health check a subset of all upstream hosts for a given
   *    cluster (for example upstream Host 1 and Host 2). It streams
   *    HealthCheckSpecifier messages with cluster related configuration for all
   *    clusters this Envoy is designated to health check. Subsequent
   *    HealthCheckSpecifier message will be sent on changes to:
   *    a. Endpoints to health checks
   *    b. Per cluster configuration change
   * 3. Envoy creates a health probe based on the HealthCheck config and sends
   *    it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
   *    configuration Envoy waits upon the arrival of the probe response and
   *    looks at the content of the response to decide whether the endpoint is
   *    healthy or not. If a response hasn't been received within the timeout
   *    interval, the endpoint health status is considered TIMEOUT.
   * 4. Envoy reports results back in an EndpointHealthResponse message.
   *    Envoy streams responses as often as the interval configured by the
   *    management server in HealthCheckSpecifier.
   * 5. The management Server collects health statuses for all endpoints in the
   *    cluster (for all clusters) and uses this information to construct
   *    EndpointDiscoveryResponse messages.
   * 6. Once Envoy has a list of upstream endpoints to send traffic to, it load
   *    balances traffic to them without additional health checking. It may
   *    use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
   *    failed to a particular endpoint to account for health status propagation
   *    delay between HDS and EDS).
   * By default, can_healthcheck is true. If can_healthcheck is false, Cluster
   * configuration may not contain HealthCheck message.
   * TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
   * invariant?
   * TODO(htuch): Add @amb67's diagram.
   *
   * @generated from rpc envoy.service.health.v3.HealthDiscoveryService.StreamHealthCheck
   */
  streamHealthCheck: {
    methodKind: "bidi_streaming";
    input: typeof HealthCheckRequestOrEndpointHealthResponseSchema;
    output: typeof HealthCheckSpecifierSchema;
  },
  /**
   * TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
   * request/response. Should we add an identifier to the HealthCheckSpecifier
   * to bind with the response?
   *
   * @generated from rpc envoy.service.health.v3.HealthDiscoveryService.FetchHealthCheck
   */
  fetchHealthCheck: {
    methodKind: "unary";
    input: typeof HealthCheckRequestOrEndpointHealthResponseSchema;
    output: typeof HealthCheckSpecifierSchema;
  },
}>;

