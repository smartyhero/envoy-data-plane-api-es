// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/service/rate_limit_quota/v3/rlqs.proto (package envoy.service.rate_limit_quota.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Duration } from "@bufbuild/protobuf/wkt";
import type { RateLimitStrategy } from "../../../type/v3/ratelimit_strategy_pb";

/**
 * Describes the file envoy/service/rate_limit_quota/v3/rlqs.proto.
 */
export declare const file_envoy_service_rate_limit_quota_v3_rlqs: GenFile;

/**
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports
 */
export declare type RateLimitQuotaUsageReports = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports"> & {
  /**
   * All quota requests must specify the domain. This enables sharing the quota
   * server between different applications without fear of overlap.
   * E.g., "envoy".
   *
   * Should only be provided in the first report, all subsequent messages on the same
   * stream are considered to be in the same domain. In case the domain needs to be
   * changes, close the stream, and reopen a new one with the different domain.
   *
   * @generated from field: string domain = 1;
   */
  domain: string;

  /**
   * A list of quota usage reports. The list is processed by the RLQS server in the same order
   * it's provided by the client.
   *
   * @generated from field: repeated envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage bucket_quota_usages = 2;
   */
  bucketQuotaUsages: RateLimitQuotaUsageReports_BucketQuotaUsage[];
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.
 * Use `create(RateLimitQuotaUsageReportsSchema)` to create a new message.
 */
export declare const RateLimitQuotaUsageReportsSchema: GenMessage<RateLimitQuotaUsageReports>;

/**
 * The usage report for a bucket.
 *
 * .. note::
 *   Note that the first report sent for a ``BucketId`` indicates to the RLQS server that
 *   the RLQS client is subscribing for the future assignments for this ``BucketId``.
 *
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage
 */
export declare type RateLimitQuotaUsageReports_BucketQuotaUsage = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage"> & {
  /**
   * ``BucketId`` for which request quota usage is reported.
   *
   * @generated from field: envoy.service.rate_limit_quota.v3.BucketId bucket_id = 1;
   */
  bucketId?: BucketId;

  /**
   * Time elapsed since the last report.
   *
   * @generated from field: google.protobuf.Duration time_elapsed = 2;
   */
  timeElapsed?: Duration;

  /**
   * Requests the data plane has allowed through.
   *
   * @generated from field: uint64 num_requests_allowed = 3;
   */
  numRequestsAllowed: bigint;

  /**
   * Requests throttled.
   *
   * @generated from field: uint64 num_requests_denied = 4;
   */
  numRequestsDenied: bigint;
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaUsageReports.BucketQuotaUsage.
 * Use `create(RateLimitQuotaUsageReports_BucketQuotaUsageSchema)` to create a new message.
 */
export declare const RateLimitQuotaUsageReports_BucketQuotaUsageSchema: GenMessage<RateLimitQuotaUsageReports_BucketQuotaUsage>;

/**
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse
 */
export declare type RateLimitQuotaResponse = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse"> & {
  /**
   * An ordered list of actions to be applied to the buckets. The actions are applied in the
   * given order, from top to bottom.
   *
   * @generated from field: repeated envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction bucket_action = 1;
   */
  bucketAction: RateLimitQuotaResponse_BucketAction[];
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.
 * Use `create(RateLimitQuotaResponseSchema)` to create a new message.
 */
export declare const RateLimitQuotaResponseSchema: GenMessage<RateLimitQuotaResponse>;

/**
 * Commands the data plane to apply one of the actions to the bucket with the
 * :ref:`bucket_id <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 *
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction
 */
export declare type RateLimitQuotaResponse_BucketAction = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction"> & {
  /**
   * ``BucketId`` for which request the action is applied.
   *
   * @generated from field: envoy.service.rate_limit_quota.v3.BucketId bucket_id = 1;
   */
  bucketId?: BucketId;

  /**
   * @generated from oneof envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_action
   */
  bucketAction: {
    /**
     * Apply the quota assignment to the bucket.
     *
     * Commands the data plane to apply a rate limiting strategy to the bucket.
     * The process of applying and expiring the rate limiting strategy is detailed in the
     * :ref:`QuotaAssignmentAction
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
     * message.
     *
     * @generated from field: envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction quota_assignment_action = 2;
     */
    value: RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction;
    case: "quotaAssignmentAction";
  } | {
    /**
     * Abandon the bucket.
     *
     * Commands the data plane to abandon the bucket.
     * The process of abandoning the bucket is described in the :ref:`AbandonAction
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
     * message.
     *
     * @generated from field: envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction abandon_action = 3;
     */
    value: RateLimitQuotaResponse_BucketAction_AbandonAction;
    case: "abandonAction";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.
 * Use `create(RateLimitQuotaResponse_BucketActionSchema)` to create a new message.
 */
export declare const RateLimitQuotaResponse_BucketActionSchema: GenMessage<RateLimitQuotaResponse_BucketAction>;

/**
 * Quota assignment for the bucket. Configures the rate limiting strategy and the duration
 * for the given :ref:`bucket_id
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 *
 * **Applying the first assignment to the bucket**
 *
 * Once the data plane receives the ``QuotaAssignmentAction``, it must send the current usage
 * report for the bucket, and start rate limiting requests matched into the bucket
 * using the strategy configured in the :ref:`rate_limit_strategy
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.rate_limit_strategy>`
 * field. The assignment becomes bucket's ``active`` assignment.
 *
 * **Expiring the assignment**
 *
 * The duration of the assignment defined in the :ref:`assignment_time_to_live
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
 * field. When the duration runs off, the assignment is ``expired``, and no longer ``active``.
 * The data plane should stop applying the rate limiting strategy to the bucket, and transition
 * the bucket to the "expired assignment" state. This activates the behavior configured in the
 * :ref:`expired_assignment_behavior <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.expired_assignment_behavior>`
 * field.
 *
 * **Replacing the assignment**
 *
 * * If the rate limiting strategy is different from bucket's ``active`` assignment, or
 *   the current bucket assignment is ``expired``, the data plane must immediately
 *   end the current assignment, report the bucket usage, and apply the new assignment.
 *   The new assignment becomes bucket's ``active`` assignment.
 * * If the rate limiting strategy is the same as the bucket's ``active`` (not ``expired``)
 *   assignment, the data plane should extend the duration of the ``active`` assignment
 *   for the duration of the new assignment provided in the :ref:`assignment_time_to_live
 *   <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
 *   field. The ``active`` assignment is considered unchanged.
 *
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction
 */
export declare type RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction"> & {
  /**
   * A duration after which the assignment is be considered ``expired``. The process of the
   * expiration is described :ref:`above
   * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.
   *
   * * If unset, the assignment has no expiration date.
   * * If set to ``0``, the assignment expires immediately, forcing the client into the
   *   :ref:`"expired assignment"
   *   <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
   *   state. This may be used by the RLQS server in cases when it needs clients to proactively
   *   fall back to the pre-configured :ref:`ExpiredAssignmentBehavior
   *   <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`,
   *   f.e. before the server going into restart.
   *
   * .. attention::
   *   Note that :ref:`expiring
   *   <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
   *   the assignment is not the same as :ref:`abandoning
   *   <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
   *   the assignment. While expiring the assignment just transitions the bucket to
   *   the "expired assignment" state; abandoning the assignment completely erases
   *   the bucket from the data plane memory, and stops the usage reports.
   *
   * @generated from field: google.protobuf.Duration assignment_time_to_live = 2;
   */
  assignmentTimeToLive?: Duration;

  /**
   * Configures the local rate limiter for the request matched to the bucket.
   * If not set, allow all requests.
   *
   * @generated from field: envoy.type.v3.RateLimitStrategy rate_limit_strategy = 3;
   */
  rateLimitStrategy?: RateLimitStrategy;
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.
 * Use `create(RateLimitQuotaResponse_BucketAction_QuotaAssignmentActionSchema)` to create a new message.
 */
export declare const RateLimitQuotaResponse_BucketAction_QuotaAssignmentActionSchema: GenMessage<RateLimitQuotaResponse_BucketAction_QuotaAssignmentAction>;

/**
 * Abandon action for the bucket. Indicates that the RLQS server will no longer be
 * sending updates for the given :ref:`bucket_id
 * <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.
 *
 * If no requests are reported for a bucket, after some time the server considers the bucket
 * inactive. The server stops tracking the bucket, and instructs the the data plane to abandon
 * the bucket via this message.
 *
 * **Abandoning the assignment**
 *
 * The data plane is to erase the bucket (including its usage data) from the memory.
 * It should stop tracking the bucket, and stop reporting its usage. This effectively resets
 * the data plane to the state prior to matching the first request into the bucket.
 *
 * **Restarting the subscription**
 *
 * If a new request is matched into a bucket previously abandoned, the data plane must behave
 * as if it has never tracked the bucket, and it's the first request matched into it:
 *
 * 1. The process of :ref:`subscription and reporting
 *    <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.reporting_interval>`
 *    starts from the beginning.
 *
 * 2. The bucket transitions to the :ref:`"no assignment"
 *    <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
 *    state.
 *
 * 3. Once the new assignment is received, it's applied per
 *    "Applying the first assignment to the bucket" section of the :ref:`QuotaAssignmentAction
 *    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.
 *
 * @generated from message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction
 */
export declare type RateLimitQuotaResponse_BucketAction_AbandonAction = Message<"envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction"> & {
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction.
 * Use `create(RateLimitQuotaResponse_BucketAction_AbandonActionSchema)` to create a new message.
 */
export declare const RateLimitQuotaResponse_BucketAction_AbandonActionSchema: GenMessage<RateLimitQuotaResponse_BucketAction_AbandonAction>;

/**
 * The identifier for the bucket. Used to match the bucket between the control plane (RLQS server),
 * and the data plane (RLQS client), f.e.:
 *
 * * the data plane sends a usage report for requests matched into the bucket with ``BucketId``
 *   to the control plane
 * * the control plane sends an assignment for the bucket with ``BucketId`` to the data plane
 *   Bucket ID.
 *
 * Example:
 *
 * .. validated-code-block:: yaml
 *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
 *
 *   bucket:
 *     name: my_bucket
 *     env: staging
 *
 * .. note::
 *   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
 *   ``{ b: 'B', a: 'A' }`` are identical.
 *
 * @generated from message envoy.service.rate_limit_quota.v3.BucketId
 */
export declare type BucketId = Message<"envoy.service.rate_limit_quota.v3.BucketId"> & {
  /**
   * @generated from field: map<string, string> bucket = 1;
   */
  bucket: { [key: string]: string };
};

/**
 * Describes the message envoy.service.rate_limit_quota.v3.BucketId.
 * Use `create(BucketIdSchema)` to create a new message.
 */
export declare const BucketIdSchema: GenMessage<BucketId>;

/**
 * Defines the Rate Limit Quota Service (RLQS).
 *
 * @generated from service envoy.service.rate_limit_quota.v3.RateLimitQuotaService
 */
export declare const RateLimitQuotaService: GenService<{
  /**
   * Main communication channel: the data plane sends usage reports to the RLQS server,
   * and the server asynchronously responding with the assignments.
   *
   * @generated from rpc envoy.service.rate_limit_quota.v3.RateLimitQuotaService.StreamRateLimitQuotas
   */
  streamRateLimitQuotas: {
    methodKind: "bidi_streaming";
    input: typeof RateLimitQuotaUsageReportsSchema;
    output: typeof RateLimitQuotaResponseSchema;
  },
}>;

