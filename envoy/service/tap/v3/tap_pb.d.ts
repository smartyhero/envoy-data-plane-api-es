// @generated by protoc-gen-es v2.10.0
// @generated from file envoy/service/tap/v3/tap.proto (package envoy.service.tap.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { TraceWrapper } from "../../../data/tap/v3/wrapper_pb";
import type { Node } from "../../../config/core/v3/base_pb";

/**
 * Describes the file envoy/service/tap/v3/tap.proto.
 */
export declare const file_envoy_service_tap_v3_tap: GenFile;

/**
 * [#not-implemented-hide:] Stream message for the Tap API. Envoy will open a stream to the server
 * and stream taps without ever expecting a response.
 *
 * @generated from message envoy.service.tap.v3.StreamTapsRequest
 */
export declare type StreamTapsRequest = Message<"envoy.service.tap.v3.StreamTapsRequest"> & {
  /**
   * Identifier data effectively is a structured metadata. As a performance optimization this will
   * only be sent in the first message on the stream.
   *
   * @generated from field: envoy.service.tap.v3.StreamTapsRequest.Identifier identifier = 1;
   */
  identifier?: StreamTapsRequest_Identifier;

  /**
   * The trace id. this can be used to merge together a streaming trace. Note that the trace_id
   * is not guaranteed to be spatially or temporally unique.
   *
   * @generated from field: uint64 trace_id = 2;
   */
  traceId: bigint;

  /**
   * The trace data.
   *
   * @generated from field: envoy.data.tap.v3.TraceWrapper trace = 3;
   */
  trace?: TraceWrapper;
};

/**
 * Describes the message envoy.service.tap.v3.StreamTapsRequest.
 * Use `create(StreamTapsRequestSchema)` to create a new message.
 */
export declare const StreamTapsRequestSchema: GenMessage<StreamTapsRequest>;

/**
 * @generated from message envoy.service.tap.v3.StreamTapsRequest.Identifier
 */
export declare type StreamTapsRequest_Identifier = Message<"envoy.service.tap.v3.StreamTapsRequest.Identifier"> & {
  /**
   * The node sending taps over the stream.
   *
   * @generated from field: envoy.config.core.v3.Node node = 1;
   */
  node?: Node;

  /**
   * The opaque identifier that was set in the :ref:`output config
   * <envoy_v3_api_field_config.tap.v3.StreamingGrpcSink.tap_id>`.
   *
   * @generated from field: string tap_id = 2;
   */
  tapId: string;
};

/**
 * Describes the message envoy.service.tap.v3.StreamTapsRequest.Identifier.
 * Use `create(StreamTapsRequest_IdentifierSchema)` to create a new message.
 */
export declare const StreamTapsRequest_IdentifierSchema: GenMessage<StreamTapsRequest_Identifier>;

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.service.tap.v3.StreamTapsResponse
 */
export declare type StreamTapsResponse = Message<"envoy.service.tap.v3.StreamTapsResponse"> & {
};

/**
 * Describes the message envoy.service.tap.v3.StreamTapsResponse.
 * Use `create(StreamTapsResponseSchema)` to create a new message.
 */
export declare const StreamTapsResponseSchema: GenMessage<StreamTapsResponse>;

/**
 * [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
 * StreamTaps to deliver captured taps to the server
 *
 * @generated from service envoy.service.tap.v3.TapSinkService
 */
export declare const TapSinkService: GenService<{
  /**
   * Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
   * response to be sent as nothing would be done in the case of failure. The server should
   * disconnect if it expects Envoy to reconnect.
   *
   * @generated from rpc envoy.service.tap.v3.TapSinkService.StreamTaps
   */
  streamTaps: {
    methodKind: "client_streaming";
    input: typeof StreamTapsRequestSchema;
    output: typeof StreamTapsResponseSchema;
  },
}>;

